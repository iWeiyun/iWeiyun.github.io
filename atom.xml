<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>微云iOS团队</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://iweiyun.github.io/"/>
  <updated>2019-01-04T03:50:53.725Z</updated>
  <id>https://iweiyun.github.io/</id>
  
  <author>
    <name>Weiyun Developer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node.js C++ Addon应用实践</title>
    <link href="https://iweiyun.github.io/2019/01/04/node-cpp-addon/"/>
    <id>https://iweiyun.github.io/2019/01/04/node-cpp-addon/</id>
    <published>2019-01-04T03:24:43.000Z</published>
    <updated>2019-01-04T03:50:53.725Z</updated>
    
    <content type="html"><![CDATA[<p>近期项目中尝试使用Electron来实现跨平台桌面客户端。由于Node.js支持c++实现native addon，将c++接口封装供js调用，我们考虑将已经被多平台使用的SDK作为native扩展库引入Electron工程。</p><p>Node.js有两套API可以供c++侧选择来实现v8接口的封装，NAN和N-API。NAN是受到广泛认可（包括Node官方）的三方接口层，内部兼容各种Node版本v8接口的变动，对外提供稳定的API，免去长期以来c++开发者升级node版本需要频繁兼容c++接口的苦恼；N-API则是Node官方自行推出的新接口层，并非取代原有接口，而是旨在提供更稳定更贴近c风格的API，同样是为了避免c++开发者频繁改动，更利于生态圈的发展。由于我们在启动Electron版本的计划时，Electron的稳定版本使用的8.9.x版本的Node.js，该版本的官方文档中，N-API还处于实验阶段，权衡之后，我们在几个重要的SDK中使用成熟稳定的NAN来为我们electron桌面端提供native封装模块；后续一些新增的小模块，则尝试使用N-API来实现。</p><p>​    </p><hr><h3 id="c-addon的本质"><a href="#c-addon的本质" class="headerlink" title="c++ addon的本质"></a>c++ addon的本质</h3><p>在编写自己的addon模块之前，可以随便拿一个.node文件来探查一下它的本质究竟是什么。直接查看一个.node文件的二进制数据，结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFFAEDFE 07000001 03000000 08000000 0D000000 30070000 85800100 00000000 19000000 C8020000 5F5F5445 58540000 00000000 00000000 00000000 00000000 00D01D00 00000000 00000000 00000000 00D01D00 00000000 07000000 05000000 08000000 ...</span><br></pre></td></tr></table></figure><p>可以看到文件头标识有0xCFFAEDFE，根据<a href="https://opensource.apple.com/source/xnu/xnu-792/EXTERNAL_HEADERS/mach-o/loader.h头文件中的定义" target="_blank" rel="noopener">https://opensource.apple.com/source/xnu/xnu-792/EXTERNAL_HEADERS/mach-o/loader.h头文件中的定义</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Constant for the magic field of the mach_header_64 (64-bit architectures) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_MAGIC_640xfeedfacf<span class="comment">/* the 64-bit mach magic number */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CIGAM_64NXSwapInt(MH_MAGIC_64)   <span class="comment">//0xcffaedfe （little-endian）</span></span></span><br></pre></td></tr></table></figure><p>这串标识是苹果Mach-O文件在64位机器上的魔数，表明.node文件在mac平台上是一个Mach-O文件，我们可以通过lipo/otool/nm等工具对其结构进行查看。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ otool -hv DemoSDK.node</span><br><span class="line">Mach header</span><br><span class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</span><br><span class="line">MH_MAGIC_64  X86_64        ALL  0x00      BUNDLE    23       4088   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK</span><br></pre></td></tr></table></figure><p>.node文件mach header中的fileType是MH_BUNDLE，也即.node文件是一个Bundle类型的动态库。一般此类动态库用于在运行时加载，允许被作为插件动态扩展程序的行为。Bundle类型动态库的后缀名可以自行指定，生成的库若不携带资源，也可以选择不生成类似framework那样的目录结构，而只输出一个二进制文件（相当于只能显式加载的.dylib）。这就是.node模块的本质，同样在windows上，.node模块实质就是一个dll。至此，mac开发者似乎都嗅到了一股熟悉的味道。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Loads a module at the given file path. Returns that module's</span></span><br><span class="line"><span class="comment">// `exports` property.</span></span><br><span class="line">Module.prototype.require = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  assert(path, <span class="string">'missing path'</span>);</span><br><span class="line">  assert(<span class="keyword">typeof</span> path === <span class="string">'string'</span>, <span class="string">'path must be a string'</span>);</span><br><span class="line">  <span class="keyword">return</span> Module._load(path, <span class="keyword">this</span>, <span class="comment">/* isMain */</span> <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Given a file name, pass it to the proper extension handler.</span></span><br><span class="line">Module.prototype.load = <span class="function"><span class="keyword">function</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  assert(!<span class="keyword">this</span>.loaded);</span><br><span class="line">  <span class="keyword">this</span>.filename = filename;</span><br><span class="line">  <span class="keyword">this</span>.paths = Module._nodeModulePaths(path.dirname(filename));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> extension = path.extname(filename) || <span class="string">'.js'</span>;</span><br><span class="line">  <span class="keyword">if</span> (!Module._extensions[extension]) extension = <span class="string">'.js'</span>;</span><br><span class="line">  Module._extensions[extension](<span class="keyword">this</span>, filename);</span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">true</span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Native extension for .node</span></span><br><span class="line">Module._extensions[<span class="string">'.node'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">module, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> process.dlopen(<span class="built_in">module</span>, path._makeLong(filename));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在node源码中找到require()方法的实现，require()调用了_load()方法，_load()方法检查该模块是否已存在缓存，如果需要执行载入，则调用真正的加载方法load()。这表明一个c++模块在整个node进程中的引入是全局唯一的，node底层会对每一个导入的c++模块进行缓存，这是高效且合理的。Module.load()方法里面主要对加载路径进行了处理。对于c++ 模块来说，会执行Module._extensions[‘.node’] 的闭包，即调用process.dlopen来动态加载模块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DLOpen is process.dlopen(module, filename).</span></span><br><span class="line"><span class="comment">// Used to load 'module.node' dynamically shared objects.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DLOpen</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">  Environment* env = Environment::GetCurrent(args);</span><br><span class="line">  <span class="keyword">uv_lib_t</span> lib;</span><br><span class="line"> ...</span><br><span class="line">  Local&lt;Object&gt; <span class="keyword">module</span> = args[<span class="number">0</span>]-&gt;ToObject(env-&gt;isolate());  <span class="comment">// Cast</span></span><br><span class="line">  node::Utf8Value filename(env-&gt;isolate(), args[1]);  // Cast</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> is_dlopen_error = uv_dlopen(*filename, &amp;lib);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在node.cc文件中可以看到，process.dlopen对应的c++函数为DLOpen()，这个是Node程序一启动就注册好的。DLOpen()函数实际上是调用了libuv库的uv_dlopen()方法。libuv库是个跨平台库，其unix版本代码调用了系统函数dlopen() 。顺带一提，在windows上，uv_dlopen也是调用了系统函数LoadLibraryExW()来实现c++模块的导入。</p><p>​    </p><hr><h3 id="用node-gyp构建c-addon"><a href="#用node-gyp构建c-addon" class="headerlink" title="用node-gyp构建c++ addon"></a>用node-gyp构建c++ addon</h3><p>构建一个c++ addon模块，一般是通过node-gyp命令行工具来执行。其实早期是用另外一款工具的，不过过去的就让他过去吧…构建c++addon时，node-gyp会根据binding.gyp配置文件调用各平台上的编译工具集来进行编译，mac上是Xcode Command Line Tools，windows上则是Visual Studio。<br>​<br>不论是window还是mac平台上，在安装了Node环境后，都可以方便地通过npm来全局安装node-gyp</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g node-gyp</span><br></pre></td></tr></table></figure><p>node-gyp 的常用命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> node-addon-root-directory</span><br><span class="line">$ node-gyp clean configure build --debug --silly  <span class="comment">#node</span></span><br><span class="line">$ node-gyp clean configure build --target=2.0.2 --arch=x64 --dist-url=https://atom.io/download/atom-shell  <span class="comment">#electron</span></span><br></pre></td></tr></table></figure><p>clean: 用于清空build缓存</p><p>configure: 根据binding.gyp文件进行编译链接相关的配置</p><p>build: 则启动构建过程</p><p>rebuild：包含了clean configure build 三个命令的集合操作</p><p>比较常见的选项：</p><p>—debug: 表明目标将构建为debug版本， 默认为release版本</p><p>—silly: 输出全部构建日志详情，包括所有编译链接选项和进度等</p><p>—target —arch —diet-url: 用于指定一个具体的版本的node进行编译，若要指定electron对应的node版本可以加上这些参数</p><p>—msvs_version 用于windows上指定vs版本</p><p>node-gyp的其他命令及选项可以参考 <a href="https://github.com/nodejs/node-gyp" target="_blank" rel="noopener">https://github.com/nodejs/node-gyp</a></p><p>binding.gyp文件的结构很简单，其实就是json格式的配置文件。一般实际工程中涉及的配置大体是下面这个样子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"targets"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"target_name"</span>: <span class="string">"DemoSDK"</span>,</span><br><span class="line">            <span class="attr">"sources"</span>: [</span><br><span class="line">                <span class="string">"DemoSDK4Node.cpp"</span>, </span><br><span class="line">...</span><br><span class="line">                ],</span><br><span class="line">            <span class="attr">"include_dirs"</span>: [</span><br><span class="line">                <span class="string">"&lt;!(node -e \"require('nan')\")"</span>,</span><br><span class="line">                <span class="string">"DemoSDK/src/"</span>,</span><br><span class="line">                ...</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"libraries"</span>: [</span><br><span class="line">                <span class="string">"../Libraries/mac/lib.a"</span>,</span><br><span class="line">                <span class="string">"-F../Libraries/mac -framework DemoLib"</span>,</span><br><span class="line">                ...</span><br><span class="line">                ], </span><br><span class="line">            <span class="attr">"defines"</span>: [</span><br><span class="line">                ...</span><br><span class="line">            ],</span><br><span class="line">            'conditions': [</span><br><span class="line">                ['OS==<span class="string">"mac"</span>', &#123;</span><br><span class="line">                    'configurations': &#123;</span><br><span class="line">                        'Debug': &#123;</span><br><span class="line">                            "xcode_settings": &#123;</span><br><span class="line">                                "GCC_OPTIMIZATION_LEVEL": "0",</span><br><span class="line">                                "DEPLOYMENT_POSTPROCESSING": "NO",</span><br><span class="line">                                "GCC_GENERATE_DEBUGGING_SYMBOLS": "YES",</span><br><span class="line">                "GCC_SYMBOLS_PRIVATE_EXTERN" : "YES",</span><br><span class="line">                                "DEBUG_INFORMATION_FORMAT": "dwarf",</span><br><span class="line">                                "GCC_ENABLE_CPP_RTTI": "YES",</span><br><span class="line">                                "GCC_ENABLE_CPP_EXCEPTIONS": "YES",</span><br><span class="line">                                "OTHER_CPLUSPLUSFLAGS" : [ '-ObjC++', "-std=c++11", "-stdlib=libc++",  "-fobjc-arc", '-fvisibility=hidden'],</span><br><span class="line">                                "OTHER_LDFLAGS": [ "-stdlib=libc++"],</span><br><span class="line">                                "MACOSX_DEPLOYMENT_TARGET": "10.10"</span><br><span class="line">                            &#125;   </span><br><span class="line">                        &#125;,</span><br><span class="line">                        'Release': &#123;</span><br><span class="line">                            "xcode_settings": &#123;</span><br><span class="line">                                "GCC_OPTIMIZATION_LEVEL": "s",</span><br><span class="line">                                "COPY_PHASE_STRIP": "YES",</span><br><span class="line">                                "DEAD_CODE_STRIPPING": "YES",</span><br><span class="line">                                "DEPLOYMENT_POSTPROCESSING": "YES",</span><br><span class="line">                                "GCC_GENERATE_DEBUGGING_SYMBOLS": "YES",</span><br><span class="line">        "GCC_SYMBOLS_PRIVATE_EXTERN" : "YES",</span><br><span class="line">                                "STRIP_INSTALLED_PRODUCT": "YES",</span><br><span class="line">                                "STRIP_STYLE": "non-global",</span><br><span class="line">                                "DEBUG_INFORMATION_FORMAT": "dwarf-with-dsym",</span><br><span class="line">                                "LD_GENERATE_MAP_FILE" : "YES",</span><br><span class="line">                                "GCC_ENABLE_CPP_RTTI": "YES",</span><br><span class="line">                                "GCC_ENABLE_CPP_EXCEPTIONS": "YES",</span><br><span class="line">                                "OTHER_CPLUSPLUSFLAGS" : [ '-ObjC++', "-std=c++11", "-stdlib=libc++",  "-fobjc-arc", '-fvisibility=hidden'],</span><br><span class="line">                                "OTHER_LDFLAGS": [ "-stdlib=libc++"],</span><br><span class="line">                                "MACOSX_DEPLOYMENT_TARGET": "10.10"</span><br><span class="line">                            &#125;   </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;],</span><br><span class="line">                ['OS==<span class="string">"win"</span>', &#123;</span><br><span class="line">                    'configurations': &#123;</span><br><span class="line">                'Debug': &#123;</span><br><span class="line">                    "msvs_settings": &#123;</span><br><span class="line">                                "VCCLCompilerTool": &#123;</span><br><span class="line">                                    "RuntimeLibrary": "3", </span><br><span class="line">                        "RuntimeTypeInfo": "true"</span><br><span class="line">                                &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                'Release': &#123;</span><br><span class="line">                            "msvs_settings": &#123;</span><br><span class="line">                                "VCCLCompilerTool": &#123;</span><br><span class="line">                                    "RuntimeLibrary": "2", </span><br><span class="line">                        "RuntimeTypeInfo": "true"</span><br><span class="line">                                &#125;,</span><br><span class="line">                            &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;]</span><br><span class="line">            ] </span><br><span class="line">        &#125;,</span><br><span class="line">&#123;</span><br><span class="line">    ... #other targets</span><br><span class="line">&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“target”： binding.gyp允许你一次配置若干个addon，每一个addon均是一个target。对于一个target，必须要指定”target_name”，最终生成的addon会被命名为target_name.node。</p><p>“sources”：指定了需要编译的所有源文件。</p><p>“include_dirs”：指定头文件查找目录。是不是发现上面的include_dirs下有一行奇怪的东西 “&lt;!(node -e \”require(‘nan’)\”)”，这是通过npm安装nan时自动写入的，&lt;!(cmd)或&lt;!@(cmd)实际上是在执行括号内的shell命令，将得到的nan路径”node_modules/nan”返回。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -e <span class="string">"require('nan')"</span></span><br><span class="line">node_modules/nan</span><br></pre></td></tr></table></figure><p>“defines”：指定预处理宏。</p><p>“libraries”：指定需要链接的库，对于.a、.dylib这类非bundle结构形式的链接库，直接设置相对路径即可；对于具有完整bundle目录结构的framework，则可以通过”-F ‘Framework Path’ -framework ‘Framework Name’ “的方式来找到</p><p>“conditions”：允许你设置各种判断条件，它其实可以出现在整个.gyp文件的任何地方，并且当.gyp文件被加载后就会优先对内部的条件语句进行处理。这里主要用于区分系统平台，以便根据平台分别对xcode和vs进行相关设定</p><p>“configurations”：分别可以对debug版本和release版本进行编译选项的设定</p><p>其他gyp配置文件的具体格式可以参考gyp的官方文档： <a href="https://gyp.gsrc.io/docs/UserDocumentation.md，不过很多找不到的还请努力谷歌。" target="_blank" rel="noopener">https://gyp.gsrc.io/docs/UserDocumentation.md，不过很多找不到的还请努力谷歌。</a></p><p>​    </p><hr><h3 id="c-addon的编写"><a href="#c-addon的编写" class="headerlink" title="c++ addon的编写"></a>c++ addon的编写</h3><h4 id="NAN的使用"><a href="#NAN的使用" class="headerlink" title="NAN的使用"></a>NAN的使用</h4><p>先来说说NAN的方式编写addon。NAN的引入十分方便，根据nan的官方文档，只需要通过npm在工程目录下安装即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br><span class="line">npm install --save nan</span><br></pre></td></tr></table></figure><p>Node.js c++ addon和nan的基本用法和封装示例均可以在 <a href="https://github.com/nodejs/node-addon-examples" target="_blank" rel="noopener">https://github.com/nodejs/node-addon-examples</a> 和Node.js官方文档中找到，没有比这些更好的入门参考了。根据这些例子和文档，基本可以搞清楚v8引擎中类似isolate、context、handlescope、local/persistent handle的概念，基本上是必看的。这些例子就不贴出来了，下面提一下我们在应用中遇到的一些问题及处理方法。</p><h4 id="通过libuv异步回调js主线程"><a href="#通过libuv异步回调js主线程" class="headerlink" title="通过libuv异步回调js主线程"></a>通过libuv异步回调js主线程</h4><p>node.js是单线程的，网络及数据库异步请求的回包，需要在v8引擎主线程才能执行js回调方法。v8引擎底层依赖libuv实现了异步事件的循环和分发。libuv主要维护了一系列event loop，js代码均执行在默认主循环uv_default_loop中，native addon执行js回调都需要抛到该loop中执行，并且避免在uv_default_loop中执行耗时操作。<br>​<br>因此，需要封装一个单独的类用于将所有异步任务传递给uv_default_loop。可以实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AsyncHandleData</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;&gt; taskList;</span><br><span class="line">    <span class="built_in">std</span>::recursive_mutex mtx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V8TaskService</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    V8TaskService() &#123;</span><br><span class="line">        _async.data = <span class="keyword">new</span> AsyncHandleData;</span><br><span class="line">        uv_async_init(uv_default_loop(), &amp;_async, [](<span class="keyword">uv_async_t</span> *handle)&#123;</span><br><span class="line">            AsyncHandleData *handleData = (AsyncHandleData *)handle-&gt;data;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;&gt; excuteList;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::recursive_mutex&gt; lock(handleData-&gt;mtx);</span><br><span class="line">                <span class="keyword">while</span> (handleData-&gt;taskList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    excuteList.push_back(handleData-&gt;taskList.front());</span><br><span class="line">                    handleData-&gt;taskList.pop_front();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (excuteList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                excuteList.front()();</span><br><span class="line">                excuteList.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~V8TaskService() &#123;</span><br><span class="line">        uv_close((<span class="keyword">uv_handle_t</span> *)&amp;_async, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">delete</span> (AsyncHandleData *)_async.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defaultLoopAsync</span><span class="params">(Func&amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; task = [=]() &#123;</span><br><span class="line">            f(args...);</span><br><span class="line">        &#125;;</span><br><span class="line">        AsyncHandleData *handleData = (AsyncHandleData *)_async.data;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::recursive_mutex&gt; lock(handleData-&gt;mtx);</span><br><span class="line">            handleData-&gt;taskList.push_back(task);</span><br><span class="line">        &#125;</span><br><span class="line">        uv_async_send(&amp;_async);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">uv_async_t</span> _async;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先，在V8TaskService的构造方法中创建一个uv_async_t类型的异步句柄，该句柄大概的结构如下。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//libuv - uv.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uv_async_t</span> &#123;</span></span><br><span class="line">  <span class="comment">/* public */</span>                                                                </span><br><span class="line">  <span class="keyword">void</span>* data;       <span class="comment">//携带数据</span></span><br><span class="line">  <span class="comment">/* read-only */</span>    </span><br><span class="line">  <span class="keyword">uv_loop_t</span>* loop;    <span class="comment">//绑定执行loop</span></span><br><span class="line">  uv_handle_type type;  </span><br><span class="line">  <span class="comment">/* private */</span>   </span><br><span class="line">  uv_async_cb async_cb;     </span><br><span class="line">  <span class="keyword">int</span> pending;  </span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>句柄的data变量是唯一公开可以读写的数据字段，用于在不同循环间传递数据。在_async中，我们写入一个队列，存储native层回来的异步操作。<br>​<br>接着调用uv_async_init()方法分别将js的主循环uv_default_loop和传入的callback绑定到句柄_async的loop和async_cb变量上。<br>​<br>当有异步任务回来时，通过成员方法defaultLoopAsync()来切到js的主线程。该方法往_async的data里写入新的数据，并执行uv_async_send()方法，通知libuv的eventloop在主循环处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//libuv - async.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_async_send</span><span class="params">(<span class="keyword">uv_async_t</span>* handle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ACCESS_ONCE(<span class="keyword">int</span>, handle-&gt;pending) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cmpxchgi(&amp;handle-&gt;pending, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">    uv__async_send(handle-&gt;loop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于网络和数据库层异步回调可能非常频繁，短时间内多次调用uv_async_send()方法，并不会获得相应次数的执行机会。查看uv_async_send()接口的实现，当handle本身的pending值还是非0值，就表明之前的发送事件并未得到处理，因此不会得到机会执行uv__async_send()这个内部接口来驱动目标loop。就因为这个机制，只能保证若有N个异步事件发送，至少能得到一次执行async_cb回调的机会。因为，我们需要自己维护一个队列，来保证每次触发时，native内所有发送的回调都能得到执行。</p><h4 id="异步js回调与Persistent-Handle"><a href="#异步js回调与Persistent-Handle" class="headerlink" title="异步js回调与Persistent Handle"></a>异步js回调与Persistent Handle</h4><p>解决了addon异步回调到js主线程的问题，还需要考虑的就是在执行js传递下来的的callback函数了。addon所有注册给js调用的接口，都只有一个v8::FunctionCallbackInfo\<a href="v8::Value\" target="_blank" rel="noopener">v8::Value\</a>类型的参数，所有js实际传递的参数、返回值的引用及JS对象本身的引用都被包含在内。</p><p>js调用接口时传递的参数通过info[i]即可依次获取，一般进行类型检查后，即可转换成对应的Local Handle对象。前面提到过，在创建Local Handle对象前，需要声明一个HandleScope，用来管理这些Local Handle对象的生命周期。当HandleScope离开函数作用域而被销毁时，会回收所有Local Handle对象，自然包括js传下来的v8::Function类型的回调函数。这里需要用一个Persistent Handle对象来延长该闭包的生命周期，v8::Persistent\<t>默认是NonCopyablePersistentTraits，禁用了拷贝构造，无法直接被lambda值捕获，只能传递v8::Persistent\<a href="v8::Function\" target="_blank" rel="noopener">v8::Function\</a>的指针；同时，NonCopyablePersistentTraits析构时不会主动为内存中对象染色，所以这里还需要传递一个deleter给智能指针，在析构时调用Reset()方法，便于v8的GC适时销毁这个persistent对象。</t></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">NAN_METHOD(DemoSDK::someTimeConsumingMethod) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(info[<span class="number">0</span>]-&gt;IsNullOrUndefined() || !info[<span class="number">1</span>]-&gt;IsFunction()) &#123;</span><br><span class="line">        Nan::ThrowError(<span class="string">"invalid parameters"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Nan::HandleScope scope;</span><br><span class="line">    std::string req(BIN(*v8::String::Utf8Value(info[0])));</span><br><span class="line">    v8::Local&lt;v8::Function&gt; callback = v8::Local&lt;v8::Function&gt;::Cast(info[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">auto</span> persistentCallback = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Nan::Persistent&lt;v8::Function&gt; &gt;(<span class="keyword">new</span> Nan::Persistent&lt;v8::Function&gt;(callback),[](Nan::Persistent&lt;v8::Function&gt; * callback)  &#123;</span><br><span class="line">        callback-&gt;Reset();</span><br><span class="line">        <span class="keyword">delete</span> callback;</span><br><span class="line">        callback = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    RealTimeConsumingMethod(req, [=] (RspListType* rspList, <span class="keyword">int</span> error) &#123;</span><br><span class="line">        service-&gt;defaultLoopAsync([=]()&#123;</span><br><span class="line">            Nan::HandleScope scope;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;v8::Local&lt;v8::Value&gt;&gt; argv;</span><br><span class="line">            argv.emplace_back(Nan::New(errorcode));</span><br><span class="line"></span><br><span class="line">            v8::Local&lt;v8::Array&gt; rspArray = Nan::New&lt;v8::Array&gt;();</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> item : *rspList) &#123;</span><br><span class="line">            rspArray-&gt;Set(index++, V8Item::newInstance(item));</span><br><span class="line">            &#125;</span><br><span class="line">            argv.emplace_back(rspArray);</span><br><span class="line">            argv.emplace_back(Nan::New(error));</span><br><span class="line">            </span><br><span class="line">            persistentCallback-&gt;Get(v8::Isolate::GetCurrent())-&gt;Call(Nan::GetCurrentContext()-&gt;Global(), argv.size(), argv.data());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Local-Handle作为返回值"><a href="#Local-Handle作为返回值" class="headerlink" title="Local Handle作为返回值"></a>Local Handle作为返回值</h4><p>我们知道Local Handle的生命周期被容器Handle Scope管理，意味着当我们需要将Local Handle作为返回值传递时，由于Handle Scope被析构，内部所有Local Handle包括当前的返回值都随时会被GC清理。<br>​<br>但是，就如下文会提到为自定义数据结构进行封装时，不可避免地会将Local Handle作为返回值处理。这个时候，我们需要用一种EscapableHandleScope来管理这些Local Handle，这种Scope允许Local Handle“逃离”自己的管理。通过Escape()方法，将要”逃离”的参数拷贝到一个封闭的scope中，之后当前的EscapableHandleScope仍然会标记其内部所有Local Handle继而被GC清理，实际返回刚才的副本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v8::Local&lt;v8::Value&gt; V8Item::newInstance() &#123;</span><br><span class="line">Nan::EscapableHandleScope scope;</span><br><span class="line">v8::Local&lt;v8::Function&gt; cons = Nan::New&lt;v8::Function&gt;(constructor);</span><br><span class="line"><span class="keyword">return</span> scope.Escape(cons-&gt;NewInstance(Nan::GetCurrentContext()).ToLocalChecked());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Mac平台OC-RunLoop与uv-default-loop"><a href="#Mac平台OC-RunLoop与uv-default-loop" class="headerlink" title="Mac平台OC RunLoop与uv_default_loop"></a>Mac平台OC RunLoop与uv_default_loop</h4><p>我们的addon中还引入了一些三方framework，在mac平台下有些framework有相当一部分模块使用Objective-C来实现，当我们提供这些三方库的Objective-C接口给js调用时，需要先用c++层包装oc接口，再进行v8层的封装。</p><p>不过，由于个别OC库的内部实现涉及通过GCD分发到Main Queue处理异步代码，libuv的事件系统并不会执行OC的MainRunLoop，从而会导致这类库无法使用。更改并维护三方库的代码并不是一个很好的方案，我们选择定时在libuv的uv_default_loop中手动插入RunLoop，使库中分发到主线程的异步回调得到执行的机会。RunLoop插入的时间间隔由addon层未完成的wns请求量来动态变化。为了避免卡住node.js的主线程，目前只能选择runMode:beforeDate:的方式来启动RunLoop，确保只执行一次，以处理所有GCD分发到Main Queue的任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeiyunOCRunLoopContext.h</span></span><br><span class="line"><span class="keyword">enum</span> RunLoopFrequencyLevel &#123;</span><br><span class="line">    RunLoopFrequencyLevelLow = <span class="number">0</span>,</span><br><span class="line">    RunLoopFrequencyLevelMedium,</span><br><span class="line">    RunLoopFrequencyLevelHigh</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OCRunLoopContext</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    OCRunLoopContext();</span><br><span class="line">    ~OCRunLoopContext();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateRunLoopFrequencyLevel</span><span class="params">(RunLoopFrequencyLevel level)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initRunLoopContext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">delayForFrequencyLevel</span><span class="params">(RunLoopFrequencyLevel level)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">bool</span>&gt; _future;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; _finish;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;RunLoopFrequencyLevel&gt; _level;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;V8TaskService&gt; _service;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _delays;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// WeiyunOCRunLoopContext.mm</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_OC_RUNLOOP_DELAY_HIGH    100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_OC_RUNLOOP_DELAY_MEDIUM  300</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_OC_RUNLOOP_DELAY_LOW     500</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;V8TaskService&gt; OCRunLoopContext::_service = <span class="built_in">std</span>::make_shared&lt;V8TaskService&gt;();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; OCRunLoopContext::_delays = &#123; DEFAULT_OC_RUNLOOP_DELAY_LOW, DEFAULT_OC_RUNLOOP_DELAY_MEDIUM, DEFAULT_OC_RUNLOOP_DELAY_HIGH &#125;;</span><br><span class="line"></span><br><span class="line">OCRunLoopContext::OCRunLoopContext(): _finish(<span class="literal">false</span>), _level(RunLoopFrequencyLevelHigh) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;initRunLoopContext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> OCRunLoopContext::initRunLoopContext() &#123;</span><br><span class="line"></span><br><span class="line">    _future = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, [<span class="keyword">this</span>]()&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> loopDelay = _delays[_level.load(<span class="built_in">std</span>::memory_order_relaxed)];</span><br><span class="line">            <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(loopDelay));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_finish.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _service-&gt;defaultLoopAsync([]()&#123;</span><br><span class="line">                @autoreleasepool &#123;</span><br><span class="line">                    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate date]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OCRunLoopContext::~OCRunLoopContext() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_finish.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    _future.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> OCRunLoopContext::updateRunLoopFrequencyLevel(RunLoopFrequencyLevel level) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_level.store(level, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><hr><h3 id="N-API的尝试"><a href="#N-API的尝试" class="headerlink" title="N-API的尝试"></a>N-API的尝试</h3><p>项目中写过一些小的c++ addon模块，尝试使用了N-API的接口来实现。这种方式与Nan没有本质区别。要使用N-API接口，只需要引入node_api.h这个头文件即可。N-API接口和数据结构非常规范，将所有底层的v8原生数据结构封装起来，调用起来形式统一。比如要实现一个native的事件监控模块，内部有一个供js调用的EventMonitor类，并提供了添加注册监控的方法，该方法返回一个handler的id，代码可以有如下写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># NodeEventMonitor.h</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeEventMonitor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> napi_value <span class="title">Init</span><span class="params">(napi_env env, napi_value exports)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Destructor</span><span class="params">(napi_env env, <span class="keyword">void</span> * nativeObject, <span class="keyword">void</span> *finalize_hint)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NodeEventMonitor</span><span class="params">()</span></span>;</span><br><span class="line">    ~NodeEventMonitor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> napi_value <span class="title">New</span><span class="params">(napi_env env, napi_callback_info info)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> napi_value <span class="title">RegisterMonitor</span><span class="params">(napi_env env, napi_callback_info info)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> napi_ref constructor;</span><br><span class="line">    napi_env env_;</span><br><span class="line">    napi_ref wrapper_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"># NodeEventMonitor.mm</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAPI_CHECK_STATUS(x) assert(x == napi_ok);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_NAPI_METHOD(name, func) &#123; name, 0, func, 0, 0, 0, napi_default, 0 &#125;</span></span><br><span class="line"></span><br><span class="line">napi_ref NodeEventMonitor::constructor;</span><br><span class="line">NodeEventMonitor::NodeEventMonitor(): env_(<span class="literal">nullptr</span>), wrapper_(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NodeEventMonitor::~NodeEventMonitor() &#123;</span><br><span class="line">    napi_delete_reference(env_, wrapper_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NodeEventMonitor::Destructor(napi_env env, <span class="keyword">void</span> *nativeObject, <span class="keyword">void</span> *finalize_hint) &#123;</span><br><span class="line">    <span class="keyword">reinterpret_cast</span>&lt;NodeEventMonitor *&gt;(nativeObject)-&gt;~NodeEventMonitor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">napi_value NodeEventMonitor::Init(napi_env env, napi_value exports) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;napi_property_descriptor&gt; properties = &#123;</span><br><span class="line">        DECLARE_NAPI_METHOD(<span class="string">"registerMonitor"</span>, RegisterMonitor),</span><br><span class="line">    &#125;;</span><br><span class="line">    napi_value cons;</span><br><span class="line">    NAPI_CHECK_STATUS(napi_define_class(env, <span class="string">"EventMonitor"</span>, NAPI_AUTO_LENGTH, New, <span class="literal">nullptr</span>, properties.size(), properties.data(), &amp;cons));</span><br><span class="line">    NAPI_CHECK_STATUS(napi_create_reference(env, cons, <span class="number">1</span>, &amp;constructor));</span><br><span class="line">    NAPI_CHECK_STATUS(napi_set_named_property(env, exports, <span class="string">"EventMonitor"</span>, cons));</span><br><span class="line">    <span class="keyword">return</span> exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">napi_value NodeEventMonitor::New(napi_env env, napi_callback_info info) &#123;</span><br><span class="line"></span><br><span class="line">    napi_value target;</span><br><span class="line">    NAPI_CHECK_STATUS(napi_get_new_target(env, info, &amp;target));</span><br><span class="line">    <span class="keyword">bool</span> is_constructor = target != <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_constructor) &#123;   <span class="comment">// 'new NodeEventMonitor()'</span></span><br><span class="line">        <span class="keyword">size_t</span> argc = <span class="number">1</span>;</span><br><span class="line">        napi_value args[<span class="number">1</span>];</span><br><span class="line">        napi_value js_this;</span><br><span class="line">        NAPI_CHECK_STATUS(napi_get_cb_info(env, info, &amp;argc, args, &amp;js_this, <span class="literal">nullptr</span>));</span><br><span class="line">        NodeEventMonitor *obj = <span class="keyword">new</span> NodeEventMonitor();</span><br><span class="line">        obj-&gt;env_ = env;</span><br><span class="line">        NAPI_CHECK_STATUS(napi_wrap(env, js_this, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(obj), NodeEventMonitor::Destructor, <span class="literal">nullptr</span>, &amp;obj-&gt;wrapper_));</span><br><span class="line">        <span class="keyword">return</span> js_this;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">size_t</span> argc_ = <span class="number">1</span>;</span><br><span class="line">        napi_value args[<span class="number">1</span>];</span><br><span class="line">        NAPI_CHECK_STATUS(napi_get_cb_info(env, info, &amp;argc_, args, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> argc = <span class="number">1</span>;</span><br><span class="line">        napi_value argv[argc] = &#123; args[<span class="number">0</span>] &#125;;</span><br><span class="line">        napi_value cons;</span><br><span class="line">        NAPI_CHECK_STATUS(napi_get_reference_value(env, constructor, &amp;cons));</span><br><span class="line"></span><br><span class="line">        napi_value instance;</span><br><span class="line">        NAPI_CHECK_STATUS(napi_new_instance(env, cons, argc, argv, &amp;instance));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">napi_value NodeEventMonitor::RegisterMonitor(napi_env env, napi_callback_info info) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> argc = <span class="number">1</span>;</span><br><span class="line">    napi_value args[<span class="number">1</span>];</span><br><span class="line">    napi_value js_this;</span><br><span class="line">    NAPI_CHECK_STATUS(napi_get_cb_info(env, info, &amp;argc, args, &amp;js_this, <span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    napi_value callback = args[<span class="number">0</span>];</span><br><span class="line">    napi_ref callbackRef;</span><br><span class="line">    NAPI_CHECK_STATUS(napi_create_reference(env, callback, <span class="number">1</span>, &amp;callbackRef));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> handlerId = [EventMonitor.defaultMonitor registerLocalMonitor:[=](<span class="keyword">int</span> type) &#123;</span><br><span class="line"></span><br><span class="line">        napi_value result;</span><br><span class="line"></span><br><span class="line">        napi_value argv[<span class="number">1</span>];</span><br><span class="line">        NAPI_CHECK_STATUS(napi_create_int32(env, type, argv));</span><br><span class="line"></span><br><span class="line">        napi_value global;</span><br><span class="line">        NAPI_CHECK_STATUS(napi_get_global(env, &amp;global));</span><br><span class="line"></span><br><span class="line">        napi_value callback;</span><br><span class="line">        NAPI_CHECK_STATUS(napi_get_reference_value(env, callbackRef, &amp;callback));</span><br><span class="line"></span><br><span class="line">        NAPI_CHECK_STATUS(napi_call_function(env, global, callback, <span class="number">1</span>, argv, &amp;result));</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    napi_value retValue;</span><br><span class="line">    NAPI_CHECK_STATUS(napi_create_uint32(env, handlerId, &amp;retValue));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分实现都参考自官方文档和例子，简单说明一下笔者的看法。首先看到NAPI_CHECK_STATUS宏定义，这里是笔者觉得不太习惯但又非常合理的地方：每一次N-API调用都会有一个napi_status类型的状态返回值，及时处理好每一次调用的可能发生的错误非常关键。所有node.js层传下来的参数、回调信息以及js对象指针都被保存在napi_callback_info中，这点和NAN和c++ Addon API的调用方式一致。napi_env笔者就理解为类似v8::Isolate和v8::Context这样的执行上下文环境，我们只要保存好并适时传递给N-API接口即可，无需过于关心具体代表的内容。napi_value封装了各种常见v8数据类型，是一个生命周期受napi_handle_scope控制的指针，类似于Local Handle的使用方式。那么如何将一个Local Handle持久化，笔者目前找到的方法是使用napi_ref类型来实现类似的持久化数据的效果，napi_ref可以为napi_value增加引用计数来延长其生命周期，也可以手动减少计数来使其标记等待GC，是否存在其他方式待后续工程中大范围使用时再深入研究一下。<br>​<br>总体而言，N-API的接口简洁、规范，在该API稳定的node.js版本下可以考虑用于正式开发了，不过想要了解更好了解v8引擎的一些底层的实现和原理，同时可以考虑使用NAN和Node Addon API来加深理解。两种方式的开发效率就笔者个人而言，目前看来相差无几，当然在v8中的性能也自然没有差别。</p><p>​    </p><hr><h3 id="c-addon在mac平台的调试和编译优化"><a href="#c-addon在mac平台的调试和编译优化" class="headerlink" title="c++ addon在mac平台的调试和编译优化"></a>c++ addon在mac平台的调试和编译优化</h3><h4 id="c-addon的调试"><a href="#c-addon的调试" class="headerlink" title="c++ addon的调试"></a>c++ addon的调试</h4><p>mac平台上，若要调试被载入Electron或Node程序的c++ addon模块，就需要用到lldb调试工具。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># node</span></span><br><span class="line">$ lldb node index.js</span><br><span class="line">(lldb) target create <span class="string">"node"</span></span><br><span class="line">Current executable <span class="built_in">set</span> to <span class="string">'node'</span> (x86_64).</span><br><span class="line">(lldb) settings <span class="built_in">set</span> -- target.run-args  <span class="string">"index.js"</span></span><br><span class="line">(lldb) run</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># electron</span></span><br><span class="line">$ lldb</span><br><span class="line">(lldb) target create <span class="string">"./electron-app/node_modules/electron/dist/Electron.app"</span></span><br><span class="line">Current executable <span class="built_in">set</span> to <span class="string">'./electron-app/node_modules/electron/dist/Electron.app'</span> (x86_64).</span><br><span class="line">(lldb) setting <span class="built_in">set</span> -- target.run-args <span class="string">"./electron-app/xplatform/dist/"</span></span><br><span class="line">(lldb) run</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>类似gdb，mac上的lldb十分强大。只需要在命令行中启动lldb，为其设置要执行的target app，再传入app启动所需的参数即可将lldb挂在到Node或Electron程序上。三条命令可以合并成一条，也可以分开执行。<br>​<br>当然也可以用Xcode - Debug - Attach To Process将xcode挂到Electron进程中调试，这种方式笔者没有试过，只是提供一种想法。<br>​<br>lldb具体的调试过程与xcode中调试ios或mac应用别无二致，一些命令和操作就不贴了，没啥意思，详情当然是参考lldb官网了 <a href="https://lldb.llvm.org/" target="_blank" rel="noopener">https://lldb.llvm.org/</a></p><h4 id="c-addon的编译选项优化"><a href="#c-addon的编译选项优化" class="headerlink" title="c++ addon的编译选项优化"></a>c++ addon的编译选项优化</h4><p>windows上编译链接相关的优化选项采用默认的方案即可，基本只需要指定运行时库类型。而在Mac平台上，不指定优化编译选项，会导致编译出来的release版本的addon模块变得非常大。这些优化选项就类似于xcode工程Build Setting里的设置，不过需要显式在.gyp中指定。上面贴出来的binding.gyp中已经包含了部分选项的指定，这里简单说明一些重要的选项：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"GCC_OPTIMIZATION_LEVEL"</span>: <span class="string">"s"</span></span><br></pre></td></tr></table></figure><p>GCC_OPTIMIZATION_LEVEL：对应xcode工程Build Setting -&gt; Optimization Level，.gyp中debug模式下此项设定为”0”，表示优化等级为None；release模式下此项为”s”, 则优化等级为Fastest, Smallest</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"DEPLOYMENT_POSTPROCESSING"</span>: <span class="string">"YES"</span>,</span><br><span class="line"><span class="string">"COPY_PHASE_STRIP"</span>: <span class="string">"YES"</span>，</span><br><span class="line"><span class="string">"DEAD_CODE_STRIPPING"</span>: <span class="string">"YES"</span>,</span><br><span class="line"><span class="string">"STRIP_INSTALLED_PRODUCT"</span>: <span class="string">"YES"</span>,</span><br><span class="line"><span class="string">"STRIP_STYLE"</span>: <span class="string">"non-global"</span></span><br></pre></td></tr></table></figure><p>DEPLOYMENT_POSTPROCESSING：开启所有strip开关，后面对各类不必要符号的strip操作能够执行</p><p>STRIP_STYLE：由于addon均认为是动态库，不能strip其需要重定位的全局符号，这里只能将类型设置为non-global</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"GCC_GENERATE_DEBUGGING_SYMBOLS"</span>: <span class="string">"YES"</span>,</span><br><span class="line"><span class="string">"DEBUG_INFORMATION_FORMAT"</span>: <span class="string">"dwarf-with-dsym"</span></span><br></pre></td></tr></table></figure><p>“DEBUG_INFORMATION_FORMAT”: 将调试符号存储到一个dSYM文件中，便于堆栈符号化</p><p>理论上，xcode工程里Build Setting内所有可配置选项均能够引入到.gyp文件中，需要的时候，可以从xcode工程里的project.pbxproj文件中参考对应的命令项填入。<br>​<br>这是我们首次尝试应用Electron实现桌面客户端并引入、实现c++原生插件，部分方案是笔者尝试后给出的方案，能力有限难免存在缺陷，若有不足之处，恳请指出，谢谢。</p><p>​    </p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://nodejs.org/dist/latest-v8.x/docs/api/addons.html" target="_blank" rel="noopener">https://nodejs.org/dist/latest-v8.x/docs/api/addons.html</a></p><p><a href="https://v8.dev/docs" target="_blank" rel="noopener">https://v8.dev/docs</a></p><p><a href="https://github.com/nodejs/nan" target="_blank" rel="noopener">https://github.com/nodejs/nan</a></p><p><a href="http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection" target="_blank" rel="noopener">http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection</a></p><p><a href="https://github.com/nodejs/node-addon-examples" target="_blank" rel="noopener">https://github.com/nodejs/node-addon-examples</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近期项目中尝试使用Electron来实现跨平台桌面客户端。由于Node.js支持c++实现native addon，将c++接口封装供js调用，我们考虑将已经被多平台使用的SDK作为native扩展库引入Electron工程。&lt;/p&gt;
&lt;p&gt;Node.js有两套API可以供
      
    
    </summary>
    
    
      <category term="node,nan,n-api" scheme="https://iweiyun.github.io/tags/node-nan-n-api/"/>
    
  </entry>
  
  <entry>
    <title>Mac内核扩展开发</title>
    <link href="https://iweiyun.github.io/2018/12/21/mac-kernel-dev/"/>
    <id>https://iweiyun.github.io/2018/12/21/mac-kernel-dev/</id>
    <published>2018-12-21T04:31:55.000Z</published>
    <updated>2018-12-21T04:40:27.995Z</updated>
    
    <content type="html"><![CDATA[<p>因为项目需要，在Mac系统上要实现一个能监控所有的文件读写的应用，并且可以阻塞或者拒绝一些特定的文件操作。</p><p>在Window上可以通过文件系统过滤驱动来做，而且网上资料也挺多。<br>Mac平台上则需要通过内核扩展（KEXT）来做，相关的资料相对就少很多了，而且大部分是英文的，过程也中踩了一些坑。</p><p>就准备把流程在这篇文章里记录一下。</p><h3 id="准备测试机"><a href="#准备测试机" class="headerlink" title="准备测试机"></a>准备测试机</h3><p>不管是Window还是Mac，估计Linux也一样，内核相关的开发是需要两台机器的。一台机器用于开发，一台机器专门用于测试编译出来的kext。</p><p>原因之一是方便，内核中如果出现空指针啊之类的错误的话，是会导致kernel panic，就只能重启系统了。普通的逻辑bug放到内核里也可能导致整个系统都不能正常运作，总之重启是家常便饭。这时两台机器分工能大大提高开发效率的。</p><p>原因之二是内核调试必须要使用两台机器。估计是因为内核断点下来之后，应用层的UI、调试器之类的程序也都暂停了。所以只能用另外的机器进行远程调试。</p><hr><p>实际操作中通常是使用虚拟机，成本低，有快照支持，非常适合用来当测试用机。<br>虚拟化软件推荐直接使用VMware Fusion，最开始我使用的Virtual Box，想着是免费开源的，然而踩了几天坑之后，发现VBox对MacOS支持的并不好。</p><p>首先要创建安装系统用的iso：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hdiutil create -o /tmp/HighSierra -size 8G -layout SPUD -fs HFS+J -type SPARSE</span><br><span class="line">hdiutil attach /tmp/HighSierra.sparseimage -noverify -mountpoint /Volumes/install_build</span><br><span class="line">sudo /Applications/Install\ macOS\ High\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/install_build</span><br><span class="line">hdiutil detach /Volumes/Install\ macOS\ High\ Sierra/</span><br><span class="line">hdiutil convert /tmp/HighSierra.sparseimage -format UDTO -o /tmp/HighSierra.iso</span><br></pre></td></tr></table></figure><p>第三行中的.app可以直接从App Store上下载，不同系统版本路径会稍有变化。<br><img src="/images/mac-kernel/1545314322_42.png" alt="系统安装文件下载"><br>其他的命令是创建磁盘镜像，挂载，卸载，转换为iso格式，具体可以参考hdiutil的man文档。</p><hr><p>然后就是新建虚拟机，把刚刚创建的iso装载到虚拟机光驱里，启动，安装就行了。没有什么需要特别设置的。<br>（VBox在安装过程中的第一次重启，不能引导正确的分区，需要进boot manager手动选择）</p><p><img src="/images/mac-kernel/1545314915_27.png" alt="网卡设置"></p><p>值得一提的是网卡这边可以设成host-only，这样就可以用虚拟机的ip直接访问它。但是虚拟机不能访问外网，不过也没必要访问外网。</p><p><img src="/images/mac-kernel/1545318719_59.png" alt="文件共享"></p><p>通过打开虚拟机Mac自带的文件共享来传输文件，VMware自带的文件拖放不太好用。</p><h3 id="配置调试环境"><a href="#配置调试环境" class="headerlink" title="配置调试环境"></a>配置调试环境</h3><p>首先要给虚拟机安装上内核调试套件Kernel Debug Kit，这里面包含了Debug版的内核和驱动，以及相应的符号文件，可以从苹果的<a href="https://developer.apple.com/download/more/" title="下载地址" target="_blank" rel="noopener">开发者中心</a>下载。</p><p><img src="/images/mac-kernel/1545319704_63.png" alt="KDK下载"></p><p>注意版本号要与虚拟机里装的MacOS完全一致！</p><p>KDK的安装路径是/Library/Developer/KDKs，其中有一个官方的readme文件，KDK的使用方法，Debug方法基本都包含了，是非常有用的资料。</p><hr><p>在虚拟机里完成KDK的安装后，需要设置启动参数，VMware里就跟真机一样设置就好了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nvram boot-args="-v debug=0x146 kdp_match_name=en0 kcsuffix=development"</span><br></pre></td></tr></table></figure><ul><li>-v：输出所有内核日志，启动时也会输出到黑屏幕</li><li>debug：内核调试的关键设置，具体可以参考苹果官方文档<a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/build/build.html" title="Building and Debugging Kernels" target="_blank" rel="noopener">Building and Debugging Kernels</a>里的Debugging flags</li></ul><p><img src="/images/mac-kernel/1545321624_58.png" alt="Debugging flags"></p><ul><li>kcsuffix：指定使用的内核，这里因为只是debug我们开发的kext，而不是内核本身，使用development的内核就可以了，性能会比较好。</li><li>kdp_match_name：指定断点时用哪个网卡进行远程调试</li></ul><p>这里特别提一下kdp_match_name这个选项，网上的教程大部分都没有这个选项。但是我最开始用VBox来远程调试的时候，死活都连不上，卡了很久，最后在前面提到的官方readme里找到了这个选项才解决。因为当时设置了两个网卡，除了host-only，还有一个NAT连外网，系统默认用了NAT的网卡来调试，当然就没办法连上了。<br>（VBox对nvram的支持非常差，直接用nvram命令设置是无效的，要用命令：VBoxManage setextradata 虚拟机名 “VBoxInternal2/EfiBootArgs” “-v debug=0x146 kdp_match_name=en0 kcsuffix=development”）<br>（后面关闭SIP的设置没法保存也是同理，必须每次启动都操作一次）</p><hr><p>接下来要做的是替换development内核，但在此之前要先关闭SIP（System Integrity Protection），因为内核是受SIP保护的，而且后面要加载未签名的KEXT也是需要在SIP关闭的情况下。</p><ol><li>重启，并按住Cmd+R进恢复模式<br>（VBox因为没有没有启动前的BIOS画面？所以也只能通过boot manager进恢复模式）</li><li>在恢复模式的终端里执行csrutil disable</li></ol><p>关闭了SIP后，重启，替换一下开发内核：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /Library/Developer/KDKs/KDK_10.14_18A391.kdk/System/Library/Kernels/kernel.development /System/Library/Kernels/kernel</span><br><span class="line">sudo kextcache -invalidate /</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>后两句是清除内核缓存并且重启。<br>到此调试环境就算是配置完成了。</p><h3 id="KEXT开发调试"><a href="#KEXT开发调试" class="headerlink" title="KEXT开发调试"></a>KEXT开发调试</h3><p>先来测试下远程调试是否OK。<br>因为前面设置了0x04这个debug标记，可以通过按键触发NMI （non-maskable interrupt）来进入调试状态。因为要按的键太多了，设置个映射比较方便。<br><img src="/images/mac-kernel/1545324557_74.png" alt="按键映射"></p><p>按完之后如果虚拟机整个卡住了，那就说明进入调试状态了。</p><p>在开发机上也装上KDK，因为需要符号和内核调试用的lldb脚本。之后运行lldb进行调试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lldb /Library/Developer/KDKs/KDK_10.14_18A391.kdk/System/Library/Kernels/kernel.development</span><br></pre></td></tr></table></figure><p>按提示导入脚本：<br><img src="/images/mac-kernel/1545324957_2.png" alt="导入脚本"><br>也可以按提示设置一下自动导入，下次进来就不用再敲导入命令了。</p><p>用ip连接虚拟机进行调试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kdp-remote 192.168.19.128</span><br></pre></td></tr></table></figure><p><img src="/images/mac-kernel/1545325071_45.png" alt="kdp-remote"><br>剩下的就跟lldb调试普通应用差不多了，例如bt命令打印堆栈等等，这里就不展开了，大家可以单独去学习。<br><img src="/images/mac-kernel/1545325185_40.png" alt="bt"></p><p>kext执行在内核中，调试也是差不多的。当你的kext引发了panic时，会自动断下来，此时用lldb连上去就能看到堆栈了。<br>也可以在lldb中下断点，或使用int3主动断下来。</p><hr><p>最后我们来实现最开始说的文件读写监控的功能。</p><p>Google了一阵之后，发现苹果在10.4引入的Kauth（Kernel Authorization）相关KPI（Kernel Programming Interface），正好符合我们的要求。</p><p>Kauth里的Vnode Scope，会回调所有的文件系统操作给KEXT中注册的回调函数，包括读写、执行、删除等，并且可以由KEXT决定是否拒绝访问。</p><p>具体细节可以参考<a href="https://developer.apple.com/library/archive/technotes/tn2127/_index.html" title="官方文档" target="_blank" rel="noopener">官方文档</a>，同时还提供了一个<a href="https://developer.apple.com/library/archive/samplecode/KauthORama/Introduction/Intro.html#//apple_ref/doc/uid/DTS10003633" title="示例代码" target="_blank" rel="noopener">示例代码</a>，可以说是非常贴心了。虽然这些资料都有些年头了，但是完全没有过时。</p><p>接下来直接看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> kern_return_t <span class="title">com_example_apple_samplecode_kext_KauthORama_start</span><span class="params">(<span class="keyword">kmod_info_t</span> * ki, <span class="keyword">void</span> * d)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> kern_return_t <span class="title">com_example_apple_samplecode_kext_KauthORama_stop</span><span class="params">(<span class="keyword">kmod_info_t</span> * ki, <span class="keyword">void</span> * d)</span></span>;</span><br></pre></td></tr></table></figure><p>这是入口函数，在kext加载或卸载时执行，可以在工程设置中指定：<br><img src="/images/mac-kernel/1545326692_63.png" alt="入口函数"><br>然后是注册回调函数，以及回调的部分实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InstallVnodeListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gListener = kauth_listen_scope(KAUTH_SCOPE_VNODE, VnodeScopeListener, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (gListener == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        RemoveVnodeListener();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">VnodeScopeListener</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">kauth_cred_t</span>    credential,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *          idata,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">kauth_action_t</span>  action,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uintptr_t</span>       arg0,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uintptr_t</span>       arg1,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uintptr_t</span>       arg2,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uintptr_t</span>       arg3    <span class="comment">// type (int *), is errPtr, if denies, indicate the error to return to the client.</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = KAUTH_RESULT_DEFER;</span><br><span class="line"></span><br><span class="line">    atomic_fetch_add(&amp;gActivationCount, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">vnode_t</span> vp = (<span class="keyword">vnode_t</span>)arg1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tag = vnode_tag(vp);</span><br><span class="line">    <span class="keyword">if</span> (tag != VT_HFS &amp;&amp; tag != VT_APFS) &#123;</span><br><span class="line">        atomic_fetch_sub(&amp;gActivationCount, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> * vpPath;</span><br><span class="line">    err = createVnodePath(vp, &amp;vpPath);</span><br></pre></td></tr></table></figure><p>更具体的代码就先略过了，可以参考官方文档和示例。除此之外还有用sysctl控制kext的方法，这个示例代码里就有。以及跟用户层进行类socket通信的<a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/NKEConceptual/control/control.html" title="KEXT Controls" target="_blank" rel="noopener">KEXT Controls</a> KPI。</p><hr><p>代码写好之后，先编译出来，然后要在plist里配置一下依赖库，用kextlibs命令来查询用到了那些库：<br><img src="/images/mac-kernel/1545327326_80.png" alt="kextlibs"><br>填到plist的OSBundleLibraries项里：<br><img src="/images/mac-kernel/1545327390_10.png" alt="plist"><br>重新编译一下就可以加载了，不加这些的话，在加载时就会出现找不到符号的错误。</p><hr><p>在虚拟机上执行以下命令加载kext：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R root:wheel KauthORama.kext; kextload KauthORama.kext</span><br></pre></td></tr></table></figure><p>必须以root用户运行，我是先用了sudo -i进了root shell的，就不用每次都sudo了。chown的原因也是因为kextload的限制，要求kext文件的owner是root。</p><p>之后就可以通过log命令来查看kext里print出来的读写请求了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log show --last=3m --predicate 'sender == "KauthORama"'</span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Filtering the log data using "sender == "KauthORama""</span><br><span class="line">Skipping info and debug messages, pass --info and/or --debug to include.</span><br><span class="line">Timestamp                       Thread     Type        Activity             PID    TTL  </span><br><span class="line">2018-12-21 01:44:41.308911+0800 0x3722     Default     0x0                  0      0    kernel.development: (KauthORama) action=LIST_DIRECTORY|ACCESS, uid=501, vp=/Users/zouquan/Desktop/KauthTest, dvp=&lt;null&gt;, pid=271, pname=Finder</span><br><span class="line">2018-12-21 01:44:41.308917+0800 0x3722     Default     0x0                  0      0    kernel.development: (KauthORama) action=SEARCH|ACCESS, uid=501, vp=/Users/zouquan/Desktop/KauthTest, dvp=&lt;null&gt;, pid=271, pname=Finder</span><br><span class="line">2018-12-21 01:44:41.309565+0800 0x3706     Default     0x0                  0      0    kernel.development: (KauthORama) action=READ_ATTRIBUTES|READ_SECURITY, uid=501, vp=/Users/zouquan/Desktop/KauthTest, dvp=&lt;null&gt;, pid=65, pname=mds</span><br><span class="line">2018-12-21 01:44:41.309676+0800 0x3706     Default     0x0                  0      0    kernel.development: (KauthORama) action=READ_ATTRIBUTES, uid=501, vp=/Users/zouquan/Desktop/KauthTest, dvp=&lt;null&gt;, pid=65, pname=mds</span><br><span class="line">2018-12-21 01:44:41.309697+0800 0x3706     Default     0x0                  0      0    kernel.development: (KauthORama) action=LIST_DIRECTORY, uid=501, vp=/Users/zouquan/Desktop/KauthTest, dvp=&lt;null&gt;, pid=65, pname=mds</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------</span><br><span class="line">Log      - Default:          5, Info:                0, Debug:             0, Error:          0, Fault:          0</span><br><span class="line">Activity - Create:           0, Transition:          0, Actions:           0</span><br></pre></td></tr></table></figure><p>当然也可以用控制台APP来查看，效果是一样的：<br><img src="/images/mac-kernel/1545328422_27.png" alt="控制台"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为项目需要，在Mac系统上要实现一个能监控所有的文件读写的应用，并且可以阻塞或者拒绝一些特定的文件操作。&lt;/p&gt;
&lt;p&gt;在Window上可以通过文件系统过滤驱动来做，而且网上资料也挺多。&lt;br&gt;Mac平台上则需要通过内核扩展（KEXT）来做，相关的资料相对就少很多了，而且
      
    
    </summary>
    
    
      <category term="mac,kernel,内核" scheme="https://iweiyun.github.io/tags/mac-kernel-%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Swift函数式编程探索</title>
    <link href="https://iweiyun.github.io/2018/11/19/swift-functional/"/>
    <id>https://iweiyun.github.io/2018/11/19/swift-functional/</id>
    <published>2018-11-19T12:16:54.000Z</published>
    <updated>2018-11-19T13:36:54.777Z</updated>
    
    <content type="html"><![CDATA[<p>以前在iOS上，除了RAC，比较少有函数式编程方面的实践。swift对函数式做了较多的支持，随着swift的普及，在iOS社区，函数式编程被越来越多的开发者所接受。并且因为函数式编程的一些优点，也越来越多的语言开始支持函数式的开发范式。</p><p>因为最近也在项目中开始实践函数式编程，也能逐渐感受到函数式强大之处。目前也有一点心得，本文就谈下自己对函数式编程的理解。<br>​<br>不过在开始之前，先推荐个小段子：<a href="http://m.youku.com/video/id_XMzUwMzg4NDAyNA==.html?spm=a2h0k.8191407.0.0&amp;source=&amp;sharetype=2&amp;from=groupmessage&amp;isappinstalled=0" target="_blank" rel="noopener">好久不见</a></p><p>​        </p><hr><h3 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h3><p>在讲函数式编程之前，我们先来看看这两大编程范式：</p><ul><li>命令式</li><li>声明式</li></ul><p>来粘贴一个关于它们的定义：</p><blockquote><p>命令式编程通过一系列改变程序状态的指令来完成计算。命令式编程模拟电脑运算，是行动导向的，关键在于定义解法，即“怎么做”，因而算法是显性而目标是隐性的。</p><p>声明式编程只描述程序应该完成的任务。声明式编程模拟人脑思维，是目标驱动的，关键在于描述问题，即“做什么”，因而目标是显性而算法是隐性的。</p></blockquote><p>这两种范式的关键区别就在于，一个主要表达“怎么做”，一个主要表达“做什么”。通过两段代码，可以直观的感受一下它们的区别：<br><img src="/images/swift-functional/1542568661_33.png" alt="命令式"><br><img src="/images/swift-functional/1542568666_91.png" alt="声明式"><br>这两段代码都是做的同一件事，把数组里每个元素都乘2，再打印出来。<br>可以看出来，我们平时使用的主要都是命令式的写法，包括使用的最多的面向对象编程(OOP)，其实还是属于命令式编程的范畴。而这篇文章要讲的函数式编程，则是属于声明式编程。</p><p>​    </p><hr><h3 id="函数式编程的优势"><a href="#函数式编程的优势" class="headerlink" title="函数式编程的优势"></a>函数式编程的优势</h3><ul><li>减轻程序员思考的负担（防秃），降低出错的可能性</li></ul><p>就拿上面举的例子来说，先不说一眼望去，命令式写法的复杂性就明显要高得多，即使是一个如此简单的逻辑，也容易写出错误。<br>当时写这个例子的时候，为了突出它们的区别，我故意没用for in range这种比较常规的写法，而使用了while，自己维护index。然鹅第一次跑起来就死循环了，再检查，发现是红框里的index加1漏了写。<br>函数式写法中，因为没有了状态的维护，杜绝了这种错误的发生。</p><ul><li>代码可读性高</li><li>更简洁、更少的代码</li></ul><p>看回定义，声明式编程描述“做什么”，目标是显性而算法是隐性的。而阅读代码时我们往往只关心代码做了什么，而不关心怎么做，这与声明式编程的思想是不谋而合的，所以函数式编程具有更高的代码可读性。<br>同时为了实现这种思想，算法的实现往往是内建的，或是隐藏的，这也让函数式的实现具有更少的代码，看起来更简洁。</p><ul><li>适用于并发环境</li><li>易于优化</li></ul><p>函数式编程中所使用的函数，大多要求为纯函数，这里可以先理解为数学意义上的函数，在相同的参数输入的情况下，一定会有同样的输出。<br>这一特点决定了纯函数可以并行的调用，而无需任何修改，因为无论并行与否，它都能输出正确的结果。<br><img src="/images/swift-functional/1542597555_48.png" alt="并发"><br>上图parallelMap函数的实现就是将数组分成多段，然后在多个线程中分别调用map，最后再拼回一整个。通过这一点改动，就简单的对这个程序进行了多线程的性能优化。</p><ul><li>细粒度的重用（函数级别）</li><li>易于测试</li></ul><p>纯函数除了之前说的，还要求“没有任何可观察的副作用，不依赖外部环境的状态”。<br>后半还是容易理解的，因为只要依赖了外部环境，就不能保证相同输入得到相同输出了。<br>前半所说的副作用，是指除了返回值外，函数还通过其他方式对调用环境产生了影响，例如修改全局变量，写文件，print到控制台等等。<br>纯函数很容易进行单元测试，只需关心输入输出即可。重用也是同理，不必考虑调用的顺序，不用担心影响后续逻辑，放心的复用。<br><img src="/images/swift-functional/1542614984_40.png" alt="函数重用"></p><ul><li>易于重构</li></ul><p>原因也就是前面说的那些，纯函数之间的依赖关系就是一个树，很容易理清。而对象之间的依赖就复杂得多，做过重构的同学应该都有体会，如果没有把代码看的很熟，是不敢轻易去动的。书里有一句话总结的很到位：<br><img src="/images/swift-functional/1542615515_42.png" alt="FP和OO"></p><p>​    </p><hr><h3 id="函数式编程指南"><a href="#函数式编程指南" class="headerlink" title="函数式编程指南"></a>函数式编程指南</h3><p>概念都了解了，那要怎么应用到实际的项目中呢？只要在编写代码时，往下面这几点靠，自然就能写出函数式风格的代码了：</p><ul><li>只定义纯函数</li><li>不要用可变量</li><li>递归代替迭代</li><li>尽量少的数据结构</li><li>闭包、高阶函数的应用</li><li>尽可能使用内置的数据结构</li><li>尽可能使用内置的函数式工具</li></ul><p>但是并非所有功能都适合用函数式来编写，很多情况下副作用是无法避免的：</p><blockquote><p>函数式语言和逻辑式语言擅长基于数理逻辑的应用，命令式语言擅长基于业务逻辑的、尤其是交互式或事件驱动型的应用。</p></blockquote><p>现阶段遇到这些情况时，还是不要强行应用函数式了，特别是苹果的系统框架还是基于面向对象的。</p><p>​<br>接下来举个🌰：<br>我们项目中有这样一个需求，在一个列表中，有多种元素（文件、文件夹、笔记等）。还有多种操作，每种操作支持的类型、数量不同。现在选中了一些元素，求能对这些元素进行哪些操作。<br>例如，选中一个文件、一个文件夹，这时可以进行移动操作（批量、不支持笔记），但不能进行重命名操作（只支持单个）。<br>这是一个很常见的需求，并且不涉及UI、交互，适合用函数式来改造一下。</p><p>​    </p><p>最终我们需要这样一个东西，输入选择的元素列表，得到支持的操作集合。我们把它定义成Strategy类型，是一类函数，在函数式编程里，函数就是一等公民。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Strategy</span> = (<span class="number">_</span> items: [<span class="type">Any</span>]) -&gt; <span class="type">Set</span>&lt;<span class="type">WYOperationType</span>&gt;</span><br></pre></td></tr></table></figure><p>光有Strategy还不够，我们要直接实现这样一个函数还是太过复杂，而且也不够灵活，需要把它拆解为更小的单元。<br>我采用的方法是，先定义一个默认的操作集合，包含了最常规的操作。然后定义一些Modifier来修改默认的操作集合。不同类型的元素支持哪些操作就定义在不同的Modifier里。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> defaultStrategy: <span class="type">Strategy</span> = &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">[.delete, .share, .safeBoxMoveIn,</span><br><span class="line">     .safeBoxMoveOut, .shareDirWithFriend, .rename,</span><br><span class="line">     .download, .jumpToDir, .openIn,</span><br><span class="line">     .favour, .move, .inbox, .unInbox,</span><br><span class="line">     .fileInfo, .ocr, .groupMove,</span><br><span class="line">     .noteGroup, .genPDF, .genGIF]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Modifier</span> = (<span class="number">_</span> items: [<span class="type">Any</span>], <span class="number">_</span> operations: <span class="type">Set</span>&lt;<span class="type">WYOperationType</span>&gt;) -&gt; <span class="type">Set</span>&lt;<span class="type">WYOperationType</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">modify</span>(<span class="title">_</span> <span class="title">strategy</span>: @<span class="title">escaping</span> <span class="title">Strategy</span>, <span class="title">_</span> <span class="title">modifier</span>: @<span class="title">escaping</span> <span class="title">Modifier</span>) -&gt; <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; items <span class="keyword">in</span></span><br><span class="line">        modifier(items, strategy(items))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的modify函数，其实就是一个带items参数的compose（组合）操作。</p><p>下面我们就来定义一个目录的modifier：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> dirSupported: <span class="type">Operand</span> = &#123; items <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> dirs = items.<span class="built_in">lazy</span>.compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunDir</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> dirs.first.<span class="built_in">map</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> $<span class="number">0</span>.isCollecting() &#123;</span><br><span class="line">            <span class="keyword">return</span> [.share, .shareDirWithFriend, .safeBoxMoveIn, .move, .inbox, .unInbox, .delete, .rename]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [.share, .shareDirWithFriend, .safeBoxMoveIn, .move, .inbox, .delete, .rename]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> dirModifier: <span class="type">Modifier</span> = buildModifier(dirSupported, intersection)</span><br></pre></td></tr></table></figure><p>dirSupported判断items中是否有目录，有的话就返回目录支持的操作，通过buildModifier和intersection，构造了一个“如果含有目录，就将目前的操作集合与目录支持的操作集合取交集”的一个Modifier。<br>考虑到Modifier其实也就只有支持、不支持、添加三种情况，分别对应集合的交、差、并集，就通过“返回操作集合”的Operand函数，和三种SetOperation来build一个Modifier，将Modifier的逻辑也细分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">SetOperation</span> = (<span class="number">_</span> first: <span class="type">Set</span>&lt;<span class="type">WYOperationType</span>&gt;, <span class="number">_</span> second: <span class="type">Set</span>&lt;<span class="type">WYOperationType</span>&gt;) -&gt; <span class="type">Set</span>&lt;<span class="type">WYOperationType</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> union: <span class="type">SetOperation</span> = &#123; $<span class="number">0</span>.union($<span class="number">1</span>) &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> subtracting: <span class="type">SetOperation</span> = &#123; $<span class="number">0</span>.subtracting($<span class="number">1</span>) &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> intersection: <span class="type">SetOperation</span> = &#123; $<span class="number">0</span>.intersection($<span class="number">1</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Operand</span> = (<span class="number">_</span> items: [<span class="type">Any</span>]) -&gt; <span class="type">Set</span>&lt;<span class="type">WYOperationType</span>&gt;?</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">buildModifier</span>(<span class="title">_</span> <span class="title">operand</span>: @<span class="title">escaping</span> <span class="title">Operand</span>, <span class="title">_</span> <span class="title">setOperation</span>: @<span class="title">escaping</span> <span class="title">SetOperation</span>) -&gt; <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; items, operations <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> ret = operand(items) &#123;</span><br><span class="line">            <span class="keyword">return</span> setOperation(operations, ret)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> operations</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面定义了几个用于将Modifier进行组合的函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> emptyModifier: <span class="type">Modifier</span> = &#123; $<span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">concat</span>(<span class="title">_</span> <span class="title">modifierLeft</span>: @<span class="title">escaping</span> <span class="title">Modifier</span>, <span class="title">_</span> <span class="title">modifierRight</span>: @<span class="title">escaping</span> <span class="title">Modifier</span>) -&gt; <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; items, operations <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> modifierRight(items, modifierLeft(items, operations))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">concatModifiers</span>(<span class="title">_</span> <span class="title">modifiers</span>: [<span class="title">Modifier</span>]) -&gt; <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> modifiers.<span class="built_in">reduce</span>(emptyModifier) &#123; concat($<span class="number">0</span>, $<span class="number">1</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了Modifier的compose函数，就可以定义更复杂的文件和笔记的Modifier了。<br>最后还有一个count的Modifier，是专门用来在多选的情况下，去除只支持单元素的操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> fileSupported: <span class="type">Operand</span> = &#123; items <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> files = items.<span class="built_in">lazy</span>.<span class="built_in">filter</span> &#123; !($<span class="number">0</span> <span class="keyword">is</span> <span class="type">WeiyunNote</span>) &#125;.compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> files.first.<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        [.download, .share, .shareDirWithFriend,</span><br><span class="line">         .fileInfo, .safeBoxMoveIn, .move,</span><br><span class="line">         .jumpToDir, .delete, .favour,</span><br><span class="line">         .rename, .openIn, .ocr,</span><br><span class="line">         .groupMove, .genGIF]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> fileUnsupported: <span class="type">Operand</span> = &#123; items <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> files = items.<span class="built_in">lazy</span>.<span class="built_in">filter</span> &#123; !($<span class="number">0</span> <span class="keyword">is</span> <span class="type">WeiyunNote</span>) &#125;.compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> noOcr = files.<span class="built_in">filter</span> &#123; !$<span class="number">0</span>.isShouldShowOCRAction() &#125;.first</span><br><span class="line">    <span class="keyword">let</span> noImgVid = files.<span class="built_in">filter</span> &#123; !$<span class="number">0</span>.isImageFile() &amp;&amp; !$<span class="number">0</span>.isVideoFile() &#125;.first</span><br><span class="line">    <span class="keyword">let</span> noLivePhoto = files.<span class="built_in">filter</span> &#123; !$<span class="number">0</span>.isLivePhoto &#125;.first</span><br><span class="line">    <span class="keyword">let</span> secondFile = files.<span class="built_in">dropFirst</span>().first</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result: [<span class="type">WYOperationType</span>] = (noOcr != <span class="literal">nil</span> ? [.ocr] : []) + (noImgVid != <span class="literal">nil</span> ? [.groupMove, .genGIF] : []) + (noLivePhoto != <span class="literal">nil</span> ? [.genGIF] : []) + (secondFile != <span class="literal">nil</span> ? [.genGIF] : [])</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Set</span>&lt;<span class="type">WYOperationType</span>&gt;(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> fileModifier: <span class="type">Modifier</span> = concatModifiers([buildModifier(fileSupported, intersection), buildModifier(fileUnsupported, subtracting)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> noteSupported: <span class="type">Operand</span> = &#123; items <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> notes = items.<span class="built_in">lazy</span>.compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunNote</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> notes.first.<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> [.share, .delete, .noteGroup, .favour]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> noteUnsupported: <span class="type">Operand</span> = &#123; items <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> notes = items.<span class="built_in">lazy</span>.compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunNote</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> notes.<span class="built_in">dropFirst</span>().first.<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> [.favour]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> noteModifier: <span class="type">Modifier</span> = concatModifiers([buildModifier(noteSupported, intersection), buildModifier(noteUnsupported, subtracting)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> countUnsupported: <span class="type">Operand</span> = &#123; items <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> wyItems = items.<span class="built_in">lazy</span>.compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunItem</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> wyItems.<span class="built_in">dropFirst</span>().first.<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> [.ocr, .fileInfo, .rename, .jumpToDir, .openIn, .inbox, .unInbox]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> countModifier: <span class="type">Modifier</span> = buildModifier(countUnsupported, subtracting)</span><br></pre></td></tr></table></figure><p>最后定义一个applyModifiers来应用一组Modifier：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">applyModifiers</span>(<span class="title">_</span> <span class="title">strategy</span>: @<span class="title">escaping</span> <span class="title">Strategy</span>, <span class="title">_</span> <span class="title">modifiers</span>: [<span class="title">Modifier</span>]) -&gt; <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> modifiers.<span class="built_in">reduce</span>(strategy) &#123; modify($<span class="number">0</span>, $<span class="number">1</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> filesTabStrategy: <span class="type">Strategy</span> = applyModifiers(defaultStrategy, [dirModifier, fileModifier, noteModifier, countModifier])</span><br></pre></td></tr></table></figure><p>filesTabStrategy就可以拿到我们APP的文件列表去用了，选中一些项目后，根据Strategy返回的操作集合来展示操作菜单。<br>如果其他场景有不同的需求，可以编写自己的Modifier，再与现有的一顿组合即可。</p><p>主要思想就是把函数、闭包作为数据来操作，运用于高阶函数。还要熟悉函数式编程的三板斧（map、filter、reduce）和lazy等函数式工具，遵循开头的那几个要点来编写代码，就算是入了函数式的大门了。</p><p>​    </p><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>纯函数的引用透明<br>引用透明网上有很多种解释，函数式里，是指函数运行的结果与函数本身，是可以互相替代的。显然纯函数是具有引用透明性的，所以可以延迟执行而不影响结果，这是lazy能正确执行的理论前提。</p><p>这里给出一个比较有意思的lazy filter的实现：<br><img src="/images/swift-functional/1542626381_77.png" alt="LazyArray"></p></li><li><p>记忆<br>可以简单的对纯函数进行缓存，提高性能。<br>Swift里虽然没有内建的实现，但是自己实现一个也很简单：<br><img src="/images/swift-functional/1542626458_75.png" alt="memorize"><br>生产环境使用时还要考虑内存占用、淘汰等。</p></li><li><p>递归代替迭代<br><img src="/images/swift-functional/1542626659_3.png" alt="递归"><br>这里实现的是“每隔1、2、3、4……个数，取一个数”。<br>不能使用var时，我们需要将迭代换成递归实现。好处就不再赘述了，并且符合函数式的原则。<br>这里需要注意的是要用上尾递归，防止爆栈。<br>然而我在swift上测试时，还是出现了爆栈的情况，网上查了资料说是swift不保证尾递归优化，好吧……</p></li><li><p>let的性能问题<br><img src="/images/swift-functional/1542627283_39.png" alt="插入百万数据"><br><img src="/images/swift-functional/1542627287_75.png" alt="将十个数据插入百万元素的字典"><br>纯函数式语言大概是不会出现这样的情况的，运行时的优化，数据结构的高度优化，结果应该是跟用var差不多的性能才对。至少以我的知识，都能实现一个插入时间复杂度为O(log n)的不可变字典。<br>swift估计是没有做这方面的优化，赋值给var时应该是发生了拷贝。并且let的dict也没有插入一个值，返回一个新let dict的方法。</p></li><li><p>运算符重载<br><img src="/images/swift-functional/1542627988_47.png" alt="运算符重载"></p></li><li><p>ReactiveX</p></li></ul><p>将Async、Lazy、Multi-threading版本的函数式工具，引入了面向对象编程，非常值得使用。</p><p>​    </p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然说swift引入了许多函数式编程的东西，光从“没有尾递归优化”和“不可变数据结构优化”这两点来看，实际上还是不能完全按照纯函数式语言的那一套来编码的。<br>函数式编程，现阶段也还不会在项目中大量运用，但是这种思维，确实可以给我们平时的编码带来不一样的启发。<br>以目前swift的能力来说，一些比较简单的函数式的应用还是可以胜任的。<br>即使在OO的编程中，这些函数式的工具也能够对简化代码、逻辑起到很大的作用。</p><p>​    </p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.zhihu.com/pub/reader/119565028" target="_blank" rel="noopener">《函数式编程思维》</a><br><a href="https://objccn.io/products/functional-swift/" target="_blank" rel="noopener">《Swift函数式编程》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以前在iOS上，除了RAC，比较少有函数式编程方面的实践。swift对函数式做了较多的支持，随着swift的普及，在iOS社区，函数式编程被越来越多的开发者所接受。并且因为函数式编程的一些优点，也越来越多的语言开始支持函数式的开发范式。&lt;/p&gt;
&lt;p&gt;因为最近也在项目中开始
      
    
    </summary>
    
    
      <category term="swift,functional" scheme="https://iweiyun.github.io/tags/swift-functional/"/>
    
  </entry>
  
  <entry>
    <title>深入理解苹果系统（Unicode）字符串的排序方法</title>
    <link href="https://iweiyun.github.io/2018/11/16/Understand-Apple-s-Sorting-Strings/"/>
    <id>https://iweiyun.github.io/2018/11/16/Understand-Apple-s-Sorting-Strings/</id>
    <published>2018-11-16T11:37:37.000Z</published>
    <updated>2018-11-16T12:43:32.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h2><p>我们知道计算机是不能直接处理文本的，而是和数字打交道。因此，为了表示文本，就建立了一个字符到数字的映射表，叫做编码。最著名的字符编码就是ASCII了，它使用7-bit来表示应用字母表以及数字和其他字符。这对于英语来说是够用了，但是对于其他语言，这个7-bit就不能满足条件了，因为字符远远超过了7-bit所能表示的最大个数。因此1987年，来自几个大的科技公司的工程师开始合作开发一种致力于能在全世界的所有书写系统中都能通用的字符编码系统，并与1991年10发布了Unicode的1.0.0标准。2018年6月发布了Unicode的11.0版本。这里就不再对Unicode做过多的介绍，值得注意的是，在iOS开发中，常使用的的NSString是基于Unicode-16来开发的，这是因为当时开发这个的时候Unicode标准还是以16bit固定长度来编码，这就导致使用上的一些坑，建议大家阅读下这篇文章：<a href="https://www.objc.io/issues/9-strings/unicode/" title="NSString and Unicode" target="_blank" rel="noopener">NSString and Unicode</a>。</p><h2 id="UCA和CLDR：最常用到的排序标准"><a href="#UCA和CLDR：最常用到的排序标准" class="headerlink" title="UCA和CLDR：最常用到的排序标准"></a>UCA和CLDR：最常用到的排序标准</h2><p>介绍完Unicode编码之后，我们就可以来介绍UCA（Unicode Collation Algorithm）和CLDR（Common Locale Data Repository）了，因为苹果的NSString的<a href="https://developer.apple.com/documentation/foundation/nsstring?language=objc" title="介绍文档" target="_blank" rel="noopener">介绍文档</a>里有这么一句话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Localized string comparisons are based on the Unicode Collation Algorithm, as tailored for different languages by CLDR (Common Locale Data Repository). Both are projects of the Unicode Consortium. Unicode is a registered trademark of Unicode, Inc.</span><br></pre></td></tr></table></figure></p><p>说白了，苹果系统的NSString字符串排序是基于UCA的，并且在不同语言下，经过CLDR来裁剪的。</p><h3 id="UCA（Unicode-Collation-Algorithm）"><a href="#UCA（Unicode-Collation-Algorithm）" class="headerlink" title="UCA（Unicode Collation Algorithm）"></a>UCA（Unicode Collation Algorithm）</h3><p>UCA的介绍官方文档介绍在这里：<a href="http://unicode.org/reports/tr10/#Introduction" title="UCA介绍" target="_blank" rel="noopener">UCA介绍</a>。其中第一句话就写的很清楚，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collation is the general term for the process and function of determining the sorting order of strings of characters.</span><br></pre></td></tr></table></figure></p><p>对字符串排序的过程就是Collation，UCA就是Unicode表示的字符串进行排序的规则，制定这个规则的原因是不同语种对字符串的排序规则要求是不一样的，比如，德国、法国和瑞士对相同的字符排序的规则是不一样的，甚至在同一个语言下比如中文，多音字这种在不同组合里，排序的先后顺序也是不一样的。<br><img src="/images/sort_1.png" alt="差异化举例"><br>因此可以想象，UCA指定的规则比较复杂。感兴趣的可以读下前面贴的UCA介绍，里面有具体的排序规则介绍。</p><h3 id="CLDR（Common-Locale-Data-Repository）"><a href="#CLDR（Common-Locale-Data-Repository）" class="headerlink" title="CLDR（Common Locale Data Repository）"></a>CLDR（Common Locale Data Repository）</h3><p>CLDR的官方文档在这里：<a href="http://cldr.unicode.org/#TOC-What-is-CLDR-" title="CLDR介绍" target="_blank" rel="noopener">CLDR介绍</a>。CLDR是一堆语言数据仓库，为软件提供各种世界语言版本提供了基础，目前在使用CLDR的公司有：</p><blockquote><ul><li>Apple (macOS, iOS, watchOS, tvOS, and several applications; Apple Mobile Device Support and iTunes for Windows; …)</li><li>Google (Web Search, Chrome, Android, Adwords, Google+, Google Maps, Blogger, Google Analytics, …)</li><li>IBM (DB2, Lotus, Websphere, Tivoli, Rational, AIX, i/OS, z/OS,…)</li><li>Microsoft (Windows, Office, Visual Studio, …)</li></ul></blockquote><p>其他公司：</p><blockquote><ul><li>ABAS Software, Adobe, Amazon (Kindle), Amdocs, Apache, Appian, Argonne National Laboratory, Avaya, Babel (Pocoo library), BAE Systems Geospatial eXploitation Products, BEA, BluePhoenix Solutions, BMC Software, Boost, BroadJump, Business Objects, caris, CERN, Debian Linux, Dell, Eclipse, eBay, EMC Corporation, ESRI, Firebird RDBMS, FreeBSD, Gentoo Linux, GroundWork Open Source, GTK+, Harman/Becker Automotive Systems GmbH, HP, Hyperion, Inktomi, Innodata Isogen, Informatica, Intel, Interlogics, IONA, IXOS, Jikes, jQuery, Library of Congress, Mathworks, Mozilla, Netezza, OpenOffice, Oracle (Solaris, Java), Lawson Software, Leica Geosystems GIS &amp; Mapping LLC, Mandrake Linux, OCLC, Perl, Progress Software, Python, QNX, Rogue Wave, SAP, Shutterstock, SIL, SPSS, Software AG, SuSE, Symantec, Teradata (NCR), ToolAware, Trend Micro, Twitter, Virage, webMethods, Wikimedia Foundation (Wikipedia), Wine, WMS Gaming, XyEnterprise, Yahoo!, Yelp</li></ul></blockquote><p>对于不同区域（local），可以找到不同的数据CLDR，结合UCA对字符串进行排序，就做到了不同语言下的本地化排序。可以去 <a href="http://cldr.unicode.org/" target="_blank" rel="noopener">http://cldr.unicode.org/</a>  下载最新的CLDR库，后面将会用到里面的一些内容。</p><hr><h2 id="字符分类与排序规则"><a href="#字符分类与排序规则" class="headerlink" title="字符分类与排序规则"></a>字符分类与排序规则</h2><h3 id="字符分类与Unicode码点值排序"><a href="#字符分类与Unicode码点值排序" class="headerlink" title="字符分类与Unicode码点值排序"></a>字符分类与Unicode码点值排序</h3><p>Unicode把所有的字符分为两类：</p><ol><li>common charaters<br>包括空格，标点，通用符号，货币符号，数字等。</li><li>script charaters<br>包括拉丁字母，希腊字母，汉字等。<br>这样经过分类，便于把一类字符统一集中在一起。</li></ol><p>通常情况下，我们是通过unicode 的UTF-16码点值逐个进行比较大小的来进行排序的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSArray *rawArray = @[@&quot;爱你&quot;, @&quot;一生一世&quot;,@&quot;㊀&quot;, @&quot;上&quot;,@&quot;㊤&quot;,@&quot;μ&quot;,@&quot;язык&quot;,@&quot;..&quot;,@&quot;123&quot;,@&quot;@&quot;,@&quot;AA&quot;,@&quot;abc&quot;,@&quot;abb&quot;];</span><br><span class="line">//1. 默认排序方式</span><br><span class="line">NSArray *defaultedSortedArray = [rawArray sortedArrayUsingComparator:^NSComparisonResult(id  _Nonnull obj1, id  _Nonnull obj2) &#123;</span><br><span class="line">    return [obj1 compare:obj2 options:NSCaseInsensitiveSearch];</span><br><span class="line">&#125;];</span><br><span class="line">__block NSMutableArray *codeUnits = [NSMutableArray array];</span><br><span class="line">[defaultedSortedArray enumerateObjectsUsingBlock:^(NSString*  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">    [codeUnits addObject:@([obj characterAtIndex:0])];</span><br><span class="line">&#125;];</span><br><span class="line">NSLog(@&quot;默认Unicode码点值排序 %@ 对应的各个字符串的首字符码点值是 %@&quot;, [defaultedSortedArray descriptionWithLocale:cnLocal], codeUnits);</span><br></pre></td></tr></table></figure></p><p>输出结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">排序结果 </span><br><span class="line"> ..  123  @  AA  abb  abc  μ  язык  ㊀  ㊤  一生一世  上  爱你 </span><br><span class="line"> 对应的各个字符串的首字符码点值是 </span><br><span class="line"> 46  49  64  65  97  97  956  1103  12928  12964  19968  19978  29233</span><br></pre></td></tr></table></figure></p><p>我们常用的各种字符的码点值范围是：</p><ul><li>0-9 U+0030 - U0039</li><li>a-z U+0061 - U+007A</li><li>A-Z U+0041 - U+005A<br>具体可通过：<a href="https://unicode-table.com/en/#control-character" title="unicode-table" target="_blank" rel="noopener">unicode-table</a>查询。</li></ul><h3 id="UCA-默认排序"><a href="#UCA-默认排序" class="headerlink" title="UCA 默认排序"></a>UCA 默认排序</h3><p>在我们前面下载的文件CLDR库有个/common/uca/allkeys_CLDR.txt文件，它表示我们指定locale为“en”或者说是默认的排序规则。它的格式是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000  ; [.0000.0000.0000] # &lt;NULL&gt;</span><br><span class="line">0001  ; [.0000.0000.0000] # &lt;START OF HEADING&gt;</span><br><span class="line">0002  ; [.0000.0000.0000] # &lt;START OF TEXT&gt;</span><br><span class="line">0003  ; [.0000.0000.0000] # &lt;END OF TEXT&gt;</span><br></pre></td></tr></table></figure></p><p>分号前的值表示码点，分号后中括号里面的值表示UCA算法权重，用<code>.</code>号来区分，Unicode字符就是按照这个规则从上到下排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSLocale *enLocale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en&quot;];</span><br><span class="line">defaultedSortedArray = [rawArray sortedArrayUsingComparator:^NSComparisonResult(NSString*  _Nonnull obj1, NSString*  _Nonnull obj2) &#123;</span><br><span class="line">    return [obj1 compare:obj2 options:0 range:NSMakeRange(0, obj1.length) locale:enLocale];</span><br><span class="line">&#125;];</span><br><span class="line">NSLog(@&quot;默认排序规则或者指定地区为locale后的排序结果是 %@&quot;, [defaultedSortedArray descriptionWithLocale:cnLocal]);</span><br></pre></td></tr></table></figure></p><p>排序结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认排序规则或者指定地区为en后的排序结果是 </span><br><span class="line"> ..  （ch  (en  @  123  AA  abb  abc  μ  язык  ㊀  一生一世  上  ㊤  爱你</span><br></pre></td></tr></table></figure></p><p>这种排序依次为符号，数字，英文/汉字等script charaters。</p><h3 id="CLDR调整后的排序"><a href="#CLDR调整后的排序" class="headerlink" title="CLDR调整后的排序"></a>CLDR调整后的排序</h3><p>在下载的CLDR文件中，有个common/bcp47/collation.xml文件，列出了可选的排序方式，有standard,pinyin, stroke（笔画排序）等。<br><img src="/images/sort_2.png" alt="排序可选方式"><br>那如何确定各个区域语言下，该使用哪种排序规则呢，我们可以看到common/collation/文件夹下，有很多标记语言LDML文件，这些文件就是表示在不同区域语言下，采用的排序规则。<br><img src="/images/sort_3.png" alt=""></p><p>我们打开zh.xml，这个就是我们简体中文的排序规则，可以看到，里面默认采用的排序是pinyin排序，并且在开头还写了各个声调字母的排序先后顺序。</p><p><img src="/images/sort_4.png" alt=""></p><ol><li>首先按照pinyin声调的先后顺序进行排序，即zh.xml底下列出的先后顺序进行排序。</li><li>如果是在同一行的汉字，则按照笔画由少到多的顺序进行排序。</li><li>如果还不能区分大小，就按照kRSUnicode （偏旁索引的方式，按照康熙字典的定义）的先后顺序进行排序。</li></ol><p>假如我们指定区域为zh_CN，则对于字符串中出现的中文则排在其他语言字符串前面。其他script charater则按照allkeys_CLDR.txt的顺序进行进行排序。值得注意的是，中文由于多音字，在这里不一定能够完全按照我们的习惯排序正确，比如“重逢（chong feng）”就没有第一个拼音chong去排，而是按照zhong来排列的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">默认排序规则或者指定地区为zh_CN后的排序结果是 </span><br><span class="line"> ..  （ch  (en  @  0124  123  艾你  爱你  産  上  ㊤  ㊀  一生一世  重逢  重要  aa  AA  abb  μ  язык </span><br><span class="line"> </span><br><span class="line"> 默认排序规则或者指定地区为ru_CN后的排序结果是 </span><br><span class="line"> ..  （ch  (en  @  0124  123  язык  aa  AA  abb  μ  ㊀  一生一世  上  ㊤  爱你  産  艾你  重要  重逢</span><br></pre></td></tr></table></figure><p>至此，我们大致讲清楚了几种排序规则。</p><hr><h2 id="苹果系统的排序"><a href="#苹果系统的排序" class="headerlink" title="苹果系统的排序"></a>苹果系统的排序</h2><p>前面我们已经说了，苹果系统的NSString排序是UCA和CLDR规则的。NSString提供了很多的排序方法，但最终，所有的都是调用了<code>compare:options:range:locale:</code>来进行处理，只是传入的参数不同。可以在<a href="https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/NSString.swift" title="NSString.swift" target="_blank" rel="noopener">NSString.swift</a> 中查看具体的实现。这么多排序方法中，其中之一是<code>localizedStandardCompare:</code>， 这个方法是苹果系统推荐的，在给用户展示的列表数据的名字或者其他字符串进行排序时所使用的方法。我们看到，它的内部实现是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public func localizedStandardCompare(_ string: String) -&gt; ComparisonResult &#123;</span><br><span class="line">    return compare(string, options: [.caseInsensitive, .numeric, .widthInsensitive, .forcedOrdering], range: NSRange(location: 0, length: length), locale: Locale.current._bridgeToObjectiveC())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中用到的四个Options参数是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSCaseInsensitiveSearch  //大小写不敏感</span><br><span class="line">NSNumericSearch //对字符串中出现的数字字符进行数字化的大小比较，比如Foo2.txt &lt; Foo7.txt &lt; Foo25.txt</span><br><span class="line">NSWidthInsensitiveSearch //忽略宽度，按照实际表示的意思来对比，如&apos;a&apos; = UFF41</span><br><span class="line">NSForcedOrderingSearch //强制返回Ascending或者Descending，和NSCaseInsensitiveSearch结合起来就是例如&quot;aaa&quot; &gt; &quot;AAA&quot;</span><br></pre></td></tr></table></figure></p><p>并且指定了当前的区域locale作为参数，这就相当于指定使用CLDR进行排序，如果是在手机上，这个方法的调用和系统当前的区域设置是有很大关系的，这和我们代码中设置locale是一个道理。我们可以这样理解，调用这个方法得到的结果和在iOS Files中文件名选择按照名称排序得到的结果是一样的。在iOS中，当我们的区域设置为中国时，排序顺序就是 <code>标点符号等特殊符号&gt;数字&gt;中文&gt;英文等其他</code>。<br><img src="/images/sort_5.png" alt="区域设置成中文后的排序"><br>自此，对<code>localizedStandardCompare:</code>的使用，大家应该比较清楚了。</p><h3 id="数字的比较"><a href="#数字的比较" class="headerlink" title="数字的比较"></a>数字的比较</h3><p>这里单独把数字字符串的比较列出来，是因为一些人对这里比较迷惑。由于<code>localizedStandardCompare:</code>中有使用<code>NSNumericSearch</code>选项，这里简单来说，就是假如目前两个字符串是相等的，两者都出现了数字，则分别从两者种取出这段数字进行数字化来比较大小，按照数字大小排序。为了验证这里的逻辑，我看了下<a href="https://opensource.apple.com/source/CF/CF-855.11/CFString.chttp://" title="CFString.c" target="_blank" rel="noopener">CFString.c</a>中<code>CFStringCompareWithOptionsAndLocale</code>这个方法的实现，这个就是<code>compare</code>实际调用的的比价方法。其中关于数字大小比较的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">if (numerically &amp;&amp; ((0 == strBuf1Len) &amp;&amp; (str1Char &lt;= &apos;9&apos;) &amp;&amp; (str1Char &gt;= &apos;0&apos;)) &amp;&amp; ((0 == strBuf2Len) &amp;&amp; (str2Char &lt;= &apos;9&apos;) &amp;&amp; (str2Char &gt;= &apos;0&apos;))) &#123; // If both are not ASCII digits, then don&apos;t do numerical comparison here</span><br><span class="line">    uint64_t intValue1 = 0, intValue2 = 0;// !!! Doesn&apos;t work if numbers are &gt; max uint64_t</span><br><span class="line">    CFIndex str1NumRangeIndex = str1Index;</span><br><span class="line">    CFIndex str2NumRangeIndex = str2Index;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        intValue1 = (intValue1 * 10) + (str1Char - &apos;0&apos;);</span><br><span class="line">        str1Char = CFStringGetCharacterFromInlineBuffer(&amp;inlineBuf1, ++str1Index);</span><br><span class="line">    &#125; while ((str1Char &lt;= &apos;9&apos;) &amp;&amp; (str1Char &gt;= &apos;0&apos;));</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        intValue2 = intValue2 * 10 + (str2Char - &apos;0&apos;);</span><br><span class="line">        str2Char = CFStringGetCharacterFromInlineBuffer(&amp;inlineBuf2, ++str2Index);</span><br><span class="line">    &#125; while ((str2Char &lt;= &apos;9&apos;) &amp;&amp; (str2Char &gt;= &apos;0&apos;));</span><br><span class="line"></span><br><span class="line">    if (intValue1 == intValue2) &#123;</span><br><span class="line">        if (forceOrdering &amp;&amp; (kCFCompareEqualTo == compareResult) &amp;&amp; ((str1Index - str1NumRangeIndex) != (str2Index - str2NumRangeIndex))) &#123;</span><br><span class="line">            compareResult = (((str1Index - str1NumRangeIndex) &lt; (str2Index - str2NumRangeIndex)) ? kCFCompareLessThan : kCFCompareGreaterThan);</span><br><span class="line">            numericEquivalence = true;</span><br><span class="line">            forcedIndex1 = str1NumRangeIndex;</span><br><span class="line">            forcedIndex2 = str2NumRangeIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        continue;</span><br><span class="line">    &#125; else if (intValue1 &lt; intValue2) &#123;</span><br><span class="line">        if (freeLocale &amp;&amp; locale) &#123;</span><br><span class="line">            CFRelease(locale);</span><br><span class="line">        &#125;</span><br><span class="line">            return kCFCompareLessThan;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (freeLocale &amp;&amp; locale) &#123;</span><br><span class="line">                CFRelease(locale);</span><br><span class="line">            &#125;</span><br><span class="line">        return kCFCompareGreaterThan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码的含义就是，如果两个字符串都是以数字开始（也可能是字符串前面都相等，当前从数字部分开始比较），则取出两个字符串的数字，按照数字大小进行对比。如果数字能够比较出大小，则直接返回两个字符串的大小关系，不再对后面的字符串进行对比。比如“0123aaa” 和“1bbbbbbbbb”，就直接返回“0123aaa”大于“1bbbbbbbbb”。当然，这里取出的数字可能超出了uint64_t表示的最大值，但是这种概率很低，在我们的名称排序中，很难遇到这么长的数字进行比较的。明白这个规则后，大家对字符串中出现的数字在进行排序时应该比较理解了。下面的名字排序是对着的。<br><img src="/images/sort_6.png" alt=""></p><hr><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>本文主要讲述由<code>localizedStandardCompare:</code>这个苹果系统方法所引发的对排序规则的深入研究，简单来说，设置中选择区域为中国时，排序顺序为 <code>标点符号等特殊符号&gt;数字&gt;中文&gt;英文等其他</code>。中文本身是按照pinyin排序的，只是由于多音字的关系，不能够做到100%按照中文习惯来排序，会有些无法正确排序的问题，但大体已经符合我们的习惯了。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Unicode</a><br><a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFStrings/Articles/UnicodeBasis.html" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFStrings/Articles/UnicodeBasis.html</a><br><a href="https://www.objc.io/issues/9-strings/unicode/" target="_blank" rel="noopener">https://www.objc.io/issues/9-strings/unicode/</a><br><a href="http://unicode.org/reports/tr10/" target="_blank" rel="noopener">http://unicode.org/reports/tr10/</a><br><a href="https://www.cnblogs.com/huahuahu/p/Unicode-zi-fu-chuan-pai-xu-gui-ze-yi-ru-he-que-din.html" target="_blank" rel="noopener">https://www.cnblogs.com/huahuahu/p/Unicode-zi-fu-chuan-pai-xu-gui-ze-yi-ru-he-que-din.html</a><br><a href="https://raw.githubusercontent.com/larvit/larvitgeodata/master/cldrData/common/uca/allkeys_CLDR.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/larvit/larvitgeodata/master/cldrData/common/uca/allkeys_CLDR.txt</a><br><a href="http://cldr.unicode.org/" target="_blank" rel="noopener">http://cldr.unicode.org/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Unicode编码&quot;&gt;&lt;a href=&quot;#Unicode编码&quot; class=&quot;headerlink&quot; title=&quot;Unicode编码&quot;&gt;&lt;/a&gt;Unicode编码&lt;/h2&gt;&lt;p&gt;我们知道计算机是不能直接处理文本的，而是和数字打交道。因此，为了表示文本，就建立了一
      
    
    </summary>
    
    
      <category term="iOS,排序,Unicode,UCA,CLDR" scheme="https://iweiyun.github.io/tags/iOS-%E6%8E%92%E5%BA%8F-Unicode-UCA-CLDR/"/>
    
  </entry>
  
  <entry>
    <title>有趣的python</title>
    <link href="https://iweiyun.github.io/2018/11/12/python-interesting/"/>
    <id>https://iweiyun.github.io/2018/11/12/python-interesting/</id>
    <published>2018-11-12T14:40:37.000Z</published>
    <updated>2018-11-14T12:27:01.225Z</updated>
    
    <content type="html"><![CDATA[<p>python是一门有趣的语言，有些特性在其它语言基本没有。比如代码格式会影响到代码，成员变量的权限是根据名称来决定，类型是全小写等。</p><p>但又有很多内容与其它语言相似。比如Generator、async/await，和JS里的相应概念很是相似，类的动态性也不少与js差不多。python类的一些高级特性，也有一些能在OC里找到影子。</p><p>python有些写法感觉会比较繁琐，如 &amp;&amp;，明明两个字符就能表示的，但python非要用<code>and</code>这样的单词。</p><p>但python又有些写法表达力很强，如lst[1:3]，即可取出子列表，以及列表生成式的表达能力，与haskell里的List Comprehension差不多了。</p><p>下面就列出python里一些有趣的点</p><p>​    </p><hr><h4 id="极强表达力的列表生成式"><a href="#极强表达力的列表生成式" class="headerlink" title="极强表达力的列表生成式"></a>极强表达力的列表生成式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">print(r)<span class="comment"># 输出：[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span></span><br></pre></td></tr></table></figure><blockquote><p><em>在Haskell中称为<a href="https://wiki.haskell.org/List_comprehension" target="_blank" rel="noopener">List comprehension</a>的，写法与其类似：</em></p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x*x | x &lt;- [<span class="number">1.</span><span class="number">.10</span>]]</span><br></pre></td></tr></table></figure><hr><h4 id="类型是小写的"><a href="#类型是小写的" class="headerlink" title="类型是小写的"></a>类型是小写的</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str即是表示字符串类型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myFunc</span><span class="params">(s: str)</span>:</span></span><br><span class="line">    <span class="comment"># some code</span></span><br></pre></td></tr></table></figure><blockquote><p><em>参数类型是可选的，一般不需要加</em></p></blockquote><hr><h4 id="变量不需要指定类型，而且在运行时可以修改类型"><a href="#变量不需要指定类型，而且在运行时可以修改类型" class="headerlink" title="变量不需要指定类型，而且在运行时可以修改类型"></a>变量不需要指定类型，而且在运行时可以修改类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v = <span class="number">1</span></span><br><span class="line">v = <span class="string">"2"</span></span><br></pre></td></tr></table></figure><hr><h4 id="与、或操作符，是用and、or来表示的"><a href="#与、或操作符，是用and、or来表示的" class="headerlink" title="与、或操作符，是用and、or来表示的"></a>与、或操作符，是用and、or来表示的</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b1 = <span class="keyword">True</span></span><br><span class="line">b2 = <span class="keyword">False</span></span><br><span class="line">o1 = b1 <span class="keyword">and</span> b2<span class="comment"># False</span></span><br><span class="line">o2 = b1 <span class="keyword">or</span> b2<span class="comment"># True</span></span><br></pre></td></tr></table></figure><hr><h4 id="列表可以从后面来访问"><a href="#列表可以从后面来访问" class="headerlink" title="列表可以从后面来访问"></a>列表可以从后面来访问</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(lst[<span class="number">-1</span>])<span class="comment"># 输出3, 也要注意不能越界</span></span><br></pre></td></tr></table></figure><blockquote><p>lst[0:2], 这样来写就可以取出[1, 2]</p></blockquote><hr><h4 id="可以执行字符串"><a href="#可以执行字符串" class="headerlink" title="可以执行字符串"></a>可以执行字符串</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec(<span class="string">"print('Hello World')"</span>)<span class="comment"># 输出：Hello World</span></span><br></pre></td></tr></table></figure><blockquote><p><em>类似js中的 <code>eval</code></em>  </p></blockquote><hr><h4 id="支持lambda表达式"><a href="#支持lambda表达式" class="headerlink" title="支持lambda表达式"></a>支持lambda表达式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> r, v : r + v</span><br></pre></td></tr></table></figure><hr><h4 id="元组定义时可以不用括号"><a href="#元组定义时可以不用括号" class="headerlink" title="元组定义时可以不用括号"></a>元组定义时可以不用括号</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tuple = <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span></span><br><span class="line">print(tuple[<span class="number">1</span>])<span class="comment"># 输出：b</span></span><br></pre></td></tr></table></figure><blockquote><p><em>元组其实就是不可变的列表</em></p></blockquote><hr><h4 id="简单的交换变量的方式"><a href="#简单的交换变量的方式" class="headerlink" title="简单的交换变量的方式"></a>简单的交换变量的方式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x</span><br></pre></td></tr></table></figure><blockquote><p><em>类似swift的写法，本质都是利用元组来交换：</em></p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x, y) = (y, x)</span><br></pre></td></tr></table></figure><hr><h4 id="for-else结构"><a href="#for-else结构" class="headerlink" title="for-else结构"></a>for-else结构</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">19</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"找到了偶数"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"没有找到偶数"</span>)<span class="comment"># 输出：没有找到偶数</span></span><br></pre></td></tr></table></figure><hr><h4 id="类的方法，定义时需要显示指定self"><a href="#类的方法，定义时需要显示指定self" class="headerlink" title="类的方法，定义时需要显示指定self"></a>类的方法，定义时需要显示指定self</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.set_score(<span class="number">85</span>)<span class="comment"># 调用时不需要指定</span></span><br></pre></td></tr></table></figure><blockquote><p> <em>在其它语言里面基本都是编译器自动帮指定，不需要显示的写出来的。</em></p></blockquote><hr><h4 id="成员变量要在-init-里面指定，在方法外定义的是类属性"><a href="#成员变量要在-init-里面指定，在方法外定义的是类属性" class="headerlink" title="成员变量要在__init__里面指定，在方法外定义的是类属性"></a>成员变量要在__init__里面指定，在方法外定义的是类属性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">        Student.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">m = Student(<span class="string">"Matthew"</span>, <span class="number">80</span>)</span><br><span class="line">print(Student.count)<span class="comment"># 1</span></span><br><span class="line">print(m.name)<span class="comment"># Matthew</span></span><br></pre></td></tr></table></figure><hr><h4 id="私有变量通过名字来限定"><a href="#私有变量通过名字来限定" class="headerlink" title="私有变量通过名字来限定"></a>私有变量通过名字来限定</h4><p>通过在名字前加双下划线，来表示是私有变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">"Matthew"</span>, <span class="number">60</span>)</span><br><span class="line">print(s.__name)<span class="comment"># 'Student' object has no attribute '__name'</span></span><br></pre></td></tr></table></figure><hr><h4 id="类可以动态的增、删成员变量"><a href="#类可以动态的增、删成员变量" class="headerlink" title="类可以动态的增、删成员变量"></a>类可以动态的增、删成员变量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">o = Student()</span><br><span class="line">o.name = <span class="string">"Matthew"</span></span><br><span class="line">print(o.name)<span class="comment"># 输出: Matthew</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> o.name</span><br><span class="line">print(o.name)<span class="comment"># 'Student' object has no attribute 'name'</span></span><br></pre></td></tr></table></figure><blockquote><p><em>js也有这个能力</em></p></blockquote><hr><h4 id="调用不存在的属性，可以被开发者接管"><a href="#调用不存在的属性，可以被开发者接管" class="headerlink" title="调用不存在的属性，可以被开发者接管"></a>调用不存在的属性，可以被开发者接管</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">'name'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Good"</span></span><br><span class="line"></span><br><span class="line">o = Student()</span><br><span class="line">print(o.name)<span class="comment"># 输出：Good</span></span><br></pre></td></tr></table></figure><blockquote><p><em>跟OC的转发找不到的方法非常像。包括  <code>__str__</code> 方法，也非常类似OC中的 <code>description</code> ，来实现自定义打印内容</em></p></blockquote><hr><h4 id="可以通过代码来设置断点"><a href="#可以通过代码来设置断点" class="headerlink" title="可以通过代码来设置断点"></a>可以通过代码来设置断点</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdb.set_trace()</span><br></pre></td></tr></table></figure><blockquote><p><em>类似js的 <code>debugger</code> 语句</em></p></blockquote><hr><p>​    </p><p><strong>参考资料</strong></p><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰的官方网站</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python是一门有趣的语言，有些特性在其它语言基本没有。比如代码格式会影响到代码，成员变量的权限是根据名称来决定，类型是全小写等。&lt;/p&gt;
&lt;p&gt;但又有很多内容与其它语言相似。比如Generator、async/await，和JS里的相应概念很是相似，类的动态性也不少与j
      
    
    </summary>
    
    
      <category term="python" scheme="https://iweiyun.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>你可能不知道的Swift</title>
    <link href="https://iweiyun.github.io/2018/11/06/swift-interesting/"/>
    <id>https://iweiyun.github.io/2018/11/06/swift-interesting/</id>
    <published>2018-11-06T14:49:17.000Z</published>
    <updated>2018-11-29T10:36:35.925Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><hr><p>​    </p><h3 id="自定义运算符不仅限于Ascii符号"><a href="#自定义运算符不仅限于Ascii符号" class="headerlink" title="自定义运算符不仅限于Ascii符号"></a>自定义运算符不仅限于Ascii符号</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ❤ : <span class="type">MultiplicationPrecedence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> ❤<span class="params">(lhs: Int, rhs: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> lhs + rhs &#125;</span><br><span class="line">r = <span class="number">1</span> ❤ <span class="number">5</span><span class="comment">// 结果是6</span></span><br></pre></td></tr></table></figure><p>除了❤，类似☢、☂、☯等都可以用，而且这些符号都是可以组合起来的</p><p>​    </p><hr><p>​    </p><h3 id="空集合，是无法判断出有效类型的"><a href="#空集合，是无法判断出有效类型的" class="headerlink" title="空集合，是无法判断出有效类型的"></a>空集合，是无法判断出有效类型的</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="type">Int</span>]()</span><br><span class="line"><span class="keyword">if</span> arr <span class="keyword">is</span> [<span class="type">String</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Match!!"</span>)<span class="comment">// 会输出Match!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="可变参数，在函数内部就是数组"><a href="#可变参数，在函数内部就是数组" class="headerlink" title="可变参数，在函数内部就是数组"></a>可变参数，在函数内部就是数组</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(params: String...)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> t = type(of: params)</span><br><span class="line">    <span class="built_in">print</span>(t)<span class="comment">// 输出：Array&lt;String&gt;</span></span><br><span class="line">    <span class="built_in">print</span>(params)<span class="comment">// 输出：["1", "2"]</span></span><br><span class="line">&#125;</span><br><span class="line">test(params: <span class="string">"1"</span>, <span class="string">"2"</span>)</span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="Optional类型，也是有map方法的"><a href="#Optional类型，也是有map方法的" class="headerlink" title="Optional类型，也是有map方法的"></a>Optional类型，也是有map方法的</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i: <span class="type">Int</span>? = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> r = i.<span class="built_in">map</span> &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(r)<span class="comment">// Optional(11)</span></span><br></pre></td></tr></table></figure><p>有些场景下可以极大简化代码</p><p>​    </p><hr><p>​    </p><h3 id="闭包仅能推断出单表达式的返回值"><a href="#闭包仅能推断出单表达式的返回值" class="headerlink" title="闭包仅能推断出单表达式的返回值"></a>闭包仅能推断出单表达式的返回值</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">map</span> &#123; item <span class="keyword">in</span><span class="comment">// Error: Unable to infer complex closure return type</span></span><br><span class="line">    <span class="keyword">let</span> r = item * item</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有改成如下形式才能编译通过</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">map</span> &#123; item <span class="keyword">in</span></span><br><span class="line">    item * item + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单表达式时，return关键字也可以省略</p><p>​    </p><hr><p>​    </p><h3 id="print是有更多参数可用的"><a href="#print是有更多参数可用的" class="headerlink" title="print是有更多参数可用的"></a>print是有更多参数可用的</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello"</span>, <span class="string">"World"</span>, separator: <span class="string">" "</span>)<span class="comment">// 输出Hello World，中间用空格分割</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两句输出： HelloWorld，不会换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hello"</span> terminator: <span class="string">""</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"World"</span>)</span><br></pre></td></tr></table></figure><p>除此之外还有debugPrint，可能会输出更详细的信息</p><p>​    </p><hr><p>​    </p><h3 id="可以很方便判断值是否在区间内"><a href="#可以很方便判断值是否在区间内" class="headerlink" title="~= 可以很方便判断值是否在区间内"></a>~= 可以很方便判断值是否在区间内</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="number">1</span>...<span class="number">5</span> ~= <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(r)<span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="switch判断，可以更强大"><a href="#switch判断，可以更强大" class="headerlink" title="switch判断，可以更强大"></a>switch判断，可以更强大</h3><p>case后面跟可以不同类型，但需要重载 ~= 运算符</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name : <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> ~=<span class="params">(pattern: String, value: Person)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value.name == pattern</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="type">Person</span>(name: <span class="string">"Alessandro"</span>)</span><br><span class="line"><span class="keyword">switch</span> person &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"Alessandro"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hey it's me!"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Not me"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="空元组，可以在不关心类型及数据时使用"><a href="#空元组，可以在不关心类型及数据时使用" class="headerlink" title="空元组，可以在不关心类型及数据时使用"></a>空元组，可以在不关心类型及数据时使用</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">emptyTuple</span><span class="params">(<span class="number">_</span>: <span class="params">()</span></span></span>) &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line">emptyTuple(())<span class="comment">// 调用时也需要传入空元组</span></span><br></pre></td></tr></table></figure><p>在Rx中，是有大量这样的使用，比如事件通知，不需要传数据，只要触发一下的情况，可能会用()<br>​<br>Swift中，Void也是用的空元组来定义的</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Void</span> = ()</span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="一起遍历两个Sequence时，可以用zip"><a href="#一起遍历两个Sequence时，可以用zip" class="headerlink" title="一起遍历两个Sequence时，可以用zip"></a>一起遍历两个Sequence时，可以用zip</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lst1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> lst2 = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]</span><br><span class="line"><span class="keyword">for</span> (a, b) <span class="keyword">in</span> <span class="built_in">zip</span>(lst1, lst2) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(a)</span><span class="subst">\(b)</span>"</span>)<span class="comment">// 输出1a 2b 3c，以短的列表为准</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="元组是可以定义标签的"><a href="#元组是可以定义标签的" class="headerlink" title="元组是可以定义标签的"></a>元组是可以定义标签的</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tuple: (first: <span class="type">Int</span>, second: <span class="type">String</span>, third: <span class="type">String</span>?) = (<span class="number">0</span>, <span class="string">""</span>, <span class="literal">nil</span>)</span><br><span class="line">tuple.first = <span class="number">1</span></span><br><span class="line">tuple.second = <span class="string">"hello"</span></span><br><span class="line">tuple.third = <span class="string">"world"</span></span><br><span class="line"><span class="built_in">print</span>(tuple.first)<span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="全局变量默认就是lazy的"><a href="#全局变量默认就是lazy的" class="headerlink" title="全局变量默认就是lazy的"></a>全局变量默认就是lazy的</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">globalFunc</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> globalVar = globalFunc()<span class="comment">// 只有globalVar被使用时，globalFunc才会被调用</span></span><br></pre></td></tr></table></figure><p>苹果源码仓库里有相应的测试代码，可以详细看到什么情况下会是懒加载：<a href="https://github.com/apple/swift/blob/master/test/decl/var/lazy_properties.swift" target="_blank" rel="noopener">lazy_properties.swift</a></p><p>​    </p><hr><p>​    </p><h3 id="precondition，比assert更严格的检查"><a href="#precondition，比assert更严格的检查" class="headerlink" title="precondition，比assert更严格的检查"></a>precondition，比assert更严格的检查</h3><p>用法上与assert类似，但更严格，只有-Ounchecked选项才能关闭，但这样会很危险</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">precondition</span>(x &gt;= <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="struct在没有自定义init时，系统会帮我们生成"><a href="#struct在没有自定义init时，系统会帮我们生成" class="headerlink" title="struct在没有自定义init时，系统会帮我们生成"></a>struct在没有自定义init时，系统会帮我们生成</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MySize</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="type">MySize</span>(width: <span class="number">1</span>, height: <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="type">MySize</span>()<span class="comment">// 如果上面没有指定默认值，则不会生成这个初始化方法</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="compactMap可以从列表中筛选出指定类型"><a href="#compactMap可以从列表中筛选出指定类型" class="headerlink" title="compactMap可以从列表中筛选出指定类型"></a>compactMap可以从列表中筛选出指定类型</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrs: [<span class="type">Any</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> r = arrs.compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">String</span> &#125;<span class="comment">// r已经被推断为[String]类型</span></span><br><span class="line"><span class="built_in">print</span>(r)<span class="comment">// 输出：["3", "4"]</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="从Dictionary获取值时，可以提供默认值"><a href="#从Dictionary获取值时，可以提供默认值" class="headerlink" title="从Dictionary获取值时，可以提供默认值"></a>从Dictionary获取值时，可以提供默认值</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dict = [<span class="string">"1"</span>: <span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> o = dict[<span class="string">"2"</span>, <span class="keyword">default</span>: <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(o)<span class="comment">// 输出：2</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="运算符也是方法"><a href="#运算符也是方法" class="headerlink" title="运算符也是方法"></a>运算符也是方法</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = (+)(<span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(r)<span class="comment">// 输出：11</span></span><br></pre></td></tr></table></figure><p>​    </p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;​    &lt;/p&gt;
&lt;h3 id=&quot;自定义运算符不仅限于Ascii符号&quot;&gt;&lt;a href=&quot;#自定义运算符不仅限于Ascii符号&quot; class=&quot;headerlink&quot; title=&quot;自定义运算符不仅限于Ascii符号&quot;&gt;&lt;/a&gt;自定义运
      
    
    </summary>
    
    
      <category term="swift" scheme="https://iweiyun.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>RxCocoa简单源码分析</title>
    <link href="https://iweiyun.github.io/2018/11/01/rxcocoa-code/"/>
    <id>https://iweiyun.github.io/2018/11/01/rxcocoa-code/</id>
    <published>2018-11-01T13:38:28.000Z</published>
    <updated>2018-11-02T02:13:59.414Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>RxCocoa是<a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>的一部分，主要是UI相关的Rx封装。比如实现了很多组件的绑定功能，简化处理逻辑。也可以监听delegate改变，无须把控件创建及delegate处理分开写等。</p><p>RxCocoa里面也定义了很多类，专门为UI处理提供的，比如<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/control_property.html" target="_blank" rel="noopener">ControlProperty</a>、<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable/control_event.html" target="_blank" rel="noopener">ControlEvent</a>、<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable/driver.html" target="_blank" rel="noopener">Driver</a>、<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observer/binder.html" target="_blank" rel="noopener">Binder</a>等。RxCocoa可以用好的话，可以极大简化UI相关处理逻辑。但是，要想随心所欲的使用，还是要对其实现要有一定的了解，否则就容易写出不是那么简洁的代码。</p><p>比如前几天在一篇博客上，看到的一段代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">textfield.rx.text</span><br><span class="line">    .asObservable()</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>这段代码一眼看过去，是没什么问题的，执行起来看起来也是ok的。</p><p>但是，这段代码的问题就是存在冗余。具体为什么冗余，稍后再分析。先从简单的示例了解RxCocoa</p><p>​    </p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>的源码里面有附带示例代码，源码clone下来之后，打开Rx.xcworkspace，即可以选择示例运行看效果。</p><p>现在就拿最简单的Numbers例子看下，(也可以在线看下这个最简单示例代码：<a href="https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Examples/Numbers/NumbersViewController.swift" target="_blank" rel="noopener">Numbers</a>）</p><p>核心代码就这一段：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Observable</span>.combineLatest(number1.rx.text.orEmpty, number2.rx.text.orEmpty, number3.rx.text.orEmpty) &#123; textValue1, textValue2, textValue3 -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">Int</span>(textValue1) ?? <span class="number">0</span>) + (<span class="type">Int</span>(textValue2) ?? <span class="number">0</span>) + (<span class="type">Int</span>(textValue3) ?? <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span>.description &#125;</span><br><span class="line">    .bind(to: result.rx.text)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>这个示例是将三个输入框的内容加起来，绑定在Label上，上面值变化之后，下面的Label立即跟着变化。</p><p>为了让例子更简单，我们可以只把label的值绑定在第一个输入框上：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">number1.rx.text.orEmpty</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span>.description &#125;</span><br><span class="line">    .bind(to: result.rx.text)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>现在我们逐个分析下，这里面的 rx、text、orEmpty、bind到底是什么</p><p>​    </p><h3 id="rx"><a href="#rx" class="headerlink" title="rx"></a>rx</h3><p>number1.rx是表示什么呢？我们根据源码来推导一下</p><p>先看下rx属性的源码实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> rx: <span class="type">Reactive</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Reactive</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        <span class="comment">// this enables using Reactive to "mutate" base object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上是创建了一个Reactive对象，所以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number1.rx  ===&gt;  Reactive(number1)</span><br></pre></td></tr></table></figure><p>Reactive源码又如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Reactive</span>&lt;<span class="title">Base</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/// Base object to extend.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> base: <span class="type">Base</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Creates extensions with base object.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - parameter base: Base object.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> base: <span class="type">Base</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.base = base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以number1.rx最终会变成如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Reactive</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> base: <span class="type">UITextField</span><span class="comment">// 指向number1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以number1.rx是变成了<strong>Reactive结构体</strong>，此时，Reactive的扩展方法，我们就可以使用了。</p><p>所以，这个.rx是进入Rx世界的入口，控件调用.rx属性之后，后面的内容就表示进入了Rx的世界了。</p><p>​    </p><h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><p>上面分析了，number1.rx是一个Reactive的结构体，它后面就可以继续调用Reactive及其扩展的属性和方法了。</p><p>（实际上number1.rx只能调用不限定的扩展的方法或者限定Base是UITextField类型的扩展方法）</p><p>所以，text属性就是Reactive的扩展的属性。这个属性定义在UITextField+Rx.swift文件中，下面是其简化后的实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UITextField</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> text: <span class="type">ControlProperty</span>&lt;<span class="type">String</span>?&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">ControlProperty</span>&lt;<span class="type">String</span>?&gt; &#123;</span><br><span class="line">        <span class="comment">// 默认事件支持了allEditingEvents、valueChanged</span></span><br><span class="line">        <span class="keyword">return</span> base.rx.controlPropertyWithDefaultEvents(</span><br><span class="line">            getter: &#123; textField <span class="keyword">in</span><span class="comment">// 要发出事件时，所需的数据，即是从这儿获取</span></span><br><span class="line">                textField.text</span><br><span class="line">        &#125;,</span><br><span class="line">            setter: &#123; textField, value <span class="keyword">in</span><span class="comment">// 作为监听者时，收到数据时会调到这儿</span></span><br><span class="line">                <span class="keyword">if</span> textField.text != value &#123;</span><br><span class="line">                    textField.text = value</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>text简单的调用了value属性，它们是ControlProperty类型的。</p><p>ControlProperty是表示控件属性，即能监听变化，又能发出通知，即同时实现了ObservableType和ObserverType协议，所以控件才能支持<strong>双向绑定</strong>。</p><p>上面代码中的getter块是在作为ObservableType时所使用的，setter块是作为ObserverType所需要的。</p><p>具体ControlProperty实现就不展开了，可以在UIControl+Rx.swift查看具体实现。</p><p>​    </p><h3 id="orEmpty"><a href="#orEmpty" class="headerlink" title="orEmpty"></a>orEmpty</h3><p>上面代码中的一个细节：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> text: <span class="type">ControlProperty</span>&lt;<span class="type">String</span>?&gt;</span><br></pre></td></tr></table></figure><p>这个value值传出来之后是String?的，是个可选值。在很多情况下，并不想要可选值，只希望如果为nil时，传””空字符串出来即可。否则可选值出来之后，外面可能处理为nil的情况处理起来会比较繁琐。</p><p> orEmpty就是这个作用。</p><p>orEmpty的实现如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> orEmpty: <span class="type">ControlProperty</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> original: <span class="type">ControlProperty</span>&lt;<span class="type">String</span>?&gt; = <span class="keyword">self</span>.asControlProperty()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> values: <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; = original._values.<span class="built_in">map</span> &#123; $<span class="number">0</span> ?? <span class="string">""</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> valueSink: <span class="type">AnyObserver</span>&lt;<span class="type">String</span>&gt; = original._valueSink.mapObserver &#123; $<span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ControlProperty</span>&lt;<span class="type">String</span>&gt;(values: values, valueSink: valueSink)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>会根据目前的values构造一个新的values，并最终构造一个新的ControlProperty，去除可选值的情况。</p><p>​    </p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind即是用来将一个信号发送者和一个信号监听者绑定在一起，即有信号发送，监听者自动收到通知。听起来是跟subscribe做的事情比较类似。</p><p>bind(to:)有几个不同的实现，最简单的实现版本如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">bind</span>&lt;O: ObserverType&gt;<span class="params">(to observer: O)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> == <span class="type">E</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.subscribe(observer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是订阅的封装。可以理解为为subscribe起了一个在绑定场景下比较容易理解的名字。</p><p>在很多情况下，我们的observer并不需要处理error、complete事件，并且处理逻辑需要在主线程中执行。所以RxCocoa帮我们封装好了一个叫Binder的对象，我们使用这个对象时，不需要考虑太多。</p><p>RxCocoa提供的一些监听属性，比如UILabel的rx.text属性即是Binder类型的:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UILabel</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> text: <span class="type">Binder</span>&lt;<span class="type">String</span>?&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Binder</span>(<span class="keyword">self</span>.base) &#123; label, text <span class="keyword">in</span></span><br><span class="line">            label.text = text<span class="comment">// 收到事件就会调用到这儿</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>这样这个简单示例就串起来了，并且能够很明确每次调用在做什么事情。</p><p>现在再看最开始的那段代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">textfield.rx.text</span><br><span class="line">    .asObservable()</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>我们知道textfield.rx.text是ControlProperty的类型，并且这个类型本身就实现了Observable协议的，那么冗余的代码就很明确了，即asObservable()这一次调用是没意义的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;RxCocoa是&lt;a href=&quot;https://github.com/ReactiveX/RxSwift&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="rxswift,rxcocoa,bind,ios,swift" scheme="https://iweiyun.github.io/tags/rxswift-rxcocoa-bind-ios-swift/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s New in LLVM（WWDC2018）</title>
    <link href="https://iweiyun.github.io/2018/10/16/What-New-in%20LLVM-WWDC2018/"/>
    <id>https://iweiyun.github.io/2018/10/16/What-New-in LLVM-WWDC2018/</id>
    <published>2018-10-16T14:30:08.000Z</published>
    <updated>2018-11-16T12:43:06.727Z</updated>
    
    <content type="html"><![CDATA[<p>在WWDC上，LLVM这个Section，基本是年年都有，前年写了篇文章介绍了下，今年继续吧。<br>本来想着今年有官方的中文字幕了，可喜可贺、可喜可贺，然而却是下面这样的情况：<br><img src="/images/1539259407_77.png" alt=""><br><img src="/images/1539259445_13.png" alt=""><br><img src="/images/1539260984_70.png" alt="黑人问号"></p><p>看到这里我还是默默的切回了英文字母，这里就当给大家翻译翻译这篇Section。</p><h3 id="一、C结构体中OC对象的ARC支持"><a href="#一、C结构体中OC对象的ARC支持" class="headerlink" title="一、C结构体中OC对象的ARC支持"></a>一、C结构体中OC对象的ARC支持</h3><p>Xcode10之前大家应该都知道ARC下struct里是不能放OC对象的，Xcode10中解除了这一限制，并且对于在栈上的这种结构体，可以做到完全自动的管理内存：<br><img src="/images/1539263611_74.png" alt="栈上"><br><img src="/images/1539263691_74.png" alt="默认值和数组"><br>对于堆上的结构体则有一些不同，首先要用新加入的calloc代替malloc来申请内存，最后free掉之前要先置nil。<br><img src="/images/1539264271_32.png" alt="堆上"></p><p>这里有几个问题：</p><ul><li>首先是calloc完了之后要强转才能赋值，否则编译会报错（骗子啊，他ppt里是没有强转的）。我理解这个calloc的不同之处就是会把申请的内存都置0。</li><li>第二个是struct定义中的默认值，在这种情况下是失效的，上图中可以看到我把第四个元素也置空了，但是并没有多出一个dealloc，说明他本来就是个nil。</li><li>最后就是free掉之前要把所有struct里的OC字段都显式的置为nil，例子里第二个元素没有置空，所以最后的dealloc少了一个。</li></ul><p>这种情况下感觉是个半成品，跟手动管理内存也没啥区别了，不过大部分情况下，我们也只需要用到栈上的结构体。</p><h3 id="二、更强的代码诊断"><a href="#二、更强的代码诊断" class="headerlink" title="二、更强的代码诊断"></a>二、更强的代码诊断</h3><p>这个部分大概也是年年讲的了，这里就挑两个讲讲：</p><h4 id="OC中的NS-NOESCAPE"><a href="#OC中的NS-NOESCAPE" class="headerlink" title="OC中的NS_NOESCAPE"></a>OC中的NS_NOESCAPE</h4><p>swift里闭包做参数，有escaping和non-escaping的区别。但是接口桥接给OC了之后，在OC中是没有办法知道是不是有escaping的。然后苹果就在OC里也加了一个NS_NOESCAPE的标识符，并且也引入了相关的警告。<br><img src="/images/1539313163_77.png" alt=""><br><img src="/images/1539313204_74.png" alt=""></p><h4 id="Autorelease-Pool外使用Autoreleasing的变量"><a href="#Autorelease-Pool外使用Autoreleasing的变量" class="headerlink" title="Autorelease Pool外使用Autoreleasing的变量"></a>Autorelease Pool外使用Autoreleasing的变量</h4><p>直接来看一个比较隐蔽的错误，下面的代码为什么会Crash呢？<br><img src="/images/1539313946_53.png" alt=""><br>有两个关键因素导致了这个crash，并且大部分人都很难在看代码的时候意识到。</p><ol><li>函数中的输出参数，默认是用__autoreleasing修饰的，即使你不写。</li><li>enumerateXXX这一系列的容器接口，里面的实现是包了一层Autorelease Pool的。</li></ol><p>这就导致了someObj在函数返回之前就已经dealloc了，后面再使用就会导致Use After Free的crash。从控制台的输出也可以看出来，dealloc是在after call之前输出的。<br><img src="/images/1539314934_1.png" alt=""><br>即使是这种比较隐蔽的情况，Xcode10中，静态分析也能指出这种错误了。</p><h3 id="三、安全性提升"><a href="#三、安全性提升" class="headerlink" title="三、安全性提升"></a>三、安全性提升</h3><p> 这个部分在Section中占了比较大的篇幅，不过主要也就讲了两个东西，都是关于防止栈上的写溢出导致的安全性问题，关于栈的基础知识讲解倒是挺多的……</p><h4 id="Stack-Protector"><a href="#Stack-Protector" class="headerlink" title="Stack Protector"></a>Stack Protector</h4><p>先贴一张函数调用栈的结构图，每一个栈桢对应一个函数调用的记录，存储着当前函数要用到的临时变量（栈变量）以及调用完成后要返回到哪里（返回地址）继续执行。<br><img src="/images/1539532681_73.png" alt=""><br>这里还涉及到一种很常见的攻击方法，栈溢出攻击。例如下面这个函数中使用的strcpy函数，它拷贝字符串时并不会判断原串的长度是否超过了目标buffer的长度。攻击者可以恶意的构造一个输入，来覆写当前函数的返回地址，达到控制程序执行流程的目的（跳过一些验证函数等）。<br><img src="/images/1539533246_91.png" alt=""><br>虽然现在使用这些函数会出警告，让你使用它们的安全版本（如strncpy），但是难免会有疏忽的时候。<br>新的编译器加入了Stack Protector这个特性来帮助我们防止这种攻击，原理如下图：<br><img src="/images/1539533945_77.png" alt=""><br><img src="/images/1539533957_92.png" alt=""><br>简单来说就就是在返回地址和栈变量中间加了一小段间隙，这里面会填充一些用于校验的数据，并且自动在函数return之前加入一段检测代码，检测间隙中的数据是否被修改了，如果检测失败，就会强制终止程序。</p><p>这个例子中，如果从栈变量的范围溢出去写返回地址，一定会修改到这块保护区。推测保护区的大小和内容都是会发生变化的，这样攻击者也没法构造一个使保护区不变的输入。</p><p>苹果说这个功能是默认打开的，然而我用他的示例代码并没有出现abort的情况，看反汇编也没有发现有相关的插入的代码在里面。</p><h4 id="Stack-Checking"><a href="#Stack-Checking" class="headerlink" title="Stack Checking"></a>Stack Checking</h4><p>这种保护措施是针对下面这种栈帧的大小也是由输入来控制的函数的。<br><img src="/images/1539535234_63.png" alt=""><br>一种情况是，攻击者传入一个非常大的len，导致这个栈帧的范围与堆的范围有重叠的部分，这样就相当于可以改写任意的堆上的对象了。</p><p>这里有一个前提就是，苹果的系统上，是允许申请一个像这样超大的栈上buffer的，甚至超出物理内存的大小也是可以的。因为系统只会在实际有读写操作时，才会给这段虚拟内存分配一个物理内存上的页，也就是说除了有操作的那一小块虚拟内存，它前后的大段虚拟内存都是不占用物理内存的。<br><img src="/images/1539535965_94.png" alt=""><br>保护的方法也是类似的，在函数入口来检测栈帧的地址范围与堆是否有重叠，是的话也abort掉。<br><img src="/images/1539536569_76.png" alt=""><br>Debug下看反汇编，发现确实有相关的检测代码存在。</p><h3 id="四、新的扩展指令集"><a href="#四、新的扩展指令集" class="headerlink" title="四、新的扩展指令集"></a>四、新的扩展指令集</h3><p>由于没有这些新的设备，就没法实操了，直接上表格吧。<br><img src="/images/1539536873_18.png" alt=""><br>可以看到，移动和桌面平台上，都有SIMD相关的升级。</p><p>桌面端是支持了Intel六代U上增加的AVX512，寄存器宽了一倍，数量也多了一倍，达到32个512bit。</p><p>移动端则是在NEON指令集上增加了半精度浮点的支持，这样在位宽不变的情况下能多放一倍的数据进行并行操作，算是个小更新。据说主要是对机器学习有加成，因为机器学习需要的精度不高。</p><p>最后就是ARM v8.1中增加了原子操作相关的指令，在此之前ARM上的原子操作都是通过Load-link/store-conditional的方式实现的，虽然也是Lock Free的，但是通常需要四条指令。这会加速iOS上APP里用到的原子操作，我自己写项目的时候有时候也会用到，不过总感觉在移动端上，这个东西应该不会造成性能瓶颈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在WWDC上，LLVM这个Section，基本是年年都有，前年写了篇文章介绍了下，今年继续吧。&lt;br&gt;本来想着今年有官方的中文字幕了，可喜可贺、可喜可贺，然而却是下面这样的情况：&lt;br&gt;&lt;img src=&quot;/images/1539259407_77.png&quot; alt=&quot;&quot;&gt;
      
    
    </summary>
    
    
      <category term="llvm,iOS,oc" scheme="https://iweiyun.github.io/tags/llvm-iOS-oc/"/>
    
  </entry>
  
  <entry>
    <title>不一样的JavaScript</title>
    <link href="https://iweiyun.github.io/2018/10/15/js-interesting/"/>
    <id>https://iweiyun.github.io/2018/10/15/js-interesting/</id>
    <published>2018-10-15T14:30:08.000Z</published>
    <updated>2018-11-29T10:48:49.516Z</updated>
    
    <content type="html"><![CDATA[<p>js语法看起来是类c的，如果有c语言基础，可以看懂一些js代码，尤其是类似这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只看这段代码，跟c的写法甚至完全一样。很容易让你有种错觉，简单看下js语法，就能写出优秀的js代码。</p><p>但是，不要被骗了，当你看到后面的代码时，就不会再这样想了。下面就列举一些js语法上感觉有趣或比较特别的例子</p><p>​    </p><hr><h4 id="变量声明可以放在使用之后"><a href="#变量声明可以放在使用之后" class="headerlink" title="变量声明可以放在使用之后"></a>变量声明可以放在使用之后</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">3</span>;<span class="comment">// 此处使用</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a;<span class="comment">// 此处声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="对象可以动态的增加属性，不需要提前声明"><a href="#对象可以动态的增加属性，不需要提前声明" class="headerlink" title="对象可以动态的增加属性，不需要提前声明"></a>对象可以动态的增加属性，不需要提前声明</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o.p1 = <span class="string">"good"</span>;</span><br><span class="line">o.p2 = <span class="number">35</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">// Object &#123;p1: "good", p2: 35&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="对象的属性也可地动态的删除"><a href="#对象的属性也可地动态的删除" class="headerlink" title="对象的属性也可地动态的删除"></a>对象的属性也可地动态的删除</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">p1</span>: <span class="string">"good"</span>, <span class="attr">p2</span>: <span class="number">35</span>&#125;;</span><br><span class="line"><span class="keyword">delete</span> o.p1;</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">// Object &#123;p2: 35&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="函数也是对象，也有方法。如可以调用length，获取参数个数"><a href="#函数也是对象，也有方法。如可以调用length，获取参数个数" class="headerlink" title="函数也是对象，也有方法。如可以调用length，获取参数个数"></a>函数也是对象，也有方法。如可以调用length，获取参数个数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAdd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myAdd.length);<span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure><p>也是支持自定义的方法添加的</p><hr><h4 id="函数定义时，可以不指定参数，但在使用时可以传任意参数"><a href="#函数定义时，可以不指定参数，但在使用时可以传任意参数" class="headerlink" title="函数定义时，可以不指定参数，但在使用时可以传任意参数"></a>函数定义时，可以不指定参数，但在使用时可以传任意参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noParamFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">noParamFunc(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">// 输出1, 2</span></span><br></pre></td></tr></table></figure><hr><h4 id="可以动态决定函数的定义"><a href="#可以动态决定函数的定义" class="headerlink" title="可以动态决定函数的定义"></a>可以动态决定函数的定义</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hey"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sayHi();<span class="comment">// 根据condition的值输出Hi或Hey</span></span><br></pre></td></tr></table></figure><hr><h4 id="函数可以这样定义"><a href="#函数可以这样定义" class="headerlink" title="函数可以这样定义"></a>函数可以这样定义</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myAdd2 = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">2</span>;</span><br><span class="line">myAdd2(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>这种写法在定义简短的函数以及闭包时会非常简洁</p><p>如写出如下简洁实用的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> longestConsec = <span class="function">(<span class="params">a, k</span>) =&gt;</span> (k &lt; <span class="number">1</span> || a.length &lt; <span class="number">1</span> || k &gt; a.length)</span><br><span class="line">? <span class="string">''</span></span><br><span class="line">: a.map(<span class="function">(<span class="params">_, i, a</span>) =&gt;</span> a.slice(i, i + k).join(<span class="string">''</span>))</span><br><span class="line">.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.length &gt;= b.length ? a : b)</span><br></pre></td></tr></table></figure><hr><h4 id="函数定义时将其赋值给其它变量，则函数名在外部不再可用"><a href="#函数定义时将其赋值给其它变量，则函数名在外部不再可用" class="headerlink" title="函数定义时将其赋值给其它变量，则函数名在外部不再可用"></a>函数定义时将其赋值给其它变量，则函数名在外部不再可用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'good'</span>);</span><br><span class="line">&#125;</span><br><span class="line">bar();  <span class="comment">// 出错，这儿只能通过foo()来调用</span></span><br><span class="line">foo();  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>但是，如下的写法又是正确的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'good'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = bar;</span><br><span class="line">bar();  <span class="comment">// ok</span></span><br><span class="line">foo();  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><hr><h4 id="在for循环里定义的变量，作用域是超出for的"><a href="#在for循环里定义的变量，作用域是超出for的" class="headerlink" title="在for循环里定义的变量，作用域是超出for的"></a>在for循环里定义的变量，作用域是超出for的</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 仍然可以访问，且是访问的上面的这个i</span></span><br></pre></td></tr></table></figure><hr><h4 id="一元加号，可以将字符串转为数字"><a href="#一元加号，可以将字符串转为数字" class="headerlink" title="一元加号，可以将字符串转为数字"></a>一元加号，可以将字符串转为数字</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+<span class="string">"10"</span><span class="comment">// 就是数值10</span></span><br></pre></td></tr></table></figure><hr><h4 id="数组的每个元素，其实就是一个属性"><a href="#数组的每个元素，其实就是一个属性" class="headerlink" title="数组的每个元素，其实就是一个属性"></a>数组的每个元素，其实就是一个属性</h4><p>不过这个属性无法直接通过’.’号来访问，而要通过下标形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr<span class="number">.0</span><span class="comment">// 错误</span></span><br><span class="line">arr[<span class="number">0</span>]<span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><hr><h4 id="数组创建的歧义"><a href="#数组创建的歧义" class="headerlink" title="数组创建的歧义"></a>数组创建的歧义</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看起来相同的写法，但行为预期却不一样</span></span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a1);     <span class="comment">// [3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a2);     <span class="comment">// [] 长度为3的空数组</span></span><br></pre></td></tr></table></figure><hr><h4 id="可以用数组定义的形式来获取数组里的元素"><a href="#可以用数组定义的形式来获取数组里的元素" class="headerlink" title="可以用数组定义的形式来获取数组里的元素"></a>可以用数组定义的形式来获取数组里的元素</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> [a, b] = arr</span><br><span class="line"><span class="built_in">console</span>.log(a, b)    <span class="comment">// 输出：1 2</span></span><br></pre></td></tr></table></figure><hr><h4 id="作用域不注意，可能行为也是不可预期"><a href="#作用域不注意，可能行为也是不可预期" class="headerlink" title="作用域不注意，可能行为也是不可预期"></a>作用域不注意，可能行为也是不可预期</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    subLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subLoop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码本来是想执行100次的循环，但实际只会执行10次</p><hr><h4 id="奇怪的相等判断"><a href="#奇怪的相等判断" class="headerlink" title="奇怪的相等判断"></a>奇怪的相等判断</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ==<span class="string">""</span>            <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span>==<span class="string">"0"</span>           <span class="comment">// true</span></span><br><span class="line"><span class="string">""</span> == <span class="string">"0"</span>           <span class="comment">// false</span></span><br></pre></td></tr></table></figure><hr><h4 id="0-可以用来取整"><a href="#0-可以用来取整" class="headerlink" title="|0 可以用来取整"></a>|0 可以用来取整</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.5</span>  | <span class="number">0</span><span class="comment">// 结果是1</span></span><br><span class="line"><span class="number">-2.5</span> | <span class="number">0</span><span class="comment">// 结果是-2</span></span><br></pre></td></tr></table></figure><p>除此之外，还有很多取整的办法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~~<span class="number">1.5</span><span class="comment">// 1</span></span><br><span class="line"><span class="number">1.5</span> ^ <span class="number">0</span><span class="comment">// 1</span></span><br><span class="line"><span class="number">1.5</span> &lt;&lt; <span class="number">0</span><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><hr><h4 id="奇怪但有效的表达式"><a href="#奇怪但有效的表达式" class="headerlink" title="奇怪但有效的表达式"></a>奇怪但有效的表达式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>][<span class="number">1</span>,<span class="number">2</span>];<span class="comment">// 输出3</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++[[]][+[]]+[+[]];</span><br></pre></td></tr></table></figure><p>这个也是有效的表达式，表达式的值是10。 具体原因可以参考<a href="http://justjavac.com/javascript/2012/05/24/can-you-explain-why-10.html" target="_blank" rel="noopener">这篇文章</a></p><hr><h4 id="JS语法本身是需要分号的"><a href="#JS语法本身是需要分号的" class="headerlink" title="JS语法本身是需要分号的"></a>JS语法本身是需要分号的</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">6</span></span><br><span class="line"><span class="comment">// code</span></span><br></pre></td></tr></table></figure><p>虽然写的代码可以不加分号，在解释执行时，解释器会帮我们补上分号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// code</span></span><br></pre></td></tr></table></figure><p>但有时候依赖于解释器加分号的话，行为可能不是预期的</p><hr><p>​    </p><p><strong>参考资料</strong></p><p><a href="https://bonsaiden.github.io/JavaScript-Garden/zh" target="_blank" rel="noopener">JavaScript秘密花园</a></p><p><a href="https://www.cnblogs.com/venoral/p/5280805.html" target="_blank" rel="noopener">JavaScript之Function函数深入总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;js语法看起来是类c的，如果有c语言基础，可以看懂一些js代码，尤其是类似这样的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
    
      <category term="js,javascript" scheme="https://iweiyun.github.io/tags/js-javascript/"/>
    
  </entry>
  
  <entry>
    <title>利用函数组合提升代码可维护性</title>
    <link href="https://iweiyun.github.io/2018/10/03/func-compose/"/>
    <id>https://iweiyun.github.io/2018/10/03/func-compose/</id>
    <published>2018-10-03T14:24:56.000Z</published>
    <updated>2018-10-03T14:52:23.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>函数组合，在函数式编程里面也是挺重要的概念，能够将函数进行操作合并等，在有些场景下可以大幅度提升代码的可读及可维护性。</p><p>下面就演示一些利用函数组合重构代码以达到更好可维护性的例子</p><h3 id="简单场景"><a href="#简单场景" class="headerlink" title="简单场景"></a>简单场景</h3><p>假设有如下代码： </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process1(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process2(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process3(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process4(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure><p>这些函数来处理字符串，如果要组合调用的话，可能会写出来如下的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = ... </span><br><span class="line">str = process1(str) </span><br><span class="line">str = process2(str) </span><br><span class="line">str = process3(str) </span><br><span class="line">str = process4(str) </span><br><span class="line"><span class="comment">// use str</span></span><br></pre></td></tr></table></figure><p>或者更洒脱一些，写出如下的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ret = process4(process3(process2(process1(str))))</span><br></pre></td></tr></table></figure><p>第二种方式可读性不算太好，第一种方式代码写起来又会非常繁琐。那应该如何来优化呢？</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>Swift中是支持<strong>自定义运算符</strong>的，而且swift中<strong>函数是一等公民</strong>。这两个特性是很强大的，利用他们，可以更好的实现函数的组合，可以让代码看起来更简洁、更易读。</p><p>大概的思路是把process1、process2等进行组合，组合成一个新的函数，调用这个新函数的效果，跟分开挨个调用是一样的。</p><p>优化后的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ++ : <span class="type">AdditionPrecedence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> ++ <span class="params">(lhs: @escaping <span class="params">(String)</span></span></span> -&gt; <span class="type">String</span>, rhs: @escaping (<span class="type">String</span>) -&gt; <span class="type">String</span>) -&gt; (<span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; rhs(lhs($<span class="number">0</span>)) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ret = (process1 ++ process2 ++ process3 ++ process4)(str)</span><br></pre></td></tr></table></figure><p>这样写出来的代码，易读且易维护，要增删操作、调整调用顺序等都是很容易的。</p><h3 id="更多场景"><a href="#更多场景" class="headerlink" title="更多场景"></a>更多场景</h3><p>上面这种场景，是比较特殊的场景，函数签名一致并且是同步函数。在真正工作中更普遍的场景是：</p><ol><li>函数签名不一致，如process1(String)，process2(Int, String)</li><li>函数是异步操作，而且回调的闭包类型也不一样等。</li></ol><h4 id="函数签名不一致"><a href="#函数签名不一致" class="headerlink" title="函数签名不一致"></a>函数签名不一致</h4><p>要能组合函数类型不一致的问题，可以参考：<a href="https://iweiyun.github.io/2018/09/04/curry-cleancode/">利用柯里化去除重复代码</a>，利用柯里化 (严格来说叫partial function application) 可以很容易解决。</p><p>代码示例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">process1(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process2(<span class="number">_</span> i: <span class="type">Int</span>, <span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process3(<span class="number">_</span> i: <span class="type">Int</span>, <span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process4(<span class="number">_</span> i: <span class="type">Int</span>, <span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line"></span><br><span class="line">process1 ++ curry(process2) ++ curry(process3) ++ curry(process4)</span><br></pre></td></tr></table></figure><p>不过这儿补充下，有柯里化，就有<strong>反柯里化</strong>。反柯里化就是给函数增加参数，让该函数跟其它函数类型对齐。</p><p>反柯里化的一种简单实现如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uncurry</span><span class="params">(function: @escaping <span class="params">(String)</span></span></span> -&gt; <span class="type">String</span>) -&gt; (<span class="type">String</span>, <span class="type">Int</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; s, <span class="number">_</span> <span class="keyword">in</span> function(s) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用该反柯里化方式，新的组合代码可以适度简化为这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uncuryy(process1) ++ process2 ++ process3 ++ process4</span><br></pre></td></tr></table></figure><p>uncurry完善的实现，可以参考Github上的一些实现，如 <a href="https://github.com/pointfreeco/swift-overture/blob/master/Sources/Overture/Uncurry.swift" target="_blank" rel="noopener">swift-overture</a></p><h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><p>再来看异步操作的问题。</p><p>说到异步处理，如果熟悉一些异步处理框架，如<a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="noopener">PromiseKit</a>或<a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>，那么可能知道PromiseKit里的Promise或RxSwift里的Observable这两个对象。</p><p>仔细想想，Promise和Observable本身就是很有意思的对象，这些对象可以封装异步操作，当然，也可以表示同步操作，表示纯数据等。这些对象本身也提供了很多操作，操作之后，返回的结果仍然是该对象类型。（在函数式编程里面，这两个对象都可以理解为<a href="http://www.ruanyifeng.com/blog/2015/07/monad.html" target="_blank" rel="noopener">Monad</a>对象）</p><p>理解上面这一点是关键，如果Observable本身可以封装异步操作，那么，一个异步操作就可以表达为一个同步函数，只是返回对象是一个代表同步或异步的对象。这样异步的问题就转变为同步处理的问题了。</p><p>下面继续举个简单的例子</p><p>假设有如下4个异步操作：</p><blockquote><p>asyncProcess1<br>asyncProcess2_1<br>asyncProcess2_2<br>asyncProcess3</p></blockquote><p>1、2、3这几个是并发，2_1和2_2是串行</p><p>用RxSwift写的传统代码大概如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">asyncProcess1(param: [<span class="type">String</span>]) -&gt; <span class="type">Observable</span>&lt;<span class="type">Ret</span>&gt; &#123;&#125;</span><br><span class="line">asyncProcess2_1(param1: <span class="type">Int</span>, param2: [<span class="type">String</span>]) -&gt; <span class="type">Observable</span>&lt;<span class="type">Ret</span>&gt; &#123;&#125;</span><br><span class="line">asyncProcess2_2(param: [<span class="type">String</span>]) -&gt; <span class="type">Observable</span>&lt;<span class="type">Ret</span>&gt; &#123;&#125;</span><br><span class="line">asyncProcess3(param: [<span class="type">String</span>]) -&gt; <span class="type">Observable</span>&lt;<span class="type">Ret</span>&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> process2 = <span class="type">Observable</span>.concat(asyncProcess2_1(value, strs), asyncProcess2_2(strs))</span><br><span class="line"><span class="keyword">let</span> process = <span class="type">Observable</span>.merge([asyncProcess1(strs), process2, asyncProcess3(strs)])</span><br><span class="line"><span class="comment">// some code</span></span><br></pre></td></tr></table></figure><p>下面我们就尝试重构下该代码。</p><p>先定义下通用的concat和merge的操作符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并发两个函数，合并成一个函数</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ||| : <span class="type">RxPrecedence</span></span><br><span class="line"><span class="comment">// 串行两个函数，合并成一个函数</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &gt;&gt;&gt; : <span class="type">RxPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">RxOper</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt; = (<span class="type">T</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> ||| &lt;T, U&gt;<span class="params">(lfun: @escaping RxOper&lt;T, U&gt;, rfun: @escaping RxOper&lt;T, U&gt;)</span></span> -&gt; <span class="type">RxOper</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; value <span class="keyword">in</span></span><br><span class="line">        <span class="type">Observable</span>.merge([lfun(value), rfun(value)])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> &gt;&gt;&gt; &lt;T, U&gt;<span class="params">(lfun: @escaping RxOper&lt;T, U&gt;, rfun: @escaping RxOper&lt;T, U&gt;)</span></span> -&gt; <span class="type">RxOper</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; value <span class="keyword">in</span></span><br><span class="line">        lfun(value).concat(rfun(value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写相应的业务代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新的处理代码</span></span><br><span class="line"><span class="keyword">let</span> process = asyncProcess1 ||| (curry(asyncProcess2_1)(value) &gt;&gt;&gt; asyncProcess2_2) ||| asyncProcess3</span><br><span class="line"><span class="comment">// process(strs)...</span></span><br></pre></td></tr></table></figure><p>新代码的优势一目了然。并且这些例子都是拿的非常简单的示例来讲解的，真正的使用场景上，当操作数量逐渐增加，操作逻辑逐渐复杂时，传统的代码写法的冗余就越能显现。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/ijoshsmith/function-composition-in-swift" target="_blank" rel="noopener">Function Composition in Swift</a></p><p><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/" target="_blank" rel="noopener">RxSwift中文文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;函数组合，在函数式编程里面也是挺重要的概念，能够将函数进行操作合并等，在有些场景下可以大幅度提升代码的可读及可维护性。&lt;/p&gt;
&lt;p&gt;下面就
      
    
    </summary>
    
    
      <category term="swift,函数式,函数组合,rxswift,promise" scheme="https://iweiyun.github.io/tags/swift-%E5%87%BD%E6%95%B0%E5%BC%8F-%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88-rxswift-promise/"/>
    
  </entry>
  
  <entry>
    <title>Swift is like Haskell</title>
    <link href="https://iweiyun.github.io/2018/09/27/swift-is-like-haskell/"/>
    <id>https://iweiyun.github.io/2018/09/27/swift-is-like-haskell/</id>
    <published>2018-09-27T13:08:53.000Z</published>
    <updated>2018-11-14T12:47:12.097Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Swift是一门多泛式语言，而且参考了很多其它语言的实现，所以总能在不同语言里看到一些Swift的影子。</p><p>前段时间看到一篇文章，<a href="https://leverich.github.io/swiftislikescala/" target="_blank" rel="noopener">Swift is like Scala</a>，里面做了Swift和Scala一些语法的对比，有些代码块语法上是很像的。最近又看到了<a href="http://nilhcem.com/swift-is-like-kotlin/" target="_blank" rel="noopener">Swift is like Kotlin</a>，<a href="http://repo.tiye.me/jiyinyiyong/swift-is-like-go/" target="_blank" rel="noopener">Swift is like Go</a>。感觉这些挺有趣的，最近刚好有了解一点Haskell，所以就有了这个想法来对比下相似点。</p><p>这儿只是列出两门语言一些类似的点，或语法，或概念上的。但在真正使用的时候，差别还是巨大的。如果想了解真正的工程中，Haskell的使用，可以参考下 <a href="https://github.com/trending/haskell?since=weekly" target="_blank" rel="noopener">Github Haskell Star排名</a>等</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><hr><h5 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello, world!"</span>)</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">putStrLn</span> <span class="string">"hello, world!"</span></span><br></pre></td></tr></table></figure><hr><h5 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- haskell中没有var定义，只能定义不可修改的变量</span></span><br><span class="line"><span class="title">let</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h5 id="显示指定类型"><a href="#显示指定类型" class="headerlink" title="显示指定类型"></a>显示指定类型</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Float</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> a = <span class="number">5</span> :: <span class="type">Float</span></span><br></pre></td></tr></table></figure><hr><h5 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ret = <span class="string">"111"</span> + <span class="string">"222"</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> ret = <span class="string">"111"</span> ++ <span class="string">"222"</span></span><br></pre></td></tr></table></figure><hr><h5 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lst = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> lst = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]</span><br></pre></td></tr></table></figure><hr><h5 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lst = [<span class="number">1</span> ... <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> lst = [<span class="number">1</span> .. <span class="number">5</span>]<span class="comment">-- [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><hr><h5 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAdd</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> a + b &#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myAdd</span> a b = a + b</span><br></pre></td></tr></table></figure><hr><h5 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAdd</span>&lt;T: Numeric&gt;<span class="params">(<span class="number">_</span> a: T, <span class="number">_</span> b: T)</span></span> -&gt; <span class="type">T</span> &#123; <span class="keyword">return</span> a + b &#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myAdd</span> a b = a + b</span><br></pre></td></tr></table></figure><hr><h5 id="返回元组"><a href="#返回元组" class="headerlink" title="返回元组"></a>返回元组</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b, a * b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">process</span> a b = (a + b, a * b)</span><br></pre></td></tr></table></figure><hr><h5 id="操作符另外的调用方式"><a href="#操作符另外的调用方式" class="headerlink" title="操作符另外的调用方式"></a>操作符另外的调用方式</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(+)(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">// 输出3</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(+) <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><hr><h5 id="自定义操作符"><a href="#自定义操作符" class="headerlink" title="自定义操作符"></a>自定义操作符</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;^&gt; : <span class="type">AdditionPrecedence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> &lt;^&gt;<span class="params">(lhs: Int, rhs: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> lhs + rhs &#125;</span><br><span class="line"><span class="number">5</span> &lt;^&gt; <span class="number">6</span><span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&lt;^&gt;) :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">a</span> &lt;^&gt; b = a + b</span><br><span class="line"><span class="number">5</span> &lt;^&gt; <span class="number">6</span><span class="comment">-- 11</span></span><br></pre></td></tr></table></figure><hr><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">2</span>&#125;<span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> (*<span class="number">2</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]<span class="comment">-- [2, 4, 6]</span></span><br></pre></td></tr></table></figure><hr><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">CGPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> x: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> y: <span class="type">CGFloat</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="type">Double</span> <span class="type">Double</span></span></span><br><span class="line">              <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br></pre></td></tr></table></figure><hr><h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> circle(<span class="type">CGPoint</span>, <span class="type">CGFloat</span>)</span><br><span class="line">    <span class="keyword">case</span> rectangle(<span class="type">CGPoint</span>, <span class="type">CGFloat</span>, <span class="type">CGFloat</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Point</span> <span class="type">Double</span></span></span><br><span class="line">           | <span class="type">Rectangle</span> <span class="type">Point</span> <span class="type">Double</span> <span class="type">Double</span></span><br><span class="line">             <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br></pre></td></tr></table></figure><hr><h5 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e = <span class="type">Shape</span>.circle(<span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>), <span class="number">100</span>)</span><br><span class="line"><span class="keyword">switch</span> e &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .circle(pt, <span class="number">_</span>):</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .rectangle(pt, <span class="number">_</span>, <span class="number">_</span>):</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">shapeInfo</span> :: <span class="type">Shape</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">shapeInfo</span> (<span class="type">Circle</span> pt _) = <span class="string">"Circle point"</span> ++ show pt</span><br><span class="line"><span class="title">shapeInfo</span> (<span class="type">Rectangle</span> pt _ _) = <span class="string">"Rectangle point"</span> ++ show pt</span><br></pre></td></tr></table></figure><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://cnhaskell.com/index.html" target="_blank" rel="noopener">Real World Haskell 中文版</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;Swift是一门多泛式语言，而且参考了很多其它语言的实现，所以总能在不同语言里看到一些Swift的影子。&lt;/p&gt;
&lt;p&gt;前段时间看到一篇文章
      
    
    </summary>
    
    
      <category term="haskell,swift,函数式" scheme="https://iweiyun.github.io/tags/haskell-swift-%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>利用柯里化去除重复代码</title>
    <link href="https://iweiyun.github.io/2018/09/04/curry-cleancode/"/>
    <id>https://iweiyun.github.io/2018/09/04/curry-cleancode/</id>
    <published>2018-09-04T11:58:01.000Z</published>
    <updated>2018-11-02T10:48:53.937Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Swift中，函数是一等公民</strong></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>最近因为某个类中有重复代码，在“固化思维”重构之后，虽然原来的重复代码去掉了，但又有如下样式的代码，仔细想想，其实还是有重复，如files和dirs的获取，以及对结果的处理，代码是完全一样的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">WeiyunItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">restore</span><span class="params">(dir: WeiyunDir?)</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> files = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> dirs = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunDir</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">WeiyunSDK</span>.sharedInstance()?.restoreRecycleFile(files, dir: dirs, pdirkey: dir?.dirkey, ppdirkey: dir?.pdirkey, block: &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> = err &#123;</span><br><span class="line">                    observer(.error(error))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    observer(.completed)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">()</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> files = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> dirs = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunDir</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">WeiyunSDK</span>.sharedInstance()?.clearRecycleFile(files, dir: dirs, block: &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> = err, !ignoreError(error) &#123;</span><br><span class="line">                    observer(.error(error))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    observer(.completed)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>按传统的思路来写的话，就是将相同的代码抽取到函数里，然后再调用相应函数来避免重复代码。 重构后大概的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">WeiyunItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">splitItems</span><span class="params">()</span></span> -&gt; ([<span class="type">WeiyunFile</span>], [<span class="type">WeiyunDir</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> files = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> dirs = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunDir</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> (files, dirs)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">processResult</span><span class="params">(observer: PrimitiveSequenceType.CompletableObserver, err: Error?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> = err &#123;</span><br><span class="line">            observer(.error(error))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            observer(.completed)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">restore</span><span class="params">(dir: WeiyunDir?)</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> tuple = splitItems()</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">WeiyunSDK</span>.sharedInstance()?.restoreRecycleFile(tuple.<span class="number">0</span>, dir: tuple.<span class="number">1</span>, pdirkey: dir?.dirkey, ppdirkey: dir?.pdirkey, block: &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.processResult(observer: observer, err: err)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">()</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> tuple = splitItems()</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">WeiyunSDK</span>.sharedInstance()?.clearRecycleFile(tuple.<span class="number">0</span>, dir: tuple.<span class="number">1</span>, block: &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.processResult(observer: observer, err: err)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来还ok，除了Completable.create及Disposables.create()之外，基本没有重复代码了。</p><h4 id="继续思考"><a href="#继续思考" class="headerlink" title="继续思考"></a>继续思考</h4><p>不过，这是终点了吗？并不是，毕竟还有部分代码是重复的。</p><p>我们现在换一种思路来思考，第一张截图里面，除了调用的WeiyunSDK的接口不同，传入的参数不同，其它所有代码都是一样的，那么是否可以在这儿做文章？</p><p>再回到开头看下这句话：Swift中函数是一等公民。这句话的意义是说函数也可以被操作、变换、处理等，你想到的基本都能做。</p><p>那么，把函数作为值传入处理函数中，在处理函数中调用处理就ok。通过传入不同的函数，即可实现调用不同的请求。</p><p>但有个很大的问题，函数类型不一样，restoreRecycleFile多了第2、3两个参数！</p><p>如何把restoreRecycleFile和clearRecycleFile变为具有相同参数的函数，就是要解决的问题。</p><p>今天的主角：<strong>柯里化</strong>，就是来解决这个问题的。</p><h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><p>柯里化是一个通用的概念，在函数式编程里面非常重要。它在维基上的定义是：</p><blockquote><p>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p></blockquote><p>就作用来说，柯里化可以改变函数类型，可以提前绑定其中的参数。</p><p>Github上也有一些现成的柯里化开源库，可以直接用的。如<a href="https://github.com/thoughtbot/Curry" target="_blank" rel="noopener">Curry</a>、<a href="https://github.com/robrix/Prelude" target="_blank" rel="noopener">Prelude</a>等</p><p>可以看如何将两个参数变一个参数的简单实现，以及如何使用柯里化：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">curry</span>&lt;A, B, C&gt;<span class="params">(<span class="number">_</span> function: @escaping <span class="params">(<span class="params">(A, B)</span></span></span></span>) -&gt; <span class="type">C</span>) -&gt; (<span class="type">A</span>) -&gt; (<span class="type">B</span>) -&gt; <span class="type">C</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; (a: <span class="type">A</span>) -&gt; (<span class="type">B</span>) -&gt; <span class="type">C</span> <span class="keyword">in</span> &#123; (b: <span class="type">B</span>) -&gt; <span class="type">C</span> <span class="keyword">in</span> function((a, b)) &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAdd</span><span class="params">(a: Int, b: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = curry(myAdd)(<span class="number">5</span>)<span class="comment">// 这样就可以变为只接受一个参数的函数，</span></span><br><span class="line">f(<span class="number">10</span>)<span class="comment">// 可以这样来调用，并且结果是15</span></span><br></pre></td></tr></table></figure><h4 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h4><p>在我们这个需求场景中，是需要提前绑定第2和3个参数，并且返回只接受三个参数的函数，这些开源库没有提供相应实现，不自己实现一个并不复杂：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以绑定2、3参数的curry化函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">curry2_3</span>&lt;A, B, C, D, E, F&gt;<span class="params">(<span class="number">_</span> function: @escaping <span class="params">(A, B, C, D, E)</span></span></span> -&gt; <span class="type">F</span>) -&gt; (<span class="type">C</span>, <span class="type">D</span>) -&gt; (<span class="type">A</span>, <span class="type">B</span>, <span class="type">E</span>) -&gt; <span class="type">F</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="built_in">c</span>, d <span class="keyword">in</span> &#123; a, b, e <span class="keyword">in</span> function(a, b, <span class="built_in">c</span>, d, e) &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把这个函数用上之后，就可以将代码整理成如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">WeiyunItem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">restore</span><span class="params">(dir: WeiyunDir?)</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> f = curry2_3(<span class="type">WeiyunSDK</span>.sharedInstance().restoreRecycleFile)(dir?.dirkey, dir?.pdirkey)</span><br><span class="line">        <span class="keyword">return</span> operate(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">()</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> f = <span class="type">WeiyunSDK</span>.sharedInstance().clearRecycleFile</span><br><span class="line">        <span class="keyword">return</span> operate(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">operate</span><span class="params">(<span class="number">_</span> function: @escaping <span class="params">([WeiyunFile]?, [WeiyunDir]?, RestoreRecycleItemBlock?)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> files = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> dirs = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunDir</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            function(files, dirs, &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> = err &#123;</span><br><span class="line">                    observer(.error(error))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    observer(.completed)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就没有任何重复代码了</p><p>这儿只是演示了柯里化非常简单的一种使用场景，在函数式编程中，对函数的处理变换无处不在，柯里化也会大放异彩！</p><blockquote><p>严格来说，curry2_3 这种处理方式，是叫函数部分施用，有些语言里会明确区分这些概念，有些语言里(例如Groovy)没有区分。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Swift中，函数是一等公民&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h4&gt;&lt;p&gt;最近因为某个类中有重复代码，在“固化思维”重构之后，虽然原来的
      
    
    </summary>
    
    
  </entry>
  
</feed>
