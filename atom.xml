<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>微云iOS团队</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.weiyun.com/"/>
  <updated>2018-10-27T10:52:41.973Z</updated>
  <id>http://www.weiyun.com/</id>
  
  <author>
    <name>Weiyun Developer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>不一样的JavaScript</title>
    <link href="http://www.weiyun.com/2018/10/15/js-interesting/"/>
    <id>http://www.weiyun.com/2018/10/15/js-interesting/</id>
    <published>2018-10-15T14:30:08.000Z</published>
    <updated>2018-10-27T10:52:41.973Z</updated>
    
    <content type="html"><![CDATA[<p>js语法看起来是类c的，如果有c语言基础，可以看懂一些js代码，尤其是类似这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只看这段代码，跟c的写法甚至完全一样。很容易让你有种错觉，简单看下js语法，就能写出优秀的js代码。</p><p>但是，不要被骗了，当你看到后面的代码时，就不会再这样想了。下面就列举一些js语法上感觉有趣或比较特别的例子</p><p>​    </p><hr><p>​    </p><h5 id="变量声明可以放在使用之后"><a href="#变量声明可以放在使用之后" class="headerlink" title="变量声明可以放在使用之后"></a>变量声明可以放在使用之后</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">3</span>;<span class="comment">// 此处使用</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a;<span class="comment">// 此处声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h5 id="对象可以动态的增加属性，不需要提前声明"><a href="#对象可以动态的增加属性，不需要提前声明" class="headerlink" title="对象可以动态的增加属性，不需要提前声明"></a>对象可以动态的增加属性，不需要提前声明</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o.p1 = <span class="string">"good"</span>;</span><br><span class="line">o.p2 = <span class="number">35</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">// Object &#123;p1: "good", p2: 35&#125;</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h5 id="对象的属性也可地动态的删除"><a href="#对象的属性也可地动态的删除" class="headerlink" title="对象的属性也可地动态的删除"></a>对象的属性也可地动态的删除</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">p1</span>: <span class="string">"good"</span>, <span class="attr">p2</span>: <span class="number">35</span>&#125;;</span><br><span class="line"><span class="keyword">delete</span> o.p1;</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">// Object &#123;p2: 35&#125;</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h5 id="函数也是对象，也有方法。如可以调用length，获取参数个数"><a href="#函数也是对象，也有方法。如可以调用length，获取参数个数" class="headerlink" title="函数也是对象，也有方法。如可以调用length，获取参数个数"></a>函数也是对象，也有方法。如可以调用length，获取参数个数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAdd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myAdd.length);<span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure><p>也是支持自定义的方法添加的</p><p>​    </p><hr><p>​    </p><h5 id="函数定义时，可以不指定参数，但在使用时可以传任意参数"><a href="#函数定义时，可以不指定参数，但在使用时可以传任意参数" class="headerlink" title="函数定义时，可以不指定参数，但在使用时可以传任意参数"></a>函数定义时，可以不指定参数，但在使用时可以传任意参数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noParamFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">noParamFunc(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">// 输出1, 2</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h5 id="可以动态决定函数的定义"><a href="#可以动态决定函数的定义" class="headerlink" title="可以动态决定函数的定义"></a>可以动态决定函数的定义</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hey"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sayHi();<span class="comment">// 根据condition的值输出Hi或Hey</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h5 id="函数可以这样定义"><a href="#函数可以这样定义" class="headerlink" title="函数可以这样定义"></a>函数可以这样定义</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myAdd2 = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">2</span>;</span><br><span class="line">myAdd2(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>这种写法在定义简短的函数以及闭包时会非常简洁</p><p>如写出如下简洁实用的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> longestConsec = <span class="function">(<span class="params">a, k</span>) =&gt;</span> (k &lt; <span class="number">1</span> || a.length &lt; <span class="number">1</span> || k &gt; a.length)</span><br><span class="line">? <span class="string">''</span></span><br><span class="line">: a.map(<span class="function">(<span class="params">_, i, a</span>) =&gt;</span> a.slice(i, i + k).join(<span class="string">''</span>))</span><br><span class="line">.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.length &gt;= b.length ? a : b)</span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h5 id="函数定义时将其赋值给其它变量，则函数名在外部不再可用"><a href="#函数定义时将其赋值给其它变量，则函数名在外部不再可用" class="headerlink" title="函数定义时将其赋值给其它变量，则函数名在外部不再可用"></a>函数定义时将其赋值给其它变量，则函数名在外部不再可用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'good'</span>);</span><br><span class="line">&#125;</span><br><span class="line">bar();  <span class="comment">// 出错，这儿只能通过foo()来调用</span></span><br><span class="line">foo();  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>但是，如下的写法又是正确的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'good'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = bar;</span><br><span class="line">bar();  <span class="comment">// ok</span></span><br><span class="line">foo();  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h5 id="在for循环里定义的变量，作用域是超出for的"><a href="#在for循环里定义的变量，作用域是超出for的" class="headerlink" title="在for循环里定义的变量，作用域是超出for的"></a>在for循环里定义的变量，作用域是超出for的</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 仍然可以访问，且是访问的上面的这个i</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h5 id="一元加号，可以将字符串转为数字"><a href="#一元加号，可以将字符串转为数字" class="headerlink" title="一元加号，可以将字符串转为数字"></a>一元加号，可以将字符串转为数字</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+<span class="string">"10"</span><span class="comment">// 就是数值10</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h5 id="数组创建的歧义"><a href="#数组创建的歧义" class="headerlink" title="数组创建的歧义"></a>数组创建的歧义</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看起来相同的写法，但行为预期却不一样</span></span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a1);     <span class="comment">// [3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a2);     <span class="comment">// [] 长度为3的空数组</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h5 id="作用域不注意，可能行为也是不可预期"><a href="#作用域不注意，可能行为也是不可预期" class="headerlink" title="作用域不注意，可能行为也是不可预期"></a>作用域不注意，可能行为也是不可预期</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    subLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subLoop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码本来是想执行100次的循环，但实际只会执行10次</p><p>​    </p><hr><p>​    </p><h5 id="奇怪的相等判断"><a href="#奇怪的相等判断" class="headerlink" title="奇怪的相等判断"></a>奇怪的相等判断</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ==<span class="string">""</span>            <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span>==<span class="string">"0"</span>           <span class="comment">// true</span></span><br><span class="line"><span class="string">""</span> == <span class="string">"0"</span>           <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h5 id="奇怪但有效的表达式"><a href="#奇怪但有效的表达式" class="headerlink" title="奇怪但有效的表达式"></a>奇怪但有效的表达式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>][<span class="number">1</span>,<span class="number">2</span>];<span class="comment">// 输出3</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++[[]][+[]]+[+[]];</span><br></pre></td></tr></table></figure><p>这个也是有效的表达式，表达式的值是10。 具体原因可以参考<a href="http://justjavac.com/javascript/2012/05/24/can-you-explain-why-10.html" target="_blank" rel="noopener">这篇文章</a></p><p>​    </p><hr><p>​    </p><h5 id="JS语法本身是需要分号的"><a href="#JS语法本身是需要分号的" class="headerlink" title="JS语法本身是需要分号的"></a>JS语法本身是需要分号的</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">6</span></span><br><span class="line"><span class="comment">// code</span></span><br></pre></td></tr></table></figure><p>虽然写的代码可以不加分号，在解释执行时，解释器会帮我们补上分号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// code</span></span><br></pre></td></tr></table></figure><p>但有时候依赖于解释器加分号的话，行为可能不是预期的</p><p>​    </p><hr><p>​    </p><p><strong>参考资料</strong></p><p><a href="https://bonsaiden.github.io/JavaScript-Garden/zh" target="_blank" rel="noopener">JavaScript秘密花园</a></p><p><a href="https://www.cnblogs.com/venoral/p/5280805.html" target="_blank" rel="noopener">JavaScript之Function函数深入总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;js语法看起来是类c的，如果有c语言基础，可以看懂一些js代码，尤其是类似这样的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
    
      <category term="js,javascript" scheme="http://www.weiyun.com/tags/js-javascript/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s New in LLVM（WWDC2018）</title>
    <link href="http://www.weiyun.com/2018/10/15/What-New-in%20LLVM-WWDC2018/"/>
    <id>http://www.weiyun.com/2018/10/15/What-New-in LLVM-WWDC2018/</id>
    <published>2018-10-15T03:44:39.247Z</published>
    <updated>2018-10-15T04:13:27.884Z</updated>
    
    <content type="html"><![CDATA[<p>在WWDC上，LLVM这个Section，基本是年年都有，前年写了篇文章介绍了下，今年继续吧。<br>本来想着今年有官方的中文字幕了，可喜可贺、可喜可贺，然而却是下面这样的情况：<br><img src="/images/1539259407_77.png" alt=""><br><img src="/images/1539259445_13.png" alt=""><br><img src="/images/1539260984_70.png" alt="黑人问号"></p><p>看到这里我还是默默的切回了英文字母，这里就当给大家翻译翻译这篇Section。</p><h3 id="一、C结构体中OC对象的ARC支持"><a href="#一、C结构体中OC对象的ARC支持" class="headerlink" title="一、C结构体中OC对象的ARC支持"></a>一、C结构体中OC对象的ARC支持</h3><p>Xcode10之前大家应该都知道ARC下struct里是不能放OC对象的，Xcode10中解除了这一限制，并且对于在栈上的这种结构体，可以做到完全自动的管理内存：<br><img src="/images/1539263611_74.png" alt="栈上"><br><img src="/images/1539263691_74.png" alt="默认值和数组"><br>对于堆上的结构体则有一些不同，首先要用新加入的calloc代替malloc来申请内存，最后free掉之前要先置nil。<br><img src="/images/1539264271_32.png" alt="堆上"></p><p>这里有几个问题：</p><ul><li>首先是calloc完了之后要强转才能赋值，否则编译会报错（骗子啊，他ppt里是没有强转的）。我理解这个calloc的不同之处就是会把申请的内存都置0。</li><li>第二个是struct定义中的默认值，在这种情况下是失效的，上图中可以看到我把第四个元素也置空了，但是并没有多出一个dealloc，说明他本来就是个nil。</li><li>最后就是free掉之前要把所有struct里的OC字段都显式的置为nil，例子里第二个元素没有置空，所以最后的dealloc少了一个。</li></ul><p>这种情况下感觉是个半成品，跟手动管理内存也没啥区别了，不过大部分情况下，我们也只需要用到栈上的结构体。</p><h3 id="二、更强的代码诊断"><a href="#二、更强的代码诊断" class="headerlink" title="二、更强的代码诊断"></a>二、更强的代码诊断</h3><p>这个部分大概也是年年讲的了，这里就挑两个讲讲：</p><h4 id="OC中的NS-NOESCAPE"><a href="#OC中的NS-NOESCAPE" class="headerlink" title="OC中的NS_NOESCAPE"></a>OC中的NS_NOESCAPE</h4><p>swift里闭包做参数，有escaping和non-escaping的区别。但是接口桥接给OC了之后，在OC中是没有办法知道是不是有escaping的。然后苹果就在OC里也加了一个NS_NOESCAPE的标识符，并且也引入了相关的警告。<br><img src="/images/1539313163_77.png" alt=""><br><img src="/images/1539313204_74.png" alt=""></p><h4 id="Autorelease-Pool外使用Autoreleasing的变量"><a href="#Autorelease-Pool外使用Autoreleasing的变量" class="headerlink" title="Autorelease Pool外使用Autoreleasing的变量"></a>Autorelease Pool外使用Autoreleasing的变量</h4><p>直接来看一个比较隐蔽的错误，下面的代码为什么会Crash呢？<br><img src="/images/1539313946_53.png" alt=""><br>有两个关键因素导致了这个crash，并且大部分人都很难在看代码的时候意识到。</p><ol><li>函数中的输出参数，默认是用__autoreleasing修饰的，即使你不写。</li><li>enumerateXXX这一系列的容器接口，里面的实现是包了一层Autorelease Pool的。</li></ol><p>这就导致了someObj在函数返回之前就已经dealloc了，后面再使用就会导致Use After Free的crash。从控制台的输出也可以看出来，dealloc是在after call之前输出的。<br><img src="/images/1539314934_1.png" alt=""><br>即使是这种比较隐蔽的情况，Xcode10中，静态分析也能指出这种错误了。</p><h3 id="三、安全性提升"><a href="#三、安全性提升" class="headerlink" title="三、安全性提升"></a>三、安全性提升</h3><p> 这个部分在Section中占了比较大的篇幅，不过主要也就讲了两个东西，都是关于防止栈上的写溢出导致的安全性问题，关于栈的基础知识讲解倒是挺多的……</p><h4 id="Stack-Protector"><a href="#Stack-Protector" class="headerlink" title="Stack Protector"></a>Stack Protector</h4><p>先贴一张函数调用栈的结构图，每一个栈桢对应一个函数调用的记录，存储着当前函数要用到的临时变量（栈变量）以及调用完成后要返回到哪里（返回地址）继续执行。<br><img src="/images/1539532681_73.png" alt=""><br>这里还涉及到一种很常见的攻击方法，栈溢出攻击。例如下面这个函数中使用的strcpy函数，它拷贝字符串时并不会判断原串的长度是否超过了目标buffer的长度。攻击者可以恶意的构造一个输入，来覆写当前函数的返回地址，达到控制程序执行流程的目的（跳过一些验证函数等）。<br><img src="/images/1539533246_91.png" alt=""><br>虽然现在使用这些函数会出警告，让你使用它们的安全版本（如strncpy），但是难免会有疏忽的时候。<br>新的编译器加入了Stack Protector这个特性来帮助我们防止这种攻击，原理如下图：<br><img src="/images/1539533945_77.png" alt=""><br><img src="/images/1539533957_92.png" alt=""><br>简单来说就就是在返回地址和栈变量中间加了一小段间隙，这里面会填充一些用于校验的数据，并且自动在函数return之前加入一段检测代码，检测间隙中的数据是否被修改了，如果检测失败，就会强制终止程序。</p><p>这个例子中，如果从栈变量的范围溢出去写返回地址，一定会修改到这块保护区。推测保护区的大小和内容都是会发生变化的，这样攻击者也没法构造一个使保护区不变的输入。</p><p>苹果说这个功能是默认打开的，然而我用他的示例代码并没有出现abort的情况，看反汇编也没有发现有相关的插入的代码在里面。</p><h4 id="Stack-Checking"><a href="#Stack-Checking" class="headerlink" title="Stack Checking"></a>Stack Checking</h4><p>这种保护措施是针对下面这种栈帧的大小也是由输入来控制的函数的。<br><img src="/images/1539535234_63.png" alt=""><br>一种情况是，攻击者传入一个非常大的len，导致这个栈帧的范围与堆的范围有重叠的部分，这样就相当于可以改写任意的堆上的对象了。</p><p>这里有一个前提就是，苹果的系统上，是允许申请一个像这样超大的栈上buffer的，甚至超出物理内存的大小也是可以的。因为系统只会在实际有读写操作时，才会给这段虚拟内存分配一个物理内存上的页，也就是说除了有操作的那一小块虚拟内存，它前后的大段虚拟内存都是不占用物理内存的。<br><img src="/images/1539535965_94.png" alt=""><br>保护的方法也是类似的，在函数入口来检测栈帧的地址范围与堆是否有重叠，是的话也abort掉。<br><img src="/images/1539536569_76.png" alt=""><br>Debug下看反汇编，发现确实有相关的检测代码存在。</p><h3 id="四、新的扩展指令集"><a href="#四、新的扩展指令集" class="headerlink" title="四、新的扩展指令集"></a>四、新的扩展指令集</h3><p>由于没有这些新的设备，就没法实操了，直接上表格吧。<br><img src="/images/1539536873_18.png" alt=""><br>可以看到，移动和桌面平台上，都有SIMD相关的升级。</p><p>桌面端是支持了Intel六代U上增加的AVX512，寄存器宽了一倍，数量也多了一倍，达到32个512bit。</p><p>移动端则是在NEON指令集上增加了半精度浮点的支持，这样在位宽不变的情况下能多放一倍的数据进行并行操作，算是个小更新。据说主要是对机器学习有加成，因为机器学习需要的精度不高。</p><p>最后就是ARM v8.1中增加了原子操作相关的指令，在此之前ARM上的原子操作都是通过Load-link/store-conditional的方式实现的，虽然也是Lock Free的，但是通常需要四条指令。这会加速iOS上APP里用到的原子操作，我自己写项目的时候有时候也会用到，不过总感觉在移动端上，这个东西应该不会造成性能瓶颈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在WWDC上，LLVM这个Section，基本是年年都有，前年写了篇文章介绍了下，今年继续吧。&lt;br&gt;本来想着今年有官方的中文字幕了，可喜可贺、可喜可贺，然而却是下面这样的情况：&lt;br&gt;&lt;img src=&quot;/images/1539259407_77.png&quot; alt=&quot;&quot;&gt;
      
    
    </summary>
    
    
      <category term="llvm,iOS,oc" scheme="http://www.weiyun.com/tags/llvm-iOS-oc/"/>
    
  </entry>
  
  <entry>
    <title>利用函数组合提升代码可维护性</title>
    <link href="http://www.weiyun.com/2018/10/03/func-compose/"/>
    <id>http://www.weiyun.com/2018/10/03/func-compose/</id>
    <published>2018-10-03T14:24:56.000Z</published>
    <updated>2018-10-03T14:52:23.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>函数组合，在函数式编程里面也是挺重要的概念，能够将函数进行操作合并等，在有些场景下可以大幅度提升代码的可读及可维护性。</p><p>下面就演示一些利用函数组合重构代码以达到更好可维护性的例子</p><h3 id="简单场景"><a href="#简单场景" class="headerlink" title="简单场景"></a>简单场景</h3><p>假设有如下代码： </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process1(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process2(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process3(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process4(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure><p>这些函数来处理字符串，如果要组合调用的话，可能会写出来如下的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = ... </span><br><span class="line">str = process1(str) </span><br><span class="line">str = process2(str) </span><br><span class="line">str = process3(str) </span><br><span class="line">str = process4(str) </span><br><span class="line"><span class="comment">// use str</span></span><br></pre></td></tr></table></figure><p>或者更洒脱一些，写出如下的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ret = process4(process3(process2(process1(str))))</span><br></pre></td></tr></table></figure><p>第二种方式可读性不算太好，第一种方式代码写起来又会非常繁琐。那应该如何来优化呢？</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>Swift中是支持<strong>自定义运算符</strong>的，而且swift中<strong>函数是一等公民</strong>。这两个特性是很强大的，利用他们，可以更好的实现函数的组合，可以让代码看起来更简洁、更易读。</p><p>大概的思路是把process1、process2等进行组合，组合成一个新的函数，调用这个新函数的效果，跟分开挨个调用是一样的。</p><p>优化后的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ++ : <span class="type">AdditionPrecedence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> ++ <span class="params">(lhs: @escaping <span class="params">(String)</span></span></span> -&gt; <span class="type">String</span>, rhs: @escaping (<span class="type">String</span>) -&gt; <span class="type">String</span>) -&gt; (<span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; rhs(lhs($<span class="number">0</span>)) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ret = (process1 ++ process2 ++ process3 ++ process4)(str)</span><br></pre></td></tr></table></figure><p>这样写出来的代码，易读且易维护，要增删操作、调整调用顺序等都是很容易的。</p><h3 id="更多场景"><a href="#更多场景" class="headerlink" title="更多场景"></a>更多场景</h3><p>上面这种场景，是比较特殊的场景，函数签名一致并且是同步函数。在真正工作中更普遍的场景是：</p><ol><li>函数签名不一致，如process1(String)，process2(Int, String)</li><li>函数是异步操作，而且回调的闭包类型也不一样等。</li></ol><h4 id="函数签名不一致"><a href="#函数签名不一致" class="headerlink" title="函数签名不一致"></a>函数签名不一致</h4><p>要能组合函数类型不一致的问题，可以参考：<a href="https://iweiyun.github.io/2018/09/04/curry-cleancode/" target="_blank" rel="noopener">利用柯里化去除重复代码</a>，利用柯里化 (严格来说叫partial function application) 可以很容易解决。</p><p>代码示例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">process1(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process2(<span class="number">_</span> i: <span class="type">Int</span>, <span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process3(<span class="number">_</span> i: <span class="type">Int</span>, <span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process4(<span class="number">_</span> i: <span class="type">Int</span>, <span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line"></span><br><span class="line">process1 ++ curry(process2) ++ curry(process3) ++ curry(process4)</span><br></pre></td></tr></table></figure><p>不过这儿补充下，有柯里化，就有<strong>反柯里化</strong>。反柯里化就是给函数增加参数，让该函数跟其它函数类型对齐。</p><p>反柯里化的一种简单实现如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uncurry</span><span class="params">(function: @escaping <span class="params">(String)</span></span></span> -&gt; <span class="type">String</span>) -&gt; (<span class="type">String</span>, <span class="type">Int</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; s, <span class="number">_</span> <span class="keyword">in</span> function(s) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用该反柯里化方式，新的组合代码可以适度简化为这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uncuryy(process1) ++ process2 ++ process3 ++ process4</span><br></pre></td></tr></table></figure><p>uncurry完善的实现，可以参考Github上的一些实现，如 <a href="https://github.com/pointfreeco/swift-overture/blob/master/Sources/Overture/Uncurry.swift" target="_blank" rel="noopener">swift-overture</a></p><h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><p>再来看异步操作的问题。</p><p>说到异步处理，如果熟悉一些异步处理框架，如<a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="noopener">PromiseKit</a>或<a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>，那么可能知道PromiseKit里的Promise或RxSwift里的Observable这两个对象。</p><p>仔细想想，Promise和Observable本身就是很有意思的对象，这些对象可以封装异步操作，当然，也可以表示同步操作，表示纯数据等。这些对象本身也提供了很多操作，操作之后，返回的结果仍然是该对象类型。（在函数式编程里面，这两个对象都可以理解为<a href="http://www.ruanyifeng.com/blog/2015/07/monad.html" target="_blank" rel="noopener">Monad</a>对象）</p><p>理解上面这一点是关键，如果Observable本身可以封装异步操作，那么，一个异步操作就可以表达为一个同步函数，只是返回对象是一个代表同步或异步的对象。这样异步的问题就转变为同步处理的问题了。</p><p>下面继续举个简单的例子</p><p>假设有如下4个异步操作：</p><blockquote><p>asyncProcess1<br>asyncProcess2_1<br>asyncProcess2_2<br>asyncProcess3</p></blockquote><p>1、2、3这几个是并发，2_1和2_2是串行</p><p>用RxSwift写的传统代码大概如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">asyncProcess1(param: [<span class="type">String</span>]) -&gt; <span class="type">Observable</span>&lt;<span class="type">Ret</span>&gt; &#123;&#125;</span><br><span class="line">asyncProcess2_1(param1: <span class="type">Int</span>, param2: [<span class="type">String</span>]) -&gt; <span class="type">Observable</span>&lt;<span class="type">Ret</span>&gt; &#123;&#125;</span><br><span class="line">asyncProcess2_2(param: [<span class="type">String</span>]) -&gt; <span class="type">Observable</span>&lt;<span class="type">Ret</span>&gt; &#123;&#125;</span><br><span class="line">asyncProcess3(param: [<span class="type">String</span>]) -&gt; <span class="type">Observable</span>&lt;<span class="type">Ret</span>&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> process2 = <span class="type">Observable</span>.concat(asyncProcess2_1(value, strs), asyncProcess2_2(strs))</span><br><span class="line"><span class="keyword">let</span> process = <span class="type">Observable</span>.merge([asyncProcess1(strs), process2, asyncProcess3(strs)])</span><br><span class="line"><span class="comment">// some code</span></span><br></pre></td></tr></table></figure><p>下面我们就尝试重构下该代码。</p><p>先定义下通用的concat和merge的操作符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并发两个函数，合并成一个函数</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ||| : <span class="type">RxPrecedence</span></span><br><span class="line"><span class="comment">// 串行两个函数，合并成一个函数</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &gt;&gt;&gt; : <span class="type">RxPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">RxOper</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt; = (<span class="type">T</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> ||| &lt;T, U&gt;<span class="params">(lfun: @escaping RxOper&lt;T, U&gt;, rfun: @escaping RxOper&lt;T, U&gt;)</span></span> -&gt; <span class="type">RxOper</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; value <span class="keyword">in</span></span><br><span class="line">        <span class="type">Observable</span>.merge([lfun(value), rfun(value)])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> &gt;&gt;&gt; &lt;T, U&gt;<span class="params">(lfun: @escaping RxOper&lt;T, U&gt;, rfun: @escaping RxOper&lt;T, U&gt;)</span></span> -&gt; <span class="type">RxOper</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; value <span class="keyword">in</span></span><br><span class="line">        lfun(value).concat(rfun(value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写相应的业务代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新的处理代码</span></span><br><span class="line"><span class="keyword">let</span> process = asyncProcess1 ||| (curry(asyncProcess2_1)(value) &gt;&gt;&gt; asyncProcess2_2) ||| asyncProcess3</span><br><span class="line"><span class="comment">// process(strs)...</span></span><br></pre></td></tr></table></figure><p>新代码的优势一目了然。并且这些例子都是拿的非常简单的示例来讲解的，真正的使用场景上，当操作数量逐渐增加，操作逻辑逐渐复杂时，传统的代码写法的冗余就越能显现。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/ijoshsmith/function-composition-in-swift" target="_blank" rel="noopener">Function Composition in Swift</a></p><p><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/" target="_blank" rel="noopener">RxSwift中文文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;函数组合，在函数式编程里面也是挺重要的概念，能够将函数进行操作合并等，在有些场景下可以大幅度提升代码的可读及可维护性。&lt;/p&gt;
&lt;p&gt;下面就
      
    
    </summary>
    
    
      <category term="swift,函数式,函数组合,rxswift,promise" scheme="http://www.weiyun.com/tags/swift-%E5%87%BD%E6%95%B0%E5%BC%8F-%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88-rxswift-promise/"/>
    
  </entry>
  
  <entry>
    <title>Swift is like Haskell</title>
    <link href="http://www.weiyun.com/2018/09/27/swift-is-like-haskell/"/>
    <id>http://www.weiyun.com/2018/09/27/swift-is-like-haskell/</id>
    <published>2018-09-27T13:08:53.000Z</published>
    <updated>2018-09-29T08:04:15.384Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Swift是一门多泛式语言，而且参考了很多其它语言的实现，所以总能在不同语言里看到一些Swift的影子。</p><p>前段时间看到一篇文章，<a href="https://leverich.github.io/swiftislikescala/" target="_blank" rel="noopener">Swift is like Scala</a>，里面做了Swift和Scala一些语法的对比，有些代码块语法上是很像的。最近又看到了<a href="http://nilhcem.com/swift-is-like-kotlin/" target="_blank" rel="noopener">Swift is like Kotlin</a>，<a href="http://repo.tiye.me/jiyinyiyong/swift-is-like-go/" target="_blank" rel="noopener">Swift is like Go</a>。感觉这些挺有趣的，最近刚好有了解一点Haskell，所以就有了这个想法来对比下相似点。</p><p>这儿只是列出两门语言一些类似的点，或语法，或概念上的。但在真正使用的时候，差别还是巨大的。如果想了解真正的工程中，Haskell的使用，可以参考下 <a href="https://github.com/trending/haskell?since=weekly" target="_blank" rel="noopener">Github Haskell Star排名</a>等</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><hr><h5 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello, world!"</span>)</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">putStrLn</span> <span class="string">"hello, world!"</span></span><br></pre></td></tr></table></figure><hr><h5 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- haskell中没有var定义，只能定义不可修改的变量</span></span><br><span class="line"><span class="title">let</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h5 id="显示指定类型"><a href="#显示指定类型" class="headerlink" title="显示指定类型"></a>显示指定类型</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Float</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> a = <span class="number">5</span> :: <span class="type">Float</span></span><br></pre></td></tr></table></figure><hr><h5 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ret = <span class="string">"111"</span> + <span class="string">"222"</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> ret = <span class="string">"111"</span> ++ <span class="string">"222"</span></span><br></pre></td></tr></table></figure><hr><h5 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lst = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> lst = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]</span><br></pre></td></tr></table></figure><hr><h5 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lst = [<span class="number">1</span> ... <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> lst = [<span class="number">1</span> .. <span class="number">5</span>]<span class="comment">-- [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><hr><h5 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAdd</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> a + b &#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myAdd</span> a b = a + b</span><br></pre></td></tr></table></figure><hr><h5 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAdd</span>&lt;T: Numeric&gt;<span class="params">(<span class="number">_</span> a: T, <span class="number">_</span> b: T)</span></span> -&gt; <span class="type">T</span> &#123; <span class="keyword">return</span> a + b &#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myAdd</span> a b = a + b</span><br></pre></td></tr></table></figure><hr><h5 id="返回元组"><a href="#返回元组" class="headerlink" title="返回元组"></a>返回元组</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b, a * b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">process</span> a b = (a + b, a * b)</span><br></pre></td></tr></table></figure><hr><h5 id="操作符另外的调用方式"><a href="#操作符另外的调用方式" class="headerlink" title="操作符另外的调用方式"></a>操作符另外的调用方式</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(+)(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">// 输出3</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(+) <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><hr><h5 id="自定义操作符"><a href="#自定义操作符" class="headerlink" title="自定义操作符"></a>自定义操作符</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;^&gt; : <span class="type">AdditionPrecedence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> &lt;^&gt;<span class="params">(lhs: Int, rhs: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> lhs + rhs &#125;</span><br><span class="line"><span class="number">5</span> &lt;^&gt; <span class="number">6</span><span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&lt;^&gt;) :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">a</span> &lt;^&gt; b = a + b</span><br><span class="line"><span class="number">5</span> &lt;^&gt; <span class="number">6</span><span class="comment">-- 11</span></span><br></pre></td></tr></table></figure><hr><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">2</span>&#125;<span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> (*<span class="number">2</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]<span class="comment">-- [2, 4, 6]</span></span><br></pre></td></tr></table></figure><hr><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">CGPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> x: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> y: <span class="type">CGFloat</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="type">Double</span> <span class="type">Double</span></span></span><br><span class="line">              <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br></pre></td></tr></table></figure><hr><h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> circle(<span class="type">CGPoint</span>, <span class="type">CGFloat</span>)</span><br><span class="line">    <span class="keyword">case</span> rectangle(<span class="type">CGPoint</span>, <span class="type">CGFloat</span>, <span class="type">CGFloat</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Point</span> <span class="type">Double</span></span></span><br><span class="line">           | <span class="type">Rectangle</span> <span class="type">Point</span> <span class="type">Double</span> <span class="type">Double</span></span><br><span class="line">             <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br></pre></td></tr></table></figure><hr><h5 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e = <span class="type">Shape</span>.circle(<span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>), <span class="number">100</span>)</span><br><span class="line"><span class="keyword">switch</span> e &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .circle(pt, <span class="number">_</span>):</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .rectangle(pt, <span class="number">_</span>, <span class="number">_</span>):</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">shapeInfo</span> :: <span class="type">Shape</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">shapeInfo</span> (<span class="type">Circle</span> pt _) = <span class="string">"Circle point"</span> ++ show pt</span><br><span class="line"><span class="title">shapeInfo</span> (<span class="type">Rectangle</span> pt _ _) = <span class="string">"Rectangle point"</span> ++ show pt</span><br></pre></td></tr></table></figure><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://cnhaskell.com/index.html" target="_blank" rel="noopener">Real World Haskell 中文版</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Swift是一门多泛式语言，而且参考了很多其它语言的实现，所以总能在不同语言里看到一些Swift的影子。&lt;/p&gt;
&lt;p&gt;前段时间看到一篇文章
      
    
    </summary>
    
    
      <category term="haskell,swift,函数式" scheme="http://www.weiyun.com/tags/haskell-swift-%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>利用柯里化去除重复代码</title>
    <link href="http://www.weiyun.com/2018/09/04/curry-cleancode/"/>
    <id>http://www.weiyun.com/2018/09/04/curry-cleancode/</id>
    <published>2018-09-04T11:58:01.000Z</published>
    <updated>2018-09-29T08:04:00.067Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Swift中，函数是一等公民</strong></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>最近因为某个类中有重复代码，在“固化思维”重构之后，虽然原来的重复代码去掉了，但又有如下样式的代码，仔细想想，其实还是有重复，如files和dirs的获取，以及对结果的处理，代码是完全一样的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">WeiyunItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">restore</span><span class="params">(dir: WeiyunDir?)</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> files = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> dirs = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunDir</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">WeiyunSDK</span>.sharedInstance()?.restoreRecycleFile(files, dir: dirs, pdirkey: dir?.dirkey, ppdirkey: dir?.pdirkey, block: &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> = err &#123;</span><br><span class="line">                    observer(.error(error))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    observer(.completed)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">()</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> files = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> dirs = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunDir</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">WeiyunSDK</span>.sharedInstance()?.clearRecycleFile(files, dir: dirs, block: &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> = err, !ignoreError(error) &#123;</span><br><span class="line">                    observer(.error(error))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    observer(.completed)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>按传统的思路来写的话，就是将相同的代码抽取到函数里，然后再调用相应函数来避免重复代码。 重构后大概的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">WeiyunItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">splitItems</span><span class="params">()</span></span> -&gt; ([<span class="type">WeiyunFile</span>], [<span class="type">WeiyunDir</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> files = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> dirs = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunDir</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> (files, dirs)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">processResult</span><span class="params">(observer: PrimitiveSequenceType.CompletableObserver, err: Error?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> = err &#123;</span><br><span class="line">            observer(.error(error))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            observer(.completed)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">restore</span><span class="params">(dir: WeiyunDir?)</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> tuple = splitItems()</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">WeiyunSDK</span>.sharedInstance()?.restoreRecycleFile(tuple.<span class="number">0</span>, dir: tuple.<span class="number">1</span>, pdirkey: dir?.dirkey, ppdirkey: dir?.pdirkey, block: &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.processResult(observer: observer, err: err)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">()</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> tuple = splitItems()</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">WeiyunSDK</span>.sharedInstance()?.clearRecycleFile(tuple.<span class="number">0</span>, dir: tuple.<span class="number">1</span>, block: &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.processResult(observer: observer, err: err)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来还ok，除了Completable.create及Disposables.create()之外，基本没有重复代码了。</p><h4 id="继续思考"><a href="#继续思考" class="headerlink" title="继续思考"></a>继续思考</h4><p>不过，这是终点了吗？并不是，毕竟还有部分代码是重复的。</p><p>我们现在换一种思路来思考，第一张截图里面，除了调用的WeiyunSDK的接口不同，传入的参数不同，其它所有代码都是一样的，那么是否可以在这儿做文章？</p><p>再回到开头看下这句话：Swift中函数是一等公民。这句话的意义是说函数也可以被操作、变换、处理等，你想到的基本都能做。</p><p>那么，把函数作为值传入处理函数中，在处理函数中调用处理就ok。通过传入不同的函数，即可实现调用不同的请求。</p><p>但有个很大的问题，函数类型不一样，restoreRecycleFile多了第2、3两个参数！</p><p>如何把restoreRecycleFile和clearRecycleFile变为具有相同参数的函数，就是要解决的问题。</p><p>今天的主角：<strong>柯里化</strong>，就是来解决这个问题的。</p><h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><p>柯里化是一个通用的概念，在函数式编程里面非常重要。它在维基上的定义是：</p><blockquote><p>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p></blockquote><p>就作用来说，柯里化可以改变函数类型，可以提前绑定其中的参数。</p><p>Github上也有一些现成的柯里化开源库，可以直接用的。如<a href="https://github.com/thoughtbot/Curry" target="_blank" rel="noopener">Curry</a>、<a href="https://github.com/robrix/Prelude" target="_blank" rel="noopener">Prelude</a>等</p><p>可以看如何将两个参数变一个参数的简单实现，以及如何使用柯里化：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">curry</span>&lt;A, B, C&gt;<span class="params">(<span class="number">_</span> function: @escaping <span class="params">(<span class="params">(A, B)</span></span></span></span>) -&gt; <span class="type">C</span>) -&gt; (<span class="type">A</span>) -&gt; (<span class="type">B</span>) -&gt; <span class="type">C</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; (a: <span class="type">A</span>) -&gt; (<span class="type">B</span>) -&gt; <span class="type">C</span> <span class="keyword">in</span> &#123; (b: <span class="type">B</span>) -&gt; <span class="type">C</span> <span class="keyword">in</span> function((a, b)) &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAdd</span><span class="params">(a: Int, b: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = curry(myAdd)(<span class="number">5</span>)<span class="comment">// 这样就可以变为只接受一个参数的函数，</span></span><br><span class="line">f(<span class="number">10</span>)<span class="comment">// 可以这样来调用，并且结果是15</span></span><br></pre></td></tr></table></figure><h4 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h4><p>在我们这个需求场景中，是需要提前绑定第2和3个参数，并且返回只接受三个参数的函数，这些开源库没有提供相应实现，不自己实现一个并不复杂：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以绑定2、3参数的curry化函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">curry2_3</span>&lt;A, B, C, D, E, F&gt;<span class="params">(<span class="number">_</span> function: @escaping <span class="params">(A, B, C, D, E)</span></span></span> -&gt; <span class="type">F</span>) -&gt; (<span class="type">C</span>, <span class="type">D</span>) -&gt; (<span class="type">A</span>, <span class="type">B</span>, <span class="type">E</span>) -&gt; <span class="type">F</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="built_in">c</span>, d <span class="keyword">in</span> &#123; a, b, e <span class="keyword">in</span> function(a, b, <span class="built_in">c</span>, d, e) &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把这个函数用上之后，就可以将代码整理成如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">WeiyunItem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">restore</span><span class="params">(dir: WeiyunDir?)</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> f = curry2_3(<span class="type">WeiyunSDK</span>.sharedInstance().restoreRecycleFile)(dir?.dirkey, dir?.pdirkey)</span><br><span class="line">        <span class="keyword">return</span> operate(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">()</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> f = <span class="type">WeiyunSDK</span>.sharedInstance().clearRecycleFile</span><br><span class="line">        <span class="keyword">return</span> operate(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">operate</span><span class="params">(<span class="number">_</span> function: @escaping <span class="params">([WeiyunFile]?, [WeiyunDir]?, RestoreRecycleItemBlock?)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> files = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> dirs = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunDir</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            function(files, dirs, &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> = err &#123;</span><br><span class="line">                    observer(.error(error))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    observer(.completed)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就没有任何重复代码了</p><p>这儿只是演示了柯里化非常简单的一种使用场景，在函数式编程中，对函数的处理变换无处不在，柯里化也会大放异彩！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Swift中，函数是一等公民&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h4&gt;&lt;p&gt;最近因为某个类中有重复代码，在“固化思维”重构之后，虽然原来的
      
    
    </summary>
    
    
  </entry>
  
</feed>
