<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>微云iOS团队</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.weiyun.com/"/>
  <updated>2018-10-03T14:51:35.093Z</updated>
  <id>http://www.weiyun.com/</id>
  
  <author>
    <name>All</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用函数组合提升代码可维护性</title>
    <link href="http://www.weiyun.com/2018/10/03/func-compose/"/>
    <id>http://www.weiyun.com/2018/10/03/func-compose/</id>
    <published>2018-10-03T14:24:56.000Z</published>
    <updated>2018-10-03T14:51:35.093Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>函数组合，在函数式编程里面也是挺重要的概念，能够将函数进行操作合并等，在有些场景下可以大幅度提升代码的可读及可维护性。</p><p>下面就演示一些利用函数组合重构代码以达到更好可维护性的例子</p><h3 id="简单场景"><a href="#简单场景" class="headerlink" title="简单场景"></a>简单场景</h3><p>假设有如下代码： </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process1(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process2(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process3(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process4(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure><p>这些函数来处理字符串，如果要组合调用的话，可能会写出来如下的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = ... </span><br><span class="line">str = process1(str) </span><br><span class="line">str = process2(str) </span><br><span class="line">str = process3(str) </span><br><span class="line">str = process4(str) </span><br><span class="line"><span class="comment">// use str</span></span><br></pre></td></tr></table></figure><p>或者更洒脱一些，写出如下的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ret = process4(process3(process2(process1(str))))</span><br></pre></td></tr></table></figure><p>第二种方式可读性不算太好，第一种方式代码写起来又会非常繁琐。那应该如何来优化呢？</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>Swift中是支持<strong>自定义运算符</strong>的，而且swift中<strong>函数是一等公民</strong>。这两个特性是很强大的，利用他们，可以更好的实现函数的组合，可以让代码看起来更简洁、更易读。</p><p>大概的思路是把process1、process2等进行组合，组合成一个新的函数，调用这个新函数的效果，跟分开挨个调用是一样的。</p><p>优化后的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ++ : <span class="type">AdditionPrecedence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> ++ <span class="params">(lhs: @escaping <span class="params">(String)</span></span></span> -&gt; <span class="type">String</span>, rhs: @escaping (<span class="type">String</span>) -&gt; <span class="type">String</span>) -&gt; (<span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; rhs(lhs($<span class="number">0</span>)) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ret = (process1 ++ process2 ++ process3 ++ process4)(str)</span><br></pre></td></tr></table></figure><p>这样写出来的代码，易读且易维护，要增删操作、调整调用顺序等都是很容易的。</p><h3 id="更多场景"><a href="#更多场景" class="headerlink" title="更多场景"></a>更多场景</h3><p>上面这种场景，是比较特殊的场景，函数签名一致并且是同步函数。在真正工作中更普遍的场景是：</p><ol><li>函数签名不一致，如process1(String)，process2(Int, String)</li><li>函数是异步操作，而且回调的闭包类型也不一样等。</li></ol><h4 id="函数签名不一致"><a href="#函数签名不一致" class="headerlink" title="函数签名不一致"></a>函数签名不一致</h4><p>要能组合函数类型不一致的问题，可以参考：<a href="https://iweiyun.github.io/2018/09/04/curry-cleancode/" target="_blank" rel="noopener">利用柯里化去除重复代码</a>，利用柯里化 (严格来说叫partial function application) 可以很容易解决。</p><p>代码示例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">process1(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process2(<span class="number">_</span> i: <span class="type">Int</span>, <span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process3(<span class="number">_</span> i: <span class="type">Int</span>, <span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process4(<span class="number">_</span> i: <span class="type">Int</span>, <span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line"></span><br><span class="line">process1 ++ curry(process2) ++ curry(process3) ++ curry(process4)</span><br></pre></td></tr></table></figure><p>不过这儿补充下，有柯里化，就有<strong>反柯里化</strong>。反柯里化就是给函数增加参数，让该函数跟其它函数类型对齐。</p><p>反柯里化的一种简单实现如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uncurry</span><span class="params">(function: @escaping <span class="params">(String)</span></span></span> -&gt; <span class="type">String</span>) -&gt; (<span class="type">String</span>, <span class="type">Int</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; s, <span class="number">_</span> <span class="keyword">in</span> function(s) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用该反柯里化方式，新的组合代码可以适度简化为这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uncuryy(process1) ++ process2 ++ process3 ++ process4</span><br></pre></td></tr></table></figure><p>uncurry完善的实现，可以参考Github上的一些实现，如 <a href="https://github.com/pointfreeco/swift-overture/blob/master/Sources/Overture/Uncurry.swift" target="_blank" rel="noopener">swift-overture</a></p><h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><p>再来看异步操作的问题。</p><p>说到异步处理，如果熟悉一些异步处理框架，如<a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="noopener">PromiseKit</a>或<a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>，那么可能知道PromiseKit里的Promise或RxSwift里的Observable这两个对象。</p><p>仔细想想，Promise和Observable本身就是很有意思的对象，这些对象可以封装异步操作，当然，也可以表示同步操作，表示纯数据等。这些对象本身也提供了很多操作，操作之后，返回的结果仍然是该对象类型。（在函数式编程里面，这两个对象都可以理解为<a href="http://www.ruanyifeng.com/blog/2015/07/monad.html" target="_blank" rel="noopener">Monad</a>对象）</p><p>理解上面这一点是关键，如果Observable本身可以封装异步操作，那么，一个异步操作就可以表达为一个同步函数，只是返回对象是一个代表同步或异步的对象。这样异步的问题就转变为同步处理的问题了。</p><p>下面继续举个简单的例子</p><p>假设有如下4个异步操作：</p><blockquote><p>asyncProcess1<br>asyncProcess2_1<br>asyncProcess2_2<br>asyncProcess3</p></blockquote><p>1、2、3这几个是并发，2_1和2_2是串行</p><p>用RxSwift写的传统代码大概如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">asyncProcess1(param: [<span class="type">String</span>]) -&gt; <span class="type">Observable</span>&lt;<span class="type">Ret</span>&gt; &#123;&#125;</span><br><span class="line">asyncProcess2_1(param1: <span class="type">Int</span>, param2: [<span class="type">String</span>]) -&gt; <span class="type">Observable</span>&lt;<span class="type">Ret</span>&gt; &#123;&#125;</span><br><span class="line">asyncProcess2_2(param: [<span class="type">String</span>]) -&gt; <span class="type">Observable</span>&lt;<span class="type">Ret</span>&gt; &#123;&#125;</span><br><span class="line">asyncProcess3(param: [<span class="type">String</span>]) -&gt; <span class="type">Observable</span>&lt;<span class="type">Ret</span>&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> process2 = <span class="type">Observable</span>.concat(asyncProcess2_1(value, strs), asyncProcess2_2(strs))</span><br><span class="line"><span class="keyword">let</span> process = <span class="type">Observable</span>.merge([asyncProcess1(strs), process2, asyncProcess3(strs)])</span><br><span class="line"><span class="comment">// some code</span></span><br></pre></td></tr></table></figure><p>下面我们就尝试重构下该代码。</p><p>先定义下通用的concat和merge的操作符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并发两个函数，合并成一个函数</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ||| : <span class="type">RxPrecedence</span></span><br><span class="line"><span class="comment">// 串行两个函数，合并成一个函数</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &gt;&gt;&gt; : <span class="type">RxPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">RxOper</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt; = (<span class="type">T</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> ||| &lt;T, U&gt;<span class="params">(lfun: @escaping RxOper&lt;T, U&gt;, rfun: @escaping RxOper&lt;T, U&gt;)</span></span> -&gt; <span class="type">RxOper</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; value <span class="keyword">in</span></span><br><span class="line">        <span class="type">Observable</span>.merge([lfun(value), rfun(value)])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> &gt;&gt;&gt; &lt;T, U&gt;<span class="params">(lfun: @escaping RxOper&lt;T, U&gt;, rfun: @escaping RxOper&lt;T, U&gt;)</span></span> -&gt; <span class="type">RxOper</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; value <span class="keyword">in</span></span><br><span class="line">        lfun(value).concat(rfun(value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写相应的业务代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新的处理代码</span></span><br><span class="line"><span class="keyword">let</span> process = asyncProcess1 ||| (curry(asyncProcess2_1)(value) &gt;&gt;&gt; asyncProcess2_2) ||| asyncProcess3</span><br><span class="line"><span class="comment">// process(strs)...</span></span><br></pre></td></tr></table></figure><p>新代码的优势一目了然。并且这些例子都是拿的非常简单的示例来讲解的，真正的使用场景上，当操作数量逐渐增加，操作逻辑逐渐复杂时，传统的代码写法的冗余就越能显现。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/ijoshsmith/function-composition-in-swift" target="_blank" rel="noopener">Function Composition in Swift</a></p><p><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/" target="_blank" rel="noopener">RxSwift中文文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;函数组合，在函数式编程里面也是挺重要的概念，能够将函数进行操作合并等，在有些场景下可以大幅度提升代码的可读及可维护性。&lt;/p&gt;
&lt;p&gt;下面就
      
    
    </summary>
    
    
      <category term="swift,函数式,函数组合,rxswift,promise" scheme="http://www.weiyun.com/tags/swift-%E5%87%BD%E6%95%B0%E5%BC%8F-%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88-rxswift-promise/"/>
    
  </entry>
  
  <entry>
    <title>Swift is like Haskell</title>
    <link href="http://www.weiyun.com/2018/09/27/swift-is-like-haskell/"/>
    <id>http://www.weiyun.com/2018/09/27/swift-is-like-haskell/</id>
    <published>2018-09-27T13:08:53.000Z</published>
    <updated>2018-09-29T08:04:15.384Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Swift是一门多泛式语言，而且参考了很多其它语言的实现，所以总能在不同语言里看到一些Swift的影子。</p><p>前段时间看到一篇文章，<a href="https://leverich.github.io/swiftislikescala/" target="_blank" rel="noopener">Swift is like Scala</a>，里面做了Swift和Scala一些语法的对比，有些代码块语法上是很像的。最近又看到了<a href="http://nilhcem.com/swift-is-like-kotlin/" target="_blank" rel="noopener">Swift is like Kotlin</a>，<a href="http://repo.tiye.me/jiyinyiyong/swift-is-like-go/" target="_blank" rel="noopener">Swift is like Go</a>。感觉这些挺有趣的，最近刚好有了解一点Haskell，所以就有了这个想法来对比下相似点。</p><p>这儿只是列出两门语言一些类似的点，或语法，或概念上的。但在真正使用的时候，差别还是巨大的。如果想了解真正的工程中，Haskell的使用，可以参考下 <a href="https://github.com/trending/haskell?since=weekly" target="_blank" rel="noopener">Github Haskell Star排名</a>等</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><hr><h5 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello, world!"</span>)</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">putStrLn</span> <span class="string">"hello, world!"</span></span><br></pre></td></tr></table></figure><hr><h5 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- haskell中没有var定义，只能定义不可修改的变量</span></span><br><span class="line"><span class="title">let</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h5 id="显示指定类型"><a href="#显示指定类型" class="headerlink" title="显示指定类型"></a>显示指定类型</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Float</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> a = <span class="number">5</span> :: <span class="type">Float</span></span><br></pre></td></tr></table></figure><hr><h5 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ret = <span class="string">"111"</span> + <span class="string">"222"</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> ret = <span class="string">"111"</span> ++ <span class="string">"222"</span></span><br></pre></td></tr></table></figure><hr><h5 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lst = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> lst = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]</span><br></pre></td></tr></table></figure><hr><h5 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lst = [<span class="number">1</span> ... <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> lst = [<span class="number">1</span> .. <span class="number">5</span>]<span class="comment">-- [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><hr><h5 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAdd</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> a + b &#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myAdd</span> a b = a + b</span><br></pre></td></tr></table></figure><hr><h5 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAdd</span>&lt;T: Numeric&gt;<span class="params">(<span class="number">_</span> a: T, <span class="number">_</span> b: T)</span></span> -&gt; <span class="type">T</span> &#123; <span class="keyword">return</span> a + b &#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myAdd</span> a b = a + b</span><br></pre></td></tr></table></figure><hr><h5 id="返回元组"><a href="#返回元组" class="headerlink" title="返回元组"></a>返回元组</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b, a * b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">process</span> a b = (a + b, a * b)</span><br></pre></td></tr></table></figure><hr><h5 id="操作符另外的调用方式"><a href="#操作符另外的调用方式" class="headerlink" title="操作符另外的调用方式"></a>操作符另外的调用方式</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(+)(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">// 输出3</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(+) <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><hr><h5 id="自定义操作符"><a href="#自定义操作符" class="headerlink" title="自定义操作符"></a>自定义操作符</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;^&gt; : <span class="type">AdditionPrecedence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> &lt;^&gt;<span class="params">(lhs: Int, rhs: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> lhs + rhs &#125;</span><br><span class="line"><span class="number">5</span> &lt;^&gt; <span class="number">6</span><span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&lt;^&gt;) :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">a</span> &lt;^&gt; b = a + b</span><br><span class="line"><span class="number">5</span> &lt;^&gt; <span class="number">6</span><span class="comment">-- 11</span></span><br></pre></td></tr></table></figure><hr><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">2</span>&#125;<span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> (*<span class="number">2</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]<span class="comment">-- [2, 4, 6]</span></span><br></pre></td></tr></table></figure><hr><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">CGPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> x: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> y: <span class="type">CGFloat</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="type">Double</span> <span class="type">Double</span></span></span><br><span class="line">              <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br></pre></td></tr></table></figure><hr><h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> circle(<span class="type">CGPoint</span>, <span class="type">CGFloat</span>)</span><br><span class="line">    <span class="keyword">case</span> rectangle(<span class="type">CGPoint</span>, <span class="type">CGFloat</span>, <span class="type">CGFloat</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Point</span> <span class="type">Double</span></span></span><br><span class="line">           | <span class="type">Rectangle</span> <span class="type">Point</span> <span class="type">Double</span> <span class="type">Double</span></span><br><span class="line">             <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br></pre></td></tr></table></figure><hr><h5 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e = <span class="type">Shape</span>.circle(<span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>), <span class="number">100</span>)</span><br><span class="line"><span class="keyword">switch</span> e &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .circle(pt, <span class="number">_</span>):</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .rectangle(pt, <span class="number">_</span>, <span class="number">_</span>):</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">shapeInfo</span> :: <span class="type">Shape</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">shapeInfo</span> (<span class="type">Circle</span> pt _) = <span class="string">"Circle point"</span> ++ show pt</span><br><span class="line"><span class="title">shapeInfo</span> (<span class="type">Rectangle</span> pt _ _) = <span class="string">"Rectangle point"</span> ++ show pt</span><br></pre></td></tr></table></figure><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://cnhaskell.com/index.html" target="_blank" rel="noopener">Real World Haskell 中文版</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Swift是一门多泛式语言，而且参考了很多其它语言的实现，所以总能在不同语言里看到一些Swift的影子。&lt;/p&gt;
&lt;p&gt;前段时间看到一篇文章
      
    
    </summary>
    
    
      <category term="haskell,swift,函数式" scheme="http://www.weiyun.com/tags/haskell-swift-%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>利用柯里化去除重复代码</title>
    <link href="http://www.weiyun.com/2018/09/04/curry-cleancode/"/>
    <id>http://www.weiyun.com/2018/09/04/curry-cleancode/</id>
    <published>2018-09-04T11:58:01.000Z</published>
    <updated>2018-09-29T08:04:00.067Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Swift中，函数是一等公民</strong></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>最近因为某个类中有重复代码，在“固化思维”重构之后，虽然原来的重复代码去掉了，但又有如下样式的代码，仔细想想，其实还是有重复，如files和dirs的获取，以及对结果的处理，代码是完全一样的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">WeiyunItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">restore</span><span class="params">(dir: WeiyunDir?)</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> files = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> dirs = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunDir</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">WeiyunSDK</span>.sharedInstance()?.restoreRecycleFile(files, dir: dirs, pdirkey: dir?.dirkey, ppdirkey: dir?.pdirkey, block: &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> = err &#123;</span><br><span class="line">                    observer(.error(error))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    observer(.completed)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">()</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> files = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> dirs = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunDir</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">WeiyunSDK</span>.sharedInstance()?.clearRecycleFile(files, dir: dirs, block: &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> = err, !ignoreError(error) &#123;</span><br><span class="line">                    observer(.error(error))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    observer(.completed)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>按传统的思路来写的话，就是将相同的代码抽取到函数里，然后再调用相应函数来避免重复代码。 重构后大概的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">WeiyunItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">splitItems</span><span class="params">()</span></span> -&gt; ([<span class="type">WeiyunFile</span>], [<span class="type">WeiyunDir</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> files = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> dirs = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunDir</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> (files, dirs)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">processResult</span><span class="params">(observer: PrimitiveSequenceType.CompletableObserver, err: Error?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> = err &#123;</span><br><span class="line">            observer(.error(error))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            observer(.completed)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">restore</span><span class="params">(dir: WeiyunDir?)</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> tuple = splitItems()</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">WeiyunSDK</span>.sharedInstance()?.restoreRecycleFile(tuple.<span class="number">0</span>, dir: tuple.<span class="number">1</span>, pdirkey: dir?.dirkey, ppdirkey: dir?.pdirkey, block: &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.processResult(observer: observer, err: err)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">()</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> tuple = splitItems()</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">WeiyunSDK</span>.sharedInstance()?.clearRecycleFile(tuple.<span class="number">0</span>, dir: tuple.<span class="number">1</span>, block: &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.processResult(observer: observer, err: err)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来还ok，除了Completable.create及Disposables.create()之外，基本没有重复代码了。</p><h4 id="继续思考"><a href="#继续思考" class="headerlink" title="继续思考"></a>继续思考</h4><p>不过，这是终点了吗？并不是，毕竟还有部分代码是重复的。</p><p>我们现在换一种思路来思考，第一张截图里面，除了调用的WeiyunSDK的接口不同，传入的参数不同，其它所有代码都是一样的，那么是否可以在这儿做文章？</p><p>再回到开头看下这句话：Swift中函数是一等公民。这句话的意义是说函数也可以被操作、变换、处理等，你想到的基本都能做。</p><p>那么，把函数作为值传入处理函数中，在处理函数中调用处理就ok。通过传入不同的函数，即可实现调用不同的请求。</p><p>但有个很大的问题，函数类型不一样，restoreRecycleFile多了第2、3两个参数！</p><p>如何把restoreRecycleFile和clearRecycleFile变为具有相同参数的函数，就是要解决的问题。</p><p>今天的主角：<strong>柯里化</strong>，就是来解决这个问题的。</p><h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><p>柯里化是一个通用的概念，在函数式编程里面非常重要。它在维基上的定义是：</p><blockquote><p>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p></blockquote><p>就作用来说，柯里化可以改变函数类型，可以提前绑定其中的参数。</p><p>Github上也有一些现成的柯里化开源库，可以直接用的。如<a href="https://github.com/thoughtbot/Curry" target="_blank" rel="noopener">Curry</a>、<a href="https://github.com/robrix/Prelude" target="_blank" rel="noopener">Prelude</a>等</p><p>可以看如何将两个参数变一个参数的简单实现，以及如何使用柯里化：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">curry</span>&lt;A, B, C&gt;<span class="params">(<span class="number">_</span> function: @escaping <span class="params">(<span class="params">(A, B)</span></span></span></span>) -&gt; <span class="type">C</span>) -&gt; (<span class="type">A</span>) -&gt; (<span class="type">B</span>) -&gt; <span class="type">C</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; (a: <span class="type">A</span>) -&gt; (<span class="type">B</span>) -&gt; <span class="type">C</span> <span class="keyword">in</span> &#123; (b: <span class="type">B</span>) -&gt; <span class="type">C</span> <span class="keyword">in</span> function((a, b)) &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAdd</span><span class="params">(a: Int, b: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = curry(myAdd)(<span class="number">5</span>)<span class="comment">// 这样就可以变为只接受一个参数的函数，</span></span><br><span class="line">f(<span class="number">10</span>)<span class="comment">// 可以这样来调用，并且结果是15</span></span><br></pre></td></tr></table></figure><h4 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h4><p>在我们这个需求场景中，是需要提前绑定第2和3个参数，并且返回只接受三个参数的函数，这些开源库没有提供相应实现，不自己实现一个并不复杂：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以绑定2、3参数的curry化函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">curry2_3</span>&lt;A, B, C, D, E, F&gt;<span class="params">(<span class="number">_</span> function: @escaping <span class="params">(A, B, C, D, E)</span></span></span> -&gt; <span class="type">F</span>) -&gt; (<span class="type">C</span>, <span class="type">D</span>) -&gt; (<span class="type">A</span>, <span class="type">B</span>, <span class="type">E</span>) -&gt; <span class="type">F</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="built_in">c</span>, d <span class="keyword">in</span> &#123; a, b, e <span class="keyword">in</span> function(a, b, <span class="built_in">c</span>, d, e) &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把这个函数用上之后，就可以将代码整理成如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">WeiyunItem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">restore</span><span class="params">(dir: WeiyunDir?)</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> f = curry2_3(<span class="type">WeiyunSDK</span>.sharedInstance().restoreRecycleFile)(dir?.dirkey, dir?.pdirkey)</span><br><span class="line">        <span class="keyword">return</span> operate(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">()</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> f = <span class="type">WeiyunSDK</span>.sharedInstance().clearRecycleFile</span><br><span class="line">        <span class="keyword">return</span> operate(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">operate</span><span class="params">(<span class="number">_</span> function: @escaping <span class="params">([WeiyunFile]?, [WeiyunDir]?, RestoreRecycleItemBlock?)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> files = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> dirs = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunDir</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            function(files, dirs, &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> = err &#123;</span><br><span class="line">                    observer(.error(error))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    observer(.completed)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就没有任何重复代码了</p><p>这儿只是演示了柯里化非常简单的一种使用场景，在函数式编程中，对函数的处理变换无处不在，柯里化也会大放异彩！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Swift中，函数是一等公民&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h4&gt;&lt;p&gt;最近因为某个类中有重复代码，在“固化思维”重构之后，虽然原来的
      
    
    </summary>
    
    
  </entry>
  
</feed>
