<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>微云iOS团队</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://iweiyun.github.io/"/>
  <updated>2018-11-19T13:09:09.783Z</updated>
  <id>https://iweiyun.github.io/</id>
  
  <author>
    <name>Weiyun Developer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift函数式编程探索</title>
    <link href="https://iweiyun.github.io/2018/11/19/swift-functional/"/>
    <id>https://iweiyun.github.io/2018/11/19/swift-functional/</id>
    <published>2018-11-19T12:16:54.000Z</published>
    <updated>2018-11-19T13:09:09.783Z</updated>
    
    <content type="html"><![CDATA[<p>开始之前，先推荐个小段子：<a href="http://m.youku.com/video/id_XMzUwMzg4NDAyNA==.html?spm=a2h0k.8191407.0.0&amp;source=&amp;sharetype=2&amp;from=groupmessage&amp;isappinstalled=0" target="_blank" rel="noopener">好久不见</a><br>​<br>以前在iOS上，除了RAC，比较少有函数式编程方面的实践。swift对函数式做了较多的支持，随着swift的普及，在iOS社区，函数式编程被越来越多的开发者所接受。并且因为函数式编程的一些优点，也越来越多的语言开始支持函数式的开发范式。</p><p>因为最近也在项目中开始实践函数式编程，也能逐渐感受到函数式强大之处。目前也有一点心得，本文就谈下自己对函数式编程的理解。</p><p>​        </p><hr><h3 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h3><p>在讲函数式编程之前，我们先来看看这两大编程范式：</p><ul><li>命令式</li><li>声明式</li></ul><p>来粘贴一个关于它们的定义：</p><blockquote><p>命令式编程通过一系列改变程序状态的指令来完成计算。命令式编程模拟电脑运算，是行动导向的，关键在于定义解法，即“怎么做”，因而算法是显性而目标是隐性的。</p><p>声明式编程只描述程序应该完成的任务。声明式编程模拟人脑思维，是目标驱动的，关键在于描述问题，即“做什么”，因而目标是显性而算法是隐性的。</p></blockquote><p>这两种范式的关键区别就在于，一个主要表达“怎么做”，一个主要表达“做什么”。通过两段代码，可以直观的感受一下它们的区别：<br><img src="/images/swift-functional/1542568661_33.png" alt="命令式"><br><img src="/images/swift-functional/1542568666_91.png" alt="声明式"><br>这两段代码都是做的同一件事，把数组里每个元素都乘2，再打印出来。<br>可以看出来，我们平时使用的主要都是命令式的写法，包括使用的最多的面向对象编程(OOP)，其实还是属于命令式编程的范畴。而这篇文章要讲的函数式编程，则是属于声明式编程。</p><p>​    </p><hr><h3 id="函数式编程的优势"><a href="#函数式编程的优势" class="headerlink" title="函数式编程的优势"></a>函数式编程的优势</h3><ul><li>减轻程序员思考的负担（防秃），降低出错的可能性</li></ul><p>就拿上面举的例子来说，先不说一眼望去，命令式写法的复杂性就明显要高得多，即使是一个如此简单的逻辑，也容易写出错误。<br>当时写这个例子的时候，为了突出它们的区别，我故意没用for in range这种比较常规的写法，而使用了while，自己维护index。然鹅第一次跑起来就死循环了，再检查，发现是红框里的index加1漏了写。<br>函数式写法中，因为没有了状态的维护，杜绝了这种错误的发生。</p><ul><li>代码可读性高</li><li>更简洁、更少的代码</li></ul><p>看回定义，声明式编程描述“做什么”，目标是显性而算法是隐性的。而阅读代码时我们往往只关心代码做了什么，而不关心怎么做，这与声明式编程的思想是不谋而合的，所以函数式编程具有更高的代码可读性。<br>同时为了实现这种思想，算法的实现往往是内建的，或是隐藏的，这也让函数式的实现具有更少的代码，看起来更简洁。</p><ul><li>适用于并发环境</li><li>易于优化</li></ul><p>函数式编程中所使用的函数，大多要求为纯函数，这里可以先理解为数学意义上的函数，在相同的参数输入的情况下，一定会有同样的输出。<br>这一特点决定了纯函数可以并行的调用，而无需任何修改，因为无论并行与否，它都能输出正确的结果。<br><img src="/images/swift-functional/1542597555_48.png" alt="并发"><br>上图parallelMap函数的实现就是将数组分成多段，然后在多个线程中分别调用map，最后再拼回一整个。通过这一点改动，就简单的对这个程序进行了多线程的性能优化。</p><ul><li>细粒度的重用（函数级别）</li><li>易于测试</li></ul><p>纯函数除了之前说的，还要求“没有任何可观察的副作用，不依赖外部环境的状态”。<br>后半还是容易理解的，因为只要依赖了外部环境，就不能保证相同输入得到相同输出了。<br>前半所说的副作用，是指除了返回值外，函数还通过其他方式对调用环境产生了影响，例如修改全局变量，写文件，print到控制台等等。<br>纯函数很容易进行单元测试，只需关心输入输出即可。重用也是同理，不必考虑调用的顺序，不用担心影响后续逻辑，放心的复用。<br><img src="/images/swift-functional/1542614984_40.png" alt="函数重用"></p><ul><li>易于重构</li></ul><p>原因也就是前面说的那些，纯函数之间的依赖关系就是一个树，很容易理清。而对象之间的依赖就复杂得多，做过重构的同学应该都有体会，如果没有把代码看的很熟，是不敢轻易去动的。书里有一句话总结的很到位：<br><img src="/images/swift-functional/1542615515_42.png" alt="FP和OO"></p><p>​    </p><hr><h3 id="函数式编程指南"><a href="#函数式编程指南" class="headerlink" title="函数式编程指南"></a>函数式编程指南</h3><p>概念都了解了，那要怎么应用到实际的项目中呢？只要在编写代码时，往下面这几点靠，自然就能写出函数式风格的代码了：</p><ul><li>只定义纯函数</li><li>不要用可变量</li><li>递归代替迭代</li><li>尽量少的数据结构</li><li>闭包、高阶函数的应用</li><li>尽可能使用内置的数据结构</li><li>尽可能使用内置的函数式工具</li></ul><p>但是并非所有功能都适合用函数式来编写，很多情况下副作用是无法避免的：</p><blockquote><p>函数式语言和逻辑式语言擅长基于数理逻辑的应用，命令式语言擅长基于业务逻辑的、尤其是交互式或事件驱动型的应用。</p></blockquote><p>现阶段遇到这些情况时，还是不要强行应用函数式了，特别是苹果的系统框架还是基于面向对象的。</p><p>​<br>接下来举个🌰：<br>我们项目中有这样一个需求，在一个列表中，有多种元素（文件、文件夹、笔记等）。还有多种操作，每种操作支持的类型、数量不同。现在选中了一些元素，求能对这些元素进行哪些操作。<br>例如，选中一个文件、一个文件夹，这时可以进行移动操作（批量、不支持笔记），但不能进行重命名操作（只支持单个）。<br>这是一个很常见的需求，并且不涉及UI、交互，适合用函数式来改造一下。</p><p>​    </p><p>最终我们需要这样一个东西，输入选择的元素列表，得到支持的操作集合。我们把它定义成Strategy类型，是一类函数，在函数式编程里，函数就是一等公民。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Strategy</span> = (<span class="number">_</span> items: [<span class="type">Any</span>]) -&gt; <span class="type">Set</span>&lt;<span class="type">WYOperationType</span>&gt;</span><br></pre></td></tr></table></figure><p>光有Strategy还不够，我们要直接实现这样一个函数还是太过复杂，而且也不够灵活，需要把它拆解为更小的单元。<br>我采用的方法是，先定义一个默认的操作集合，包含了最常规的操作。然后定义一些Modifier来修改默认的操作集合。不同类型的元素支持哪些操作就定义在不同的Modifier里。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> defaultStrategy: <span class="type">Strategy</span> = &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">[.delete, .share, .safeBoxMoveIn,</span><br><span class="line">     .safeBoxMoveOut, .shareDirWithFriend, .rename,</span><br><span class="line">     .download, .jumpToDir, .openIn,</span><br><span class="line">     .favour, .move, .inbox, .unInbox,</span><br><span class="line">     .fileInfo, .ocr, .groupMove,</span><br><span class="line">     .noteGroup, .genPDF, .genGIF]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Modifier</span> = (<span class="number">_</span> items: [<span class="type">Any</span>], <span class="number">_</span> operations: <span class="type">Set</span>&lt;<span class="type">WYOperationType</span>&gt;) -&gt; <span class="type">Set</span>&lt;<span class="type">WYOperationType</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">modify</span>(<span class="title">_</span> <span class="title">strategy</span>: @<span class="title">escaping</span> <span class="title">Strategy</span>, <span class="title">_</span> <span class="title">modifier</span>: @<span class="title">escaping</span> <span class="title">Modifier</span>) -&gt; <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; items <span class="keyword">in</span></span><br><span class="line">        modifier(items, strategy(items))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的modify函数，其实就是一个带items参数的compose（组合）操作。</p><p>下面我们就来定义一个目录的modifier：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> dirSupported: <span class="type">Operand</span> = &#123; items <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> dirs = items.<span class="built_in">lazy</span>.compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunDir</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> dirs.first.<span class="built_in">map</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> $<span class="number">0</span>.isCollecting() &#123;</span><br><span class="line">            <span class="keyword">return</span> [.share, .shareDirWithFriend, .safeBoxMoveIn, .move, .inbox, .unInbox, .delete, .rename]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [.share, .shareDirWithFriend, .safeBoxMoveIn, .move, .inbox, .delete, .rename]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> dirModifier: <span class="type">Modifier</span> = buildModifier(dirSupported, intersection)</span><br></pre></td></tr></table></figure><p>dirSupported判断items中是否有目录，有的话就返回目录支持的操作，通过buildModifier和intersection，构造了一个“如果含有目录，就将目前的操作集合与目录支持的操作集合取交集”的一个Modifier。<br>考虑到Modifier其实也就只有支持、不支持、添加三种情况，分别对应集合的交、差、并集，就通过“返回操作集合”的Operand函数，和三种SetOperation来build一个Modifier，将Modifier的逻辑也细分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">SetOperation</span> = (<span class="number">_</span> first: <span class="type">Set</span>&lt;<span class="type">WYOperationType</span>&gt;, <span class="number">_</span> second: <span class="type">Set</span>&lt;<span class="type">WYOperationType</span>&gt;) -&gt; <span class="type">Set</span>&lt;<span class="type">WYOperationType</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> union: <span class="type">SetOperation</span> = &#123; $<span class="number">0</span>.union($<span class="number">1</span>) &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> subtracting: <span class="type">SetOperation</span> = &#123; $<span class="number">0</span>.subtracting($<span class="number">1</span>) &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> intersection: <span class="type">SetOperation</span> = &#123; $<span class="number">0</span>.intersection($<span class="number">1</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Operand</span> = (<span class="number">_</span> items: [<span class="type">Any</span>]) -&gt; <span class="type">Set</span>&lt;<span class="type">WYOperationType</span>&gt;?</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">buildModifier</span>(<span class="title">_</span> <span class="title">operand</span>: @<span class="title">escaping</span> <span class="title">Operand</span>, <span class="title">_</span> <span class="title">setOperation</span>: @<span class="title">escaping</span> <span class="title">SetOperation</span>) -&gt; <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; items, operations <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> ret = operand(items) &#123;</span><br><span class="line">            <span class="keyword">return</span> setOperation(operations, ret)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> operations</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面定义了几个用于将Modifier进行组合的函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> emptyModifier: <span class="type">Modifier</span> = &#123; $<span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">concat</span>(<span class="title">_</span> <span class="title">modifierLeft</span>: @<span class="title">escaping</span> <span class="title">Modifier</span>, <span class="title">_</span> <span class="title">modifierRight</span>: @<span class="title">escaping</span> <span class="title">Modifier</span>) -&gt; <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; items, operations <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> modifierRight(items, modifierLeft(items, operations))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">concatModifiers</span>(<span class="title">_</span> <span class="title">modifiers</span>: [<span class="title">Modifier</span>]) -&gt; <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> modifiers.<span class="built_in">reduce</span>(emptyModifier) &#123; concat($<span class="number">0</span>, $<span class="number">1</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了Modifier的compose函数，就可以定义更复杂的文件和笔记的Modifier了。<br>最后还有一个count的Modifier，是专门用来在多选的情况下，去除只支持单元素的操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> fileSupported: <span class="type">Operand</span> = &#123; items <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> files = items.<span class="built_in">lazy</span>.<span class="built_in">filter</span> &#123; !($<span class="number">0</span> <span class="keyword">is</span> <span class="type">WeiyunNote</span>) &#125;.compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> files.first.<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        [.download, .share, .shareDirWithFriend,</span><br><span class="line">         .fileInfo, .safeBoxMoveIn, .move,</span><br><span class="line">         .jumpToDir, .delete, .favour,</span><br><span class="line">         .rename, .openIn, .ocr,</span><br><span class="line">         .groupMove, .genGIF]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> fileUnsupported: <span class="type">Operand</span> = &#123; items <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> files = items.<span class="built_in">lazy</span>.<span class="built_in">filter</span> &#123; !($<span class="number">0</span> <span class="keyword">is</span> <span class="type">WeiyunNote</span>) &#125;.compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> noOcr = files.<span class="built_in">filter</span> &#123; !$<span class="number">0</span>.isShouldShowOCRAction() &#125;.first</span><br><span class="line">    <span class="keyword">let</span> noImgVid = files.<span class="built_in">filter</span> &#123; !$<span class="number">0</span>.isImageFile() &amp;&amp; !$<span class="number">0</span>.isVideoFile() &#125;.first</span><br><span class="line">    <span class="keyword">let</span> noLivePhoto = files.<span class="built_in">filter</span> &#123; !$<span class="number">0</span>.isLivePhoto &#125;.first</span><br><span class="line">    <span class="keyword">let</span> secondFile = files.<span class="built_in">dropFirst</span>().first</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result: [<span class="type">WYOperationType</span>] = (noOcr != <span class="literal">nil</span> ? [.ocr] : []) + (noImgVid != <span class="literal">nil</span> ? [.groupMove, .genGIF] : []) + (noLivePhoto != <span class="literal">nil</span> ? [.genGIF] : []) + (secondFile != <span class="literal">nil</span> ? [.genGIF] : [])</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Set</span>&lt;<span class="type">WYOperationType</span>&gt;(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> fileModifier: <span class="type">Modifier</span> = concatModifiers([buildModifier(fileSupported, intersection), buildModifier(fileUnsupported, subtracting)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> noteSupported: <span class="type">Operand</span> = &#123; items <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> notes = items.<span class="built_in">lazy</span>.compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunNote</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> notes.first.<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> [.share, .delete, .noteGroup, .favour]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> noteUnsupported: <span class="type">Operand</span> = &#123; items <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> notes = items.<span class="built_in">lazy</span>.compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunNote</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> notes.<span class="built_in">dropFirst</span>().first.<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> [.favour]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> noteModifier: <span class="type">Modifier</span> = concatModifiers([buildModifier(noteSupported, intersection), buildModifier(noteUnsupported, subtracting)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> countUnsupported: <span class="type">Operand</span> = &#123; items <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> wyItems = items.<span class="built_in">lazy</span>.compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunItem</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> wyItems.<span class="built_in">dropFirst</span>().first.<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> [.ocr, .fileInfo, .rename, .jumpToDir, .openIn, .inbox, .unInbox]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> countModifier: <span class="type">Modifier</span> = buildModifier(countUnsupported, subtracting)</span><br></pre></td></tr></table></figure><p>最后定义一个applyModifiers来应用一组Modifier：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">applyModifiers</span>(<span class="title">_</span> <span class="title">strategy</span>: @<span class="title">escaping</span> <span class="title">Strategy</span>, <span class="title">_</span> <span class="title">modifiers</span>: [<span class="title">Modifier</span>]) -&gt; <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> modifiers.<span class="built_in">reduce</span>(strategy) &#123; modify($<span class="number">0</span>, $<span class="number">1</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> filesTabStrategy: <span class="type">Strategy</span> = applyModifiers(defaultStrategy, [dirModifier, fileModifier, noteModifier, countModifier])</span><br></pre></td></tr></table></figure><p>filesTabStrategy就可以拿到我们APP的文件列表去用了，选中一些项目后，根据Strategy返回的操作集合来展示操作菜单。<br>如果其他场景有不同的需求，可以编写自己的Modifier，再与现有的一顿组合即可。</p><p>主要思想就是把函数、闭包作为数据来操作，运用于高阶函数。还要熟悉函数式编程的三板斧（map、filter、reduce）和lazy等函数式工具，遵循开头的那几个要点来编写代码，就算是入了函数式的大门了。</p><p>​    </p><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>纯函数的引用透明</li></ul><p>引用透明网上有很多种解释，函数式里，是指函数运行的结果与函数本身，是可以互相替代的。显然纯函数是具有引用透明性的，所以可以延迟执行而不影响结果，这是lazy能正确执行的理论前提。这里给出一个比较有意思的lazy filter的实现：<br><img src="/images/swift-functional/1542626381_77.png" alt="LazyArray"></p><ul><li>记忆<br>可以简单的对纯函数进行缓存，提高性能。<br>Swift里虽然没有内建的实现，但是自己实现一个也很简单：<br><img src="/images/swift-functional/1542626458_75.png" alt="memorize"><br>生产环境使用时还要考虑内存占用、淘汰等。</li><li>递归代替迭代<br><img src="/images/swift-functional/1542626659_3.png" alt="递归"><br>这里实现的是“每隔1、2、3、4……个数，取一个数”。<br>不能使用var时，我们需要将迭代换成递归实现。好处就不再赘述了，并且符合函数式的原则。<br>这里需要注意的是要用上尾递归，防止爆栈。<br>然而我在swift上测试时，还是出现了爆栈的情况，网上查了资料说是swift不保证尾递归优化，好吧……</li><li>let的性能问题<br><img src="/images/swift-functional/1542627283_39.png" alt="插入百万数据"><br><img src="/images/swift-functional/1542627287_75.png" alt="将十个数据插入百万元素的字典"><br>纯函数式语言大概是不会出现这样的情况的，运行时的优化，数据结构的高度优化，结果应该是跟用var差不多的性能才对。至少以我的知识，都能实现一个插入时间复杂度为O(log n)的不可变字典。<br>swift估计是没有做这方面的优化，赋值给var时应该是发生了拷贝。并且let的dict也没有插入一个值，返回一个新let dict的方法。</li><li>运算符重载<br><img src="/images/swift-functional/1542627988_47.png" alt="运算符重载"></li><li>ReactiveX</li></ul><p>将Async、Lazy、Multi-threading版本的函数式工具，引入了面向对象编程，非常值得使用。</p><p>​    </p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然说swift引入了许多函数式编程的东西，光从“没有尾递归优化”和“不可变数据结构优化”这两点来看，实际上还是不能完全按照纯函数式语言的那一套来编码的。<br>函数式编程，现阶段也还不会在项目中大量运用，但是这种思维，确实可以给我们平时的编码带来不一样的启发。<br>以目前swift的能力来说，一些比较简单的函数式的应用还是可以胜任的。<br>即使在OO的编程中，这些函数式的工具也能够对简化代码、逻辑起到很大的作用。</p><p>​    </p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.zhihu.com/pub/reader/119565028" target="_blank" rel="noopener">《函数式编程思维》</a><br><a href="https://objccn.io/products/functional-swift/" target="_blank" rel="noopener">《Swift函数式编程》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开始之前，先推荐个小段子：&lt;a href=&quot;http://m.youku.com/video/id_XMzUwMzg4NDAyNA==.html?spm=a2h0k.8191407.0.0&amp;amp;source=&amp;amp;sharetype=2&amp;amp;from=group
      
    
    </summary>
    
    
      <category term="swift,functional" scheme="https://iweiyun.github.io/tags/swift-functional/"/>
    
  </entry>
  
  <entry>
    <title>深入理解苹果系统（Unicode）字符串的排序方法</title>
    <link href="https://iweiyun.github.io/2018/11/16/Understand-Apple-s-Sorting-Strings/"/>
    <id>https://iweiyun.github.io/2018/11/16/Understand-Apple-s-Sorting-Strings/</id>
    <published>2018-11-16T11:37:37.000Z</published>
    <updated>2018-11-16T12:43:32.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h2><p>我们知道计算机是不能直接处理文本的，而是和数字打交道。因此，为了表示文本，就建立了一个字符到数字的映射表，叫做编码。最著名的字符编码就是ASCII了，它使用7-bit来表示应用字母表以及数字和其他字符。这对于英语来说是够用了，但是对于其他语言，这个7-bit就不能满足条件了，因为字符远远超过了7-bit所能表示的最大个数。因此1987年，来自几个大的科技公司的工程师开始合作开发一种致力于能在全世界的所有书写系统中都能通用的字符编码系统，并与1991年10发布了Unicode的1.0.0标准。2018年6月发布了Unicode的11.0版本。这里就不再对Unicode做过多的介绍，值得注意的是，在iOS开发中，常使用的的NSString是基于Unicode-16来开发的，这是因为当时开发这个的时候Unicode标准还是以16bit固定长度来编码，这就导致使用上的一些坑，建议大家阅读下这篇文章：<a href="https://www.objc.io/issues/9-strings/unicode/" title="NSString and Unicode" target="_blank" rel="noopener">NSString and Unicode</a>。</p><h2 id="UCA和CLDR：最常用到的排序标准"><a href="#UCA和CLDR：最常用到的排序标准" class="headerlink" title="UCA和CLDR：最常用到的排序标准"></a>UCA和CLDR：最常用到的排序标准</h2><p>介绍完Unicode编码之后，我们就可以来介绍UCA（Unicode Collation Algorithm）和CLDR（Common Locale Data Repository）了，因为苹果的NSString的<a href="https://developer.apple.com/documentation/foundation/nsstring?language=objc" title="介绍文档" target="_blank" rel="noopener">介绍文档</a>里有这么一句话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Localized string comparisons are based on the Unicode Collation Algorithm, as tailored for different languages by CLDR (Common Locale Data Repository). Both are projects of the Unicode Consortium. Unicode is a registered trademark of Unicode, Inc.</span><br></pre></td></tr></table></figure></p><p>说白了，苹果系统的NSString字符串排序是基于UCA的，并且在不同语言下，经过CLDR来裁剪的。</p><h3 id="UCA（Unicode-Collation-Algorithm）"><a href="#UCA（Unicode-Collation-Algorithm）" class="headerlink" title="UCA（Unicode Collation Algorithm）"></a>UCA（Unicode Collation Algorithm）</h3><p>UCA的介绍官方文档介绍在这里：<a href="http://unicode.org/reports/tr10/#Introduction" title="UCA介绍" target="_blank" rel="noopener">UCA介绍</a>。其中第一句话就写的很清楚，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collation is the general term for the process and function of determining the sorting order of strings of characters.</span><br></pre></td></tr></table></figure></p><p>对字符串排序的过程就是Collation，UCA就是Unicode表示的字符串进行排序的规则，制定这个规则的原因是不同语种对字符串的排序规则要求是不一样的，比如，德国、法国和瑞士对相同的字符排序的规则是不一样的，甚至在同一个语言下比如中文，多音字这种在不同组合里，排序的先后顺序也是不一样的。<br><img src="/images/sort_1.png" alt="差异化举例"><br>因此可以想象，UCA指定的规则比较复杂。感兴趣的可以读下前面贴的UCA介绍，里面有具体的排序规则介绍。</p><h3 id="CLDR（Common-Locale-Data-Repository）"><a href="#CLDR（Common-Locale-Data-Repository）" class="headerlink" title="CLDR（Common Locale Data Repository）"></a>CLDR（Common Locale Data Repository）</h3><p>CLDR的官方文档在这里：<a href="http://cldr.unicode.org/#TOC-What-is-CLDR-" title="CLDR介绍" target="_blank" rel="noopener">CLDR介绍</a>。CLDR是一堆语言数据仓库，为软件提供各种世界语言版本提供了基础，目前在使用CLDR的公司有：</p><blockquote><ul><li>Apple (macOS, iOS, watchOS, tvOS, and several applications; Apple Mobile Device Support and iTunes for Windows; …)</li><li>Google (Web Search, Chrome, Android, Adwords, Google+, Google Maps, Blogger, Google Analytics, …)</li><li>IBM (DB2, Lotus, Websphere, Tivoli, Rational, AIX, i/OS, z/OS,…)</li><li>Microsoft (Windows, Office, Visual Studio, …)</li></ul></blockquote><p>其他公司：</p><blockquote><ul><li>ABAS Software, Adobe, Amazon (Kindle), Amdocs, Apache, Appian, Argonne National Laboratory, Avaya, Babel (Pocoo library), BAE Systems Geospatial eXploitation Products, BEA, BluePhoenix Solutions, BMC Software, Boost, BroadJump, Business Objects, caris, CERN, Debian Linux, Dell, Eclipse, eBay, EMC Corporation, ESRI, Firebird RDBMS, FreeBSD, Gentoo Linux, GroundWork Open Source, GTK+, Harman/Becker Automotive Systems GmbH, HP, Hyperion, Inktomi, Innodata Isogen, Informatica, Intel, Interlogics, IONA, IXOS, Jikes, jQuery, Library of Congress, Mathworks, Mozilla, Netezza, OpenOffice, Oracle (Solaris, Java), Lawson Software, Leica Geosystems GIS &amp; Mapping LLC, Mandrake Linux, OCLC, Perl, Progress Software, Python, QNX, Rogue Wave, SAP, Shutterstock, SIL, SPSS, Software AG, SuSE, Symantec, Teradata (NCR), ToolAware, Trend Micro, Twitter, Virage, webMethods, Wikimedia Foundation (Wikipedia), Wine, WMS Gaming, XyEnterprise, Yahoo!, Yelp</li></ul></blockquote><p>对于不同区域（local），可以找到不同的数据CLDR，结合UCA对字符串进行排序，就做到了不同语言下的本地化排序。可以去 <a href="http://cldr.unicode.org/" target="_blank" rel="noopener">http://cldr.unicode.org/</a>  下载最新的CLDR库，后面将会用到里面的一些内容。</p><hr><h2 id="字符分类与排序规则"><a href="#字符分类与排序规则" class="headerlink" title="字符分类与排序规则"></a>字符分类与排序规则</h2><h3 id="字符分类与Unicode码点值排序"><a href="#字符分类与Unicode码点值排序" class="headerlink" title="字符分类与Unicode码点值排序"></a>字符分类与Unicode码点值排序</h3><p>Unicode把所有的字符分为两类：</p><ol><li>common charaters<br>包括空格，标点，通用符号，货币符号，数字等。</li><li>script charaters<br>包括拉丁字母，希腊字母，汉字等。<br>这样经过分类，便于把一类字符统一集中在一起。</li></ol><p>通常情况下，我们是通过unicode 的UTF-16码点值逐个进行比较大小的来进行排序的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSArray *rawArray = @[@&quot;爱你&quot;, @&quot;一生一世&quot;,@&quot;㊀&quot;, @&quot;上&quot;,@&quot;㊤&quot;,@&quot;μ&quot;,@&quot;язык&quot;,@&quot;..&quot;,@&quot;123&quot;,@&quot;@&quot;,@&quot;AA&quot;,@&quot;abc&quot;,@&quot;abb&quot;];</span><br><span class="line">//1. 默认排序方式</span><br><span class="line">NSArray *defaultedSortedArray = [rawArray sortedArrayUsingComparator:^NSComparisonResult(id  _Nonnull obj1, id  _Nonnull obj2) &#123;</span><br><span class="line">    return [obj1 compare:obj2 options:NSCaseInsensitiveSearch];</span><br><span class="line">&#125;];</span><br><span class="line">__block NSMutableArray *codeUnits = [NSMutableArray array];</span><br><span class="line">[defaultedSortedArray enumerateObjectsUsingBlock:^(NSString*  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">    [codeUnits addObject:@([obj characterAtIndex:0])];</span><br><span class="line">&#125;];</span><br><span class="line">NSLog(@&quot;默认Unicode码点值排序 %@ 对应的各个字符串的首字符码点值是 %@&quot;, [defaultedSortedArray descriptionWithLocale:cnLocal], codeUnits);</span><br></pre></td></tr></table></figure></p><p>输出结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">排序结果 </span><br><span class="line"> ..  123  @  AA  abb  abc  μ  язык  ㊀  ㊤  一生一世  上  爱你 </span><br><span class="line"> 对应的各个字符串的首字符码点值是 </span><br><span class="line"> 46  49  64  65  97  97  956  1103  12928  12964  19968  19978  29233</span><br></pre></td></tr></table></figure></p><p>我们常用的各种字符的码点值范围是：</p><ul><li>0-9 U+0030 - U0039</li><li>a-z U+0061 - U+007A</li><li>A-Z U+0041 - U+005A<br>具体可通过：<a href="https://unicode-table.com/en/#control-character" title="unicode-table" target="_blank" rel="noopener">unicode-table</a>查询。</li></ul><h3 id="UCA-默认排序"><a href="#UCA-默认排序" class="headerlink" title="UCA 默认排序"></a>UCA 默认排序</h3><p>在我们前面下载的文件CLDR库有个/common/uca/allkeys_CLDR.txt文件，它表示我们指定locale为“en”或者说是默认的排序规则。它的格式是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000  ; [.0000.0000.0000] # &lt;NULL&gt;</span><br><span class="line">0001  ; [.0000.0000.0000] # &lt;START OF HEADING&gt;</span><br><span class="line">0002  ; [.0000.0000.0000] # &lt;START OF TEXT&gt;</span><br><span class="line">0003  ; [.0000.0000.0000] # &lt;END OF TEXT&gt;</span><br></pre></td></tr></table></figure></p><p>分号前的值表示码点，分号后中括号里面的值表示UCA算法权重，用<code>.</code>号来区分，Unicode字符就是按照这个规则从上到下排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSLocale *enLocale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en&quot;];</span><br><span class="line">defaultedSortedArray = [rawArray sortedArrayUsingComparator:^NSComparisonResult(NSString*  _Nonnull obj1, NSString*  _Nonnull obj2) &#123;</span><br><span class="line">    return [obj1 compare:obj2 options:0 range:NSMakeRange(0, obj1.length) locale:enLocale];</span><br><span class="line">&#125;];</span><br><span class="line">NSLog(@&quot;默认排序规则或者指定地区为locale后的排序结果是 %@&quot;, [defaultedSortedArray descriptionWithLocale:cnLocal]);</span><br></pre></td></tr></table></figure></p><p>排序结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认排序规则或者指定地区为en后的排序结果是 </span><br><span class="line"> ..  （ch  (en  @  123  AA  abb  abc  μ  язык  ㊀  一生一世  上  ㊤  爱你</span><br></pre></td></tr></table></figure></p><p>这种排序依次为符号，数字，英文/汉字等script charaters。</p><h3 id="CLDR调整后的排序"><a href="#CLDR调整后的排序" class="headerlink" title="CLDR调整后的排序"></a>CLDR调整后的排序</h3><p>在下载的CLDR文件中，有个common/bcp47/collation.xml文件，列出了可选的排序方式，有standard,pinyin, stroke（笔画排序）等。<br><img src="/images/sort_2.png" alt="排序可选方式"><br>那如何确定各个区域语言下，该使用哪种排序规则呢，我们可以看到common/collation/文件夹下，有很多标记语言LDML文件，这些文件就是表示在不同区域语言下，采用的排序规则。<br><img src="/images/sort_3.png" alt=""></p><p>我们打开zh.xml，这个就是我们简体中文的排序规则，可以看到，里面默认采用的排序是pinyin排序，并且在开头还写了各个声调字母的排序先后顺序。</p><p><img src="/images/sort_4.png" alt=""></p><ol><li>首先按照pinyin声调的先后顺序进行排序，即zh.xml底下列出的先后顺序进行排序。</li><li>如果是在同一行的汉字，则按照笔画由少到多的顺序进行排序。</li><li>如果还不能区分大小，就按照kRSUnicode （偏旁索引的方式，按照康熙字典的定义）的先后顺序进行排序。</li></ol><p>假如我们指定区域为zh_CN，则对于字符串中出现的中文则排在其他语言字符串前面。其他script charater则按照allkeys_CLDR.txt的顺序进行进行排序。值得注意的是，中文由于多音字，在这里不一定能够完全按照我们的习惯排序正确，比如“重逢（chong feng）”就没有第一个拼音chong去排，而是按照zhong来排列的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">默认排序规则或者指定地区为zh_CN后的排序结果是 </span><br><span class="line"> ..  （ch  (en  @  0124  123  艾你  爱你  産  上  ㊤  ㊀  一生一世  重逢  重要  aa  AA  abb  μ  язык </span><br><span class="line"> </span><br><span class="line"> 默认排序规则或者指定地区为ru_CN后的排序结果是 </span><br><span class="line"> ..  （ch  (en  @  0124  123  язык  aa  AA  abb  μ  ㊀  一生一世  上  ㊤  爱你  産  艾你  重要  重逢</span><br></pre></td></tr></table></figure><p>至此，我们大致讲清楚了几种排序规则。</p><hr><h2 id="苹果系统的排序"><a href="#苹果系统的排序" class="headerlink" title="苹果系统的排序"></a>苹果系统的排序</h2><p>前面我们已经说了，苹果系统的NSString排序是UCA和CLDR规则的。NSString提供了很多的排序方法，但最终，所有的都是调用了<code>compare:options:range:locale:</code>来进行处理，只是传入的参数不同。可以在<a href="https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/NSString.swift" title="NSString.swift" target="_blank" rel="noopener">NSString.swift</a> 中查看具体的实现。这么多排序方法中，其中之一是<code>localizedStandardCompare:</code>， 这个方法是苹果系统推荐的，在给用户展示的列表数据的名字或者其他字符串进行排序时所使用的方法。我们看到，它的内部实现是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public func localizedStandardCompare(_ string: String) -&gt; ComparisonResult &#123;</span><br><span class="line">    return compare(string, options: [.caseInsensitive, .numeric, .widthInsensitive, .forcedOrdering], range: NSRange(location: 0, length: length), locale: Locale.current._bridgeToObjectiveC())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中用到的四个Options参数是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSCaseInsensitiveSearch  //大小写不敏感</span><br><span class="line">NSNumericSearch //对字符串中出现的数字字符进行数字化的大小比较，比如Foo2.txt &lt; Foo7.txt &lt; Foo25.txt</span><br><span class="line">NSWidthInsensitiveSearch //忽略宽度，按照实际表示的意思来对比，如&apos;a&apos; = UFF41</span><br><span class="line">NSForcedOrderingSearch //强制返回Ascending或者Descending，和NSCaseInsensitiveSearch结合起来就是例如&quot;aaa&quot; &gt; &quot;AAA&quot;</span><br></pre></td></tr></table></figure></p><p>并且指定了当前的区域locale作为参数，这就相当于指定使用CLDR进行排序，如果是在手机上，这个方法的调用和系统当前的区域设置是有很大关系的，这和我们代码中设置locale是一个道理。我们可以这样理解，调用这个方法得到的结果和在iOS Files中文件名选择按照名称排序得到的结果是一样的。在iOS中，当我们的区域设置为中国时，排序顺序就是 <code>标点符号等特殊符号&gt;数字&gt;中文&gt;英文等其他</code>。<br><img src="/images/sort_5.png" alt="区域设置成中文后的排序"><br>自此，对<code>localizedStandardCompare:</code>的使用，大家应该比较清楚了。</p><h3 id="数字的比较"><a href="#数字的比较" class="headerlink" title="数字的比较"></a>数字的比较</h3><p>这里单独把数字字符串的比较列出来，是因为一些人对这里比较迷惑。由于<code>localizedStandardCompare:</code>中有使用<code>NSNumericSearch</code>选项，这里简单来说，就是假如目前两个字符串是相等的，两者都出现了数字，则分别从两者种取出这段数字进行数字化来比较大小，按照数字大小排序。为了验证这里的逻辑，我看了下<a href="https://opensource.apple.com/source/CF/CF-855.11/CFString.chttp://" title="CFString.c" target="_blank" rel="noopener">CFString.c</a>中<code>CFStringCompareWithOptionsAndLocale</code>这个方法的实现，这个就是<code>compare</code>实际调用的的比价方法。其中关于数字大小比较的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">if (numerically &amp;&amp; ((0 == strBuf1Len) &amp;&amp; (str1Char &lt;= &apos;9&apos;) &amp;&amp; (str1Char &gt;= &apos;0&apos;)) &amp;&amp; ((0 == strBuf2Len) &amp;&amp; (str2Char &lt;= &apos;9&apos;) &amp;&amp; (str2Char &gt;= &apos;0&apos;))) &#123; // If both are not ASCII digits, then don&apos;t do numerical comparison here</span><br><span class="line">    uint64_t intValue1 = 0, intValue2 = 0;// !!! Doesn&apos;t work if numbers are &gt; max uint64_t</span><br><span class="line">    CFIndex str1NumRangeIndex = str1Index;</span><br><span class="line">    CFIndex str2NumRangeIndex = str2Index;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        intValue1 = (intValue1 * 10) + (str1Char - &apos;0&apos;);</span><br><span class="line">        str1Char = CFStringGetCharacterFromInlineBuffer(&amp;inlineBuf1, ++str1Index);</span><br><span class="line">    &#125; while ((str1Char &lt;= &apos;9&apos;) &amp;&amp; (str1Char &gt;= &apos;0&apos;));</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        intValue2 = intValue2 * 10 + (str2Char - &apos;0&apos;);</span><br><span class="line">        str2Char = CFStringGetCharacterFromInlineBuffer(&amp;inlineBuf2, ++str2Index);</span><br><span class="line">    &#125; while ((str2Char &lt;= &apos;9&apos;) &amp;&amp; (str2Char &gt;= &apos;0&apos;));</span><br><span class="line"></span><br><span class="line">    if (intValue1 == intValue2) &#123;</span><br><span class="line">        if (forceOrdering &amp;&amp; (kCFCompareEqualTo == compareResult) &amp;&amp; ((str1Index - str1NumRangeIndex) != (str2Index - str2NumRangeIndex))) &#123;</span><br><span class="line">            compareResult = (((str1Index - str1NumRangeIndex) &lt; (str2Index - str2NumRangeIndex)) ? kCFCompareLessThan : kCFCompareGreaterThan);</span><br><span class="line">            numericEquivalence = true;</span><br><span class="line">            forcedIndex1 = str1NumRangeIndex;</span><br><span class="line">            forcedIndex2 = str2NumRangeIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        continue;</span><br><span class="line">    &#125; else if (intValue1 &lt; intValue2) &#123;</span><br><span class="line">        if (freeLocale &amp;&amp; locale) &#123;</span><br><span class="line">            CFRelease(locale);</span><br><span class="line">        &#125;</span><br><span class="line">            return kCFCompareLessThan;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (freeLocale &amp;&amp; locale) &#123;</span><br><span class="line">                CFRelease(locale);</span><br><span class="line">            &#125;</span><br><span class="line">        return kCFCompareGreaterThan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码的含义就是，如果两个字符串都是以数字开始（也可能是字符串前面都相等，当前从数字部分开始比较），则取出两个字符串的数字，按照数字大小进行对比。如果数字能够比较出大小，则直接返回两个字符串的大小关系，不再对后面的字符串进行对比。比如“0123aaa” 和“1bbbbbbbbb”，就直接返回“0123aaa”大于“1bbbbbbbbb”。当然，这里取出的数字可能超出了uint64_t表示的最大值，但是这种概率很低，在我们的名称排序中，很难遇到这么长的数字进行比较的。明白这个规则后，大家对字符串中出现的数字在进行排序时应该比较理解了。下面的名字排序是对着的。<br><img src="/images/sort_6.png" alt=""></p><hr><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>本文主要讲述由<code>localizedStandardCompare:</code>这个苹果系统方法所引发的对排序规则的深入研究，简单来说，设置中选择区域为中国时，排序顺序为 <code>标点符号等特殊符号&gt;数字&gt;中文&gt;英文等其他</code>。中文本身是按照pinyin排序的，只是由于多音字的关系，不能够做到100%按照中文习惯来排序，会有些无法正确排序的问题，但大体已经符合我们的习惯了。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Unicode</a><br><a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFStrings/Articles/UnicodeBasis.html" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFStrings/Articles/UnicodeBasis.html</a><br><a href="https://www.objc.io/issues/9-strings/unicode/" target="_blank" rel="noopener">https://www.objc.io/issues/9-strings/unicode/</a><br><a href="http://unicode.org/reports/tr10/" target="_blank" rel="noopener">http://unicode.org/reports/tr10/</a><br><a href="https://www.cnblogs.com/huahuahu/p/Unicode-zi-fu-chuan-pai-xu-gui-ze-yi-ru-he-que-din.html" target="_blank" rel="noopener">https://www.cnblogs.com/huahuahu/p/Unicode-zi-fu-chuan-pai-xu-gui-ze-yi-ru-he-que-din.html</a><br><a href="https://raw.githubusercontent.com/larvit/larvitgeodata/master/cldrData/common/uca/allkeys_CLDR.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/larvit/larvitgeodata/master/cldrData/common/uca/allkeys_CLDR.txt</a><br><a href="http://cldr.unicode.org/" target="_blank" rel="noopener">http://cldr.unicode.org/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Unicode编码&quot;&gt;&lt;a href=&quot;#Unicode编码&quot; class=&quot;headerlink&quot; title=&quot;Unicode编码&quot;&gt;&lt;/a&gt;Unicode编码&lt;/h2&gt;&lt;p&gt;我们知道计算机是不能直接处理文本的，而是和数字打交道。因此，为了表示文本，就建立了一
      
    
    </summary>
    
    
      <category term="iOS,排序,Unicode,UCA,CLDR" scheme="https://iweiyun.github.io/tags/iOS-%E6%8E%92%E5%BA%8F-Unicode-UCA-CLDR/"/>
    
  </entry>
  
  <entry>
    <title>有趣的python</title>
    <link href="https://iweiyun.github.io/2018/11/12/python-interesting/"/>
    <id>https://iweiyun.github.io/2018/11/12/python-interesting/</id>
    <published>2018-11-12T14:40:37.000Z</published>
    <updated>2018-11-14T12:27:01.225Z</updated>
    
    <content type="html"><![CDATA[<p>python是一门有趣的语言，有些特性在其它语言基本没有。比如代码格式会影响到代码，成员变量的权限是根据名称来决定，类型是全小写等。</p><p>但又有很多内容与其它语言相似。比如Generator、async/await，和JS里的相应概念很是相似，类的动态性也不少与js差不多。python类的一些高级特性，也有一些能在OC里找到影子。</p><p>python有些写法感觉会比较繁琐，如 &amp;&amp;，明明两个字符就能表示的，但python非要用<code>and</code>这样的单词。</p><p>但python又有些写法表达力很强，如lst[1:3]，即可取出子列表，以及列表生成式的表达能力，与haskell里的List Comprehension差不多了。</p><p>下面就列出python里一些有趣的点</p><p>​    </p><hr><h4 id="极强表达力的列表生成式"><a href="#极强表达力的列表生成式" class="headerlink" title="极强表达力的列表生成式"></a>极强表达力的列表生成式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">print(r)<span class="comment"># 输出：[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span></span><br></pre></td></tr></table></figure><blockquote><p><em>在Haskell中称为<a href="https://wiki.haskell.org/List_comprehension" target="_blank" rel="noopener">List comprehension</a>的，写法与其类似：</em></p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x*x | x &lt;- [<span class="number">1.</span><span class="number">.10</span>]]</span><br></pre></td></tr></table></figure><hr><h4 id="类型是小写的"><a href="#类型是小写的" class="headerlink" title="类型是小写的"></a>类型是小写的</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str即是表示字符串类型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myFunc</span><span class="params">(s: str)</span>:</span></span><br><span class="line">    <span class="comment"># some code</span></span><br></pre></td></tr></table></figure><blockquote><p><em>参数类型是可选的，一般不需要加</em></p></blockquote><hr><h4 id="变量不需要指定类型，而且在运行时可以修改类型"><a href="#变量不需要指定类型，而且在运行时可以修改类型" class="headerlink" title="变量不需要指定类型，而且在运行时可以修改类型"></a>变量不需要指定类型，而且在运行时可以修改类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v = <span class="number">1</span></span><br><span class="line">v = <span class="string">"2"</span></span><br></pre></td></tr></table></figure><hr><h4 id="与、或操作符，是用and、or来表示的"><a href="#与、或操作符，是用and、or来表示的" class="headerlink" title="与、或操作符，是用and、or来表示的"></a>与、或操作符，是用and、or来表示的</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b1 = <span class="keyword">True</span></span><br><span class="line">b2 = <span class="keyword">False</span></span><br><span class="line">o1 = b1 <span class="keyword">and</span> b2<span class="comment"># False</span></span><br><span class="line">o2 = b1 <span class="keyword">or</span> b2<span class="comment"># True</span></span><br></pre></td></tr></table></figure><hr><h4 id="列表可以从后面来访问"><a href="#列表可以从后面来访问" class="headerlink" title="列表可以从后面来访问"></a>列表可以从后面来访问</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(lst[<span class="number">-1</span>])<span class="comment"># 输出3, 也要注意不能越界</span></span><br></pre></td></tr></table></figure><blockquote><p>lst[0:2], 这样来写就可以取出[1, 2]</p></blockquote><hr><h4 id="可以执行字符串"><a href="#可以执行字符串" class="headerlink" title="可以执行字符串"></a>可以执行字符串</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec(<span class="string">"print('Hello World')"</span>)<span class="comment"># 输出：Hello World</span></span><br></pre></td></tr></table></figure><blockquote><p><em>类似js中的 <code>eval</code></em>  </p></blockquote><hr><h4 id="支持lambda表达式"><a href="#支持lambda表达式" class="headerlink" title="支持lambda表达式"></a>支持lambda表达式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> r, v : r + v</span><br></pre></td></tr></table></figure><hr><h4 id="元组定义时可以不用括号"><a href="#元组定义时可以不用括号" class="headerlink" title="元组定义时可以不用括号"></a>元组定义时可以不用括号</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tuple = <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span></span><br><span class="line">print(tuple[<span class="number">1</span>])<span class="comment"># 输出：b</span></span><br></pre></td></tr></table></figure><blockquote><p><em>元组其实就是不可变的列表</em></p></blockquote><hr><h4 id="简单的交换变量的方式"><a href="#简单的交换变量的方式" class="headerlink" title="简单的交换变量的方式"></a>简单的交换变量的方式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x</span><br></pre></td></tr></table></figure><blockquote><p><em>类似swift的写法，本质都是利用元组来交换：</em></p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x, y) = (y, x)</span><br></pre></td></tr></table></figure><hr><h4 id="for-else结构"><a href="#for-else结构" class="headerlink" title="for-else结构"></a>for-else结构</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">19</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"找到了偶数"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"没有找到偶数"</span>)<span class="comment"># 输出：没有找到偶数</span></span><br></pre></td></tr></table></figure><hr><h4 id="类的方法，定义时需要显示指定self"><a href="#类的方法，定义时需要显示指定self" class="headerlink" title="类的方法，定义时需要显示指定self"></a>类的方法，定义时需要显示指定self</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.set_score(<span class="number">85</span>)<span class="comment"># 调用时不需要指定</span></span><br></pre></td></tr></table></figure><blockquote><p> <em>在其它语言里面基本都是编译器自动帮指定，不需要显示的写出来的。</em></p></blockquote><hr><h4 id="成员变量要在-init-里面指定，在方法外定义的是类属性"><a href="#成员变量要在-init-里面指定，在方法外定义的是类属性" class="headerlink" title="成员变量要在__init__里面指定，在方法外定义的是类属性"></a>成员变量要在__init__里面指定，在方法外定义的是类属性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">        Student.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">m = Student(<span class="string">"Matthew"</span>, <span class="number">80</span>)</span><br><span class="line">print(Student.count)<span class="comment"># 1</span></span><br><span class="line">print(m.name)<span class="comment"># Matthew</span></span><br></pre></td></tr></table></figure><hr><h4 id="私有变量通过名字来限定"><a href="#私有变量通过名字来限定" class="headerlink" title="私有变量通过名字来限定"></a>私有变量通过名字来限定</h4><p>通过在名字前加双下划线，来表示是私有变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">"Matthew"</span>, <span class="number">60</span>)</span><br><span class="line">print(s.__name)<span class="comment"># 'Student' object has no attribute '__name'</span></span><br></pre></td></tr></table></figure><hr><h4 id="类可以动态的增、删成员变量"><a href="#类可以动态的增、删成员变量" class="headerlink" title="类可以动态的增、删成员变量"></a>类可以动态的增、删成员变量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">o = Student()</span><br><span class="line">o.name = <span class="string">"Matthew"</span></span><br><span class="line">print(o.name)<span class="comment"># 输出: Matthew</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> o.name</span><br><span class="line">print(o.name)<span class="comment"># 'Student' object has no attribute 'name'</span></span><br></pre></td></tr></table></figure><blockquote><p><em>js也有这个能力</em></p></blockquote><hr><h4 id="调用不存在的属性，可以被开发者接管"><a href="#调用不存在的属性，可以被开发者接管" class="headerlink" title="调用不存在的属性，可以被开发者接管"></a>调用不存在的属性，可以被开发者接管</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">'name'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Good"</span></span><br><span class="line"></span><br><span class="line">o = Student()</span><br><span class="line">print(o.name)<span class="comment"># 输出：Good</span></span><br></pre></td></tr></table></figure><blockquote><p><em>跟OC的转发找不到的方法非常像。包括  <code>__str__</code> 方法，也非常类似OC中的 <code>description</code> ，来实现自定义打印内容</em></p></blockquote><hr><h4 id="可以通过代码来设置断点"><a href="#可以通过代码来设置断点" class="headerlink" title="可以通过代码来设置断点"></a>可以通过代码来设置断点</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdb.set_trace()</span><br></pre></td></tr></table></figure><blockquote><p><em>类似js的 <code>debugger</code> 语句</em></p></blockquote><hr><p>​    </p><p><strong>参考资料</strong></p><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰的官方网站</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python是一门有趣的语言，有些特性在其它语言基本没有。比如代码格式会影响到代码，成员变量的权限是根据名称来决定，类型是全小写等。&lt;/p&gt;
&lt;p&gt;但又有很多内容与其它语言相似。比如Generator、async/await，和JS里的相应概念很是相似，类的动态性也不少与j
      
    
    </summary>
    
    
      <category term="python" scheme="https://iweiyun.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>你可能不知道的Swift</title>
    <link href="https://iweiyun.github.io/2018/11/06/swift-interesting/"/>
    <id>https://iweiyun.github.io/2018/11/06/swift-interesting/</id>
    <published>2018-11-06T14:49:17.000Z</published>
    <updated>2018-11-19T13:30:43.204Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><hr><p>​    </p><h3 id="自定义运算符不仅限于Ascii符号"><a href="#自定义运算符不仅限于Ascii符号" class="headerlink" title="自定义运算符不仅限于Ascii符号"></a>自定义运算符不仅限于Ascii符号</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ❤ : <span class="type">MultiplicationPrecedence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> ❤<span class="params">(lhs: Int, rhs: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> lhs + rhs &#125;</span><br><span class="line">r = <span class="number">1</span> ❤ <span class="number">5</span><span class="comment">// 结果是6</span></span><br></pre></td></tr></table></figure><p>除了❤，类似☢、☂、☯等都可以用，而且这些符号都是可以组合起来的</p><p>​    </p><hr><p>​    </p><h3 id="空集合，是无法判断出有效类型的"><a href="#空集合，是无法判断出有效类型的" class="headerlink" title="空集合，是无法判断出有效类型的"></a>空集合，是无法判断出有效类型的</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="type">Int</span>]()</span><br><span class="line"><span class="keyword">if</span> arr <span class="keyword">is</span> [<span class="type">String</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Match!!"</span>)<span class="comment">// 会输出Match!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="可变参数，在函数内部就是数组"><a href="#可变参数，在函数内部就是数组" class="headerlink" title="可变参数，在函数内部就是数组"></a>可变参数，在函数内部就是数组</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(params: String...)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> t = type(of: params)</span><br><span class="line">    <span class="built_in">print</span>(t)<span class="comment">// 输出：Array&lt;String&gt;</span></span><br><span class="line">    <span class="built_in">print</span>(params)<span class="comment">// 输出：["1", "2"]</span></span><br><span class="line">&#125;</span><br><span class="line">test(params: <span class="string">"1"</span>, <span class="string">"2"</span>)</span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="Optional类型，也是有map方法的"><a href="#Optional类型，也是有map方法的" class="headerlink" title="Optional类型，也是有map方法的"></a>Optional类型，也是有map方法的</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i: <span class="type">Int</span>? = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> r = i.<span class="built_in">map</span> &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(r)<span class="comment">// Optional(11)</span></span><br></pre></td></tr></table></figure><p>有些场景下可以极大简化代码</p><p>​    </p><hr><p>​    </p><h3 id="闭包仅能推断出单表达式的返回值"><a href="#闭包仅能推断出单表达式的返回值" class="headerlink" title="闭包仅能推断出单表达式的返回值"></a>闭包仅能推断出单表达式的返回值</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">map</span> &#123; item <span class="keyword">in</span><span class="comment">// Error: Unable to infer complex closure return type</span></span><br><span class="line"><span class="keyword">let</span> r = item * item</span><br><span class="line"><span class="keyword">return</span> r + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有改成如下形式才能编译通过</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">map</span> &#123; item <span class="keyword">in</span><span class="comment">// Error: Unable to infer complex closure return type</span></span><br><span class="line">item * item + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单表达式时，return关键字也可以省略</p><p>​    </p><hr><p>​    </p><h3 id="print是有更多参数可用的"><a href="#print是有更多参数可用的" class="headerlink" title="print是有更多参数可用的"></a>print是有更多参数可用的</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello"</span>, <span class="string">"World"</span>, separator: <span class="string">" "</span>)<span class="comment">// 输出Hello World，中间用空格分割</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两句输出： HelloWorld，不会换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hello"</span> terminator: <span class="string">""</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"World"</span>)</span><br></pre></td></tr></table></figure><p>除此之外还有debugPrint，可能会输出更详细的信息</p><p>​    </p><hr><p>​    </p><h3 id="可以很方便判断值是否在区间内"><a href="#可以很方便判断值是否在区间内" class="headerlink" title="~= 可以很方便判断值是否在区间内"></a>~= 可以很方便判断值是否在区间内</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="number">1</span>...<span class="number">5</span> ~= <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(r)<span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="switch判断，可以更强大"><a href="#switch判断，可以更强大" class="headerlink" title="switch判断，可以更强大"></a>switch判断，可以更强大</h3><p>case后面跟可以不同类型，但需要重载 ~= 运算符</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name : <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> ~=<span class="params">(pattern: String, value: Person)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value.name == pattern</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="type">Person</span>(name: <span class="string">"Alessandro"</span>)</span><br><span class="line"><span class="keyword">switch</span> person &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"Alessandro"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hey it's me!"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Not me"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="空元组，可以在不关心类型及数据时使用"><a href="#空元组，可以在不关心类型及数据时使用" class="headerlink" title="空元组，可以在不关心类型及数据时使用"></a>空元组，可以在不关心类型及数据时使用</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">emptyTuple</span><span class="params">(<span class="number">_</span>: <span class="params">()</span></span></span>) &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line">emptyTuple(())<span class="comment">// 调用时也需要传入空元组</span></span><br></pre></td></tr></table></figure><p>在Rx中，是有大量这样的使用，比如事件通知，不需要传数据，只要触发一下的情况，可能会用()<br>​<br>Swift中，Void也是用的空元组来定义的</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Void</span> = ()</span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="一起遍历两个Sequence时，可以用zip"><a href="#一起遍历两个Sequence时，可以用zip" class="headerlink" title="一起遍历两个Sequence时，可以用zip"></a>一起遍历两个Sequence时，可以用zip</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lst1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> lst2 = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]</span><br><span class="line"><span class="keyword">for</span> (a, b) <span class="keyword">in</span> <span class="built_in">zip</span>(lst1, lst2) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(a)</span><span class="subst">\(b)</span>"</span>)<span class="comment">// 输出1a 2b 3c，以短的列表为准</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="元组是可以定义标签的"><a href="#元组是可以定义标签的" class="headerlink" title="元组是可以定义标签的"></a>元组是可以定义标签的</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tuple: (first: <span class="type">Int</span>, second: <span class="type">String</span>, third: <span class="type">String</span>?) = (<span class="number">0</span>, <span class="string">""</span>, <span class="literal">nil</span>)</span><br><span class="line">tuple.first = <span class="number">1</span></span><br><span class="line">tuple.second = <span class="string">"hello"</span></span><br><span class="line">tuple.third = <span class="string">"world"</span></span><br><span class="line"><span class="built_in">print</span>(tuple.first)<span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="全局变量默认就是lazy的"><a href="#全局变量默认就是lazy的" class="headerlink" title="全局变量默认就是lazy的"></a>全局变量默认就是lazy的</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">globalFunc</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> globalVar = globalFunc()<span class="comment">// 只有globalVar被使用时，globalFunc才会被调用</span></span><br></pre></td></tr></table></figure><p>苹果源码仓库里有相应的测试代码，可以详细看到什么情况下会是懒加载：<a href="https://github.com/apple/swift/blob/master/test/decl/var/lazy_properties.swift" target="_blank" rel="noopener">lazy_properties.swift</a></p><p>​    </p><hr><p>​    </p><h3 id="precondition，比assert更严格的检查"><a href="#precondition，比assert更严格的检查" class="headerlink" title="precondition，比assert更严格的检查"></a>precondition，比assert更严格的检查</h3><p>用法上与assert类似，但更严格，只有-Ounchecked选项才能关闭，但这样会很危险</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">precondition</span>(x &gt;= <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="struct在没有自定义init时，系统会帮我们生成"><a href="#struct在没有自定义init时，系统会帮我们生成" class="headerlink" title="struct在没有自定义init时，系统会帮我们生成"></a>struct在没有自定义init时，系统会帮我们生成</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MySize</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="type">MySize</span>(width: <span class="number">1</span>, height: <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="type">MySize</span>()<span class="comment">// 如果上面没有指定默认值，则不会生成这个初始化方法</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="compactMap可以从列表中筛选出指定类型"><a href="#compactMap可以从列表中筛选出指定类型" class="headerlink" title="compactMap可以从列表中筛选出指定类型"></a>compactMap可以从列表中筛选出指定类型</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrs: [<span class="type">Any</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> r = arrs.compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">String</span> &#125;<span class="comment">// r已经被推断为[String]类型</span></span><br><span class="line"><span class="built_in">print</span>(r)<span class="comment">// 输出：["3", "4"]</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="从Dictionary获取值时，可以提供默认值"><a href="#从Dictionary获取值时，可以提供默认值" class="headerlink" title="从Dictionary获取值时，可以提供默认值"></a>从Dictionary获取值时，可以提供默认值</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dict = [<span class="string">"1"</span>: <span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> o = dict[<span class="string">"2"</span>, <span class="keyword">default</span>: <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(o)<span class="comment">// 输出：2</span></span><br></pre></td></tr></table></figure><p>​    </p><hr><p>​    </p><h3 id="运算符也是方法"><a href="#运算符也是方法" class="headerlink" title="运算符也是方法"></a>运算符也是方法</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = (+)(<span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(r)<span class="comment">// 输出：11</span></span><br></pre></td></tr></table></figure><p>​    </p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;​    &lt;/p&gt;
&lt;h3 id=&quot;自定义运算符不仅限于Ascii符号&quot;&gt;&lt;a href=&quot;#自定义运算符不仅限于Ascii符号&quot; class=&quot;headerlink&quot; title=&quot;自定义运算符不仅限于Ascii符号&quot;&gt;&lt;/a&gt;自定义运
      
    
    </summary>
    
    
      <category term="swift" scheme="https://iweiyun.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>RxCocoa简单源码分析</title>
    <link href="https://iweiyun.github.io/2018/11/01/rxcocoa-code/"/>
    <id>https://iweiyun.github.io/2018/11/01/rxcocoa-code/</id>
    <published>2018-11-01T13:38:28.000Z</published>
    <updated>2018-11-02T02:13:59.414Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>RxCocoa是<a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>的一部分，主要是UI相关的Rx封装。比如实现了很多组件的绑定功能，简化处理逻辑。也可以监听delegate改变，无须把控件创建及delegate处理分开写等。</p><p>RxCocoa里面也定义了很多类，专门为UI处理提供的，比如<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/control_property.html" target="_blank" rel="noopener">ControlProperty</a>、<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable/control_event.html" target="_blank" rel="noopener">ControlEvent</a>、<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable/driver.html" target="_blank" rel="noopener">Driver</a>、<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observer/binder.html" target="_blank" rel="noopener">Binder</a>等。RxCocoa可以用好的话，可以极大简化UI相关处理逻辑。但是，要想随心所欲的使用，还是要对其实现要有一定的了解，否则就容易写出不是那么简洁的代码。</p><p>比如前几天在一篇博客上，看到的一段代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">textfield.rx.text</span><br><span class="line">    .asObservable()</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>这段代码一眼看过去，是没什么问题的，执行起来看起来也是ok的。</p><p>但是，这段代码的问题就是存在冗余。具体为什么冗余，稍后再分析。先从简单的示例了解RxCocoa</p><p>​    </p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>的源码里面有附带示例代码，源码clone下来之后，打开Rx.xcworkspace，即可以选择示例运行看效果。</p><p>现在就拿最简单的Numbers例子看下，(也可以在线看下这个最简单示例代码：<a href="https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Examples/Numbers/NumbersViewController.swift" target="_blank" rel="noopener">Numbers</a>）</p><p>核心代码就这一段：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Observable</span>.combineLatest(number1.rx.text.orEmpty, number2.rx.text.orEmpty, number3.rx.text.orEmpty) &#123; textValue1, textValue2, textValue3 -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">Int</span>(textValue1) ?? <span class="number">0</span>) + (<span class="type">Int</span>(textValue2) ?? <span class="number">0</span>) + (<span class="type">Int</span>(textValue3) ?? <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span>.description &#125;</span><br><span class="line">    .bind(to: result.rx.text)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>这个示例是将三个输入框的内容加起来，绑定在Label上，上面值变化之后，下面的Label立即跟着变化。</p><p>为了让例子更简单，我们可以只把label的值绑定在第一个输入框上：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">number1.rx.text.orEmpty</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span>.description &#125;</span><br><span class="line">    .bind(to: result.rx.text)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>现在我们逐个分析下，这里面的 rx、text、orEmpty、bind到底是什么</p><p>​    </p><h3 id="rx"><a href="#rx" class="headerlink" title="rx"></a>rx</h3><p>number1.rx是表示什么呢？我们根据源码来推导一下</p><p>先看下rx属性的源码实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> rx: <span class="type">Reactive</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Reactive</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        <span class="comment">// this enables using Reactive to "mutate" base object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上是创建了一个Reactive对象，所以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number1.rx  ===&gt;  Reactive(number1)</span><br></pre></td></tr></table></figure><p>Reactive源码又如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Reactive</span>&lt;<span class="title">Base</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/// Base object to extend.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> base: <span class="type">Base</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Creates extensions with base object.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - parameter base: Base object.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> base: <span class="type">Base</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.base = base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以number1.rx最终会变成如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Reactive</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> base: <span class="type">UITextField</span><span class="comment">// 指向number1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以number1.rx是变成了<strong>Reactive结构体</strong>，此时，Reactive的扩展方法，我们就可以使用了。</p><p>所以，这个.rx是进入Rx世界的入口，控件调用.rx属性之后，后面的内容就表示进入了Rx的世界了。</p><p>​    </p><h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><p>上面分析了，number1.rx是一个Reactive的结构体，它后面就可以继续调用Reactive及其扩展的属性和方法了。</p><p>（实际上number1.rx只能调用不限定的扩展的方法或者限定Base是UITextField类型的扩展方法）</p><p>所以，text属性就是Reactive的扩展的属性。这个属性定义在UITextField+Rx.swift文件中，下面是其简化后的实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UITextField</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> text: <span class="type">ControlProperty</span>&lt;<span class="type">String</span>?&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">ControlProperty</span>&lt;<span class="type">String</span>?&gt; &#123;</span><br><span class="line">        <span class="comment">// 默认事件支持了allEditingEvents、valueChanged</span></span><br><span class="line">        <span class="keyword">return</span> base.rx.controlPropertyWithDefaultEvents(</span><br><span class="line">            getter: &#123; textField <span class="keyword">in</span><span class="comment">// 要发出事件时，所需的数据，即是从这儿获取</span></span><br><span class="line">                textField.text</span><br><span class="line">        &#125;,</span><br><span class="line">            setter: &#123; textField, value <span class="keyword">in</span><span class="comment">// 作为监听者时，收到数据时会调到这儿</span></span><br><span class="line">                <span class="keyword">if</span> textField.text != value &#123;</span><br><span class="line">                    textField.text = value</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>text简单的调用了value属性，它们是ControlProperty类型的。</p><p>ControlProperty是表示控件属性，即能监听变化，又能发出通知，即同时实现了ObservableType和ObserverType协议，所以控件才能支持<strong>双向绑定</strong>。</p><p>上面代码中的getter块是在作为ObservableType时所使用的，setter块是作为ObserverType所需要的。</p><p>具体ControlProperty实现就不展开了，可以在UIControl+Rx.swift查看具体实现。</p><p>​    </p><h3 id="orEmpty"><a href="#orEmpty" class="headerlink" title="orEmpty"></a>orEmpty</h3><p>上面代码中的一个细节：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> text: <span class="type">ControlProperty</span>&lt;<span class="type">String</span>?&gt;</span><br></pre></td></tr></table></figure><p>这个value值传出来之后是String?的，是个可选值。在很多情况下，并不想要可选值，只希望如果为nil时，传””空字符串出来即可。否则可选值出来之后，外面可能处理为nil的情况处理起来会比较繁琐。</p><p> orEmpty就是这个作用。</p><p>orEmpty的实现如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> orEmpty: <span class="type">ControlProperty</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> original: <span class="type">ControlProperty</span>&lt;<span class="type">String</span>?&gt; = <span class="keyword">self</span>.asControlProperty()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> values: <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; = original._values.<span class="built_in">map</span> &#123; $<span class="number">0</span> ?? <span class="string">""</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> valueSink: <span class="type">AnyObserver</span>&lt;<span class="type">String</span>&gt; = original._valueSink.mapObserver &#123; $<span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ControlProperty</span>&lt;<span class="type">String</span>&gt;(values: values, valueSink: valueSink)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>会根据目前的values构造一个新的values，并最终构造一个新的ControlProperty，去除可选值的情况。</p><p>​    </p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind即是用来将一个信号发送者和一个信号监听者绑定在一起，即有信号发送，监听者自动收到通知。听起来是跟subscribe做的事情比较类似。</p><p>bind(to:)有几个不同的实现，最简单的实现版本如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">bind</span>&lt;O: ObserverType&gt;<span class="params">(to observer: O)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> == <span class="type">E</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.subscribe(observer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是订阅的封装。可以理解为为subscribe起了一个在绑定场景下比较容易理解的名字。</p><p>在很多情况下，我们的observer并不需要处理error、complete事件，并且处理逻辑需要在主线程中执行。所以RxCocoa帮我们封装好了一个叫Binder的对象，我们使用这个对象时，不需要考虑太多。</p><p>RxCocoa提供的一些监听属性，比如UILabel的rx.text属性即是Binder类型的:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UILabel</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> text: <span class="type">Binder</span>&lt;<span class="type">String</span>?&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Binder</span>(<span class="keyword">self</span>.base) &#123; label, text <span class="keyword">in</span></span><br><span class="line">            label.text = text<span class="comment">// 收到事件就会调用到这儿</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>这样这个简单示例就串起来了，并且能够很明确每次调用在做什么事情。</p><p>现在再看最开始的那段代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">textfield.rx.text</span><br><span class="line">    .asObservable()</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>我们知道textfield.rx.text是ControlProperty的类型，并且这个类型本身就实现了Observable协议的，那么冗余的代码就很明确了，即asObservable()这一次调用是没意义的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;RxCocoa是&lt;a href=&quot;https://github.com/ReactiveX/RxSwift&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="rxswift,rxcocoa,bind,ios,swift" scheme="https://iweiyun.github.io/tags/rxswift-rxcocoa-bind-ios-swift/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s New in LLVM（WWDC2018）</title>
    <link href="https://iweiyun.github.io/2018/10/16/What-New-in%20LLVM-WWDC2018/"/>
    <id>https://iweiyun.github.io/2018/10/16/What-New-in LLVM-WWDC2018/</id>
    <published>2018-10-16T14:30:08.000Z</published>
    <updated>2018-11-16T12:43:06.727Z</updated>
    
    <content type="html"><![CDATA[<p>在WWDC上，LLVM这个Section，基本是年年都有，前年写了篇文章介绍了下，今年继续吧。<br>本来想着今年有官方的中文字幕了，可喜可贺、可喜可贺，然而却是下面这样的情况：<br><img src="/images/1539259407_77.png" alt=""><br><img src="/images/1539259445_13.png" alt=""><br><img src="/images/1539260984_70.png" alt="黑人问号"></p><p>看到这里我还是默默的切回了英文字母，这里就当给大家翻译翻译这篇Section。</p><h3 id="一、C结构体中OC对象的ARC支持"><a href="#一、C结构体中OC对象的ARC支持" class="headerlink" title="一、C结构体中OC对象的ARC支持"></a>一、C结构体中OC对象的ARC支持</h3><p>Xcode10之前大家应该都知道ARC下struct里是不能放OC对象的，Xcode10中解除了这一限制，并且对于在栈上的这种结构体，可以做到完全自动的管理内存：<br><img src="/images/1539263611_74.png" alt="栈上"><br><img src="/images/1539263691_74.png" alt="默认值和数组"><br>对于堆上的结构体则有一些不同，首先要用新加入的calloc代替malloc来申请内存，最后free掉之前要先置nil。<br><img src="/images/1539264271_32.png" alt="堆上"></p><p>这里有几个问题：</p><ul><li>首先是calloc完了之后要强转才能赋值，否则编译会报错（骗子啊，他ppt里是没有强转的）。我理解这个calloc的不同之处就是会把申请的内存都置0。</li><li>第二个是struct定义中的默认值，在这种情况下是失效的，上图中可以看到我把第四个元素也置空了，但是并没有多出一个dealloc，说明他本来就是个nil。</li><li>最后就是free掉之前要把所有struct里的OC字段都显式的置为nil，例子里第二个元素没有置空，所以最后的dealloc少了一个。</li></ul><p>这种情况下感觉是个半成品，跟手动管理内存也没啥区别了，不过大部分情况下，我们也只需要用到栈上的结构体。</p><h3 id="二、更强的代码诊断"><a href="#二、更强的代码诊断" class="headerlink" title="二、更强的代码诊断"></a>二、更强的代码诊断</h3><p>这个部分大概也是年年讲的了，这里就挑两个讲讲：</p><h4 id="OC中的NS-NOESCAPE"><a href="#OC中的NS-NOESCAPE" class="headerlink" title="OC中的NS_NOESCAPE"></a>OC中的NS_NOESCAPE</h4><p>swift里闭包做参数，有escaping和non-escaping的区别。但是接口桥接给OC了之后，在OC中是没有办法知道是不是有escaping的。然后苹果就在OC里也加了一个NS_NOESCAPE的标识符，并且也引入了相关的警告。<br><img src="/images/1539313163_77.png" alt=""><br><img src="/images/1539313204_74.png" alt=""></p><h4 id="Autorelease-Pool外使用Autoreleasing的变量"><a href="#Autorelease-Pool外使用Autoreleasing的变量" class="headerlink" title="Autorelease Pool外使用Autoreleasing的变量"></a>Autorelease Pool外使用Autoreleasing的变量</h4><p>直接来看一个比较隐蔽的错误，下面的代码为什么会Crash呢？<br><img src="/images/1539313946_53.png" alt=""><br>有两个关键因素导致了这个crash，并且大部分人都很难在看代码的时候意识到。</p><ol><li>函数中的输出参数，默认是用__autoreleasing修饰的，即使你不写。</li><li>enumerateXXX这一系列的容器接口，里面的实现是包了一层Autorelease Pool的。</li></ol><p>这就导致了someObj在函数返回之前就已经dealloc了，后面再使用就会导致Use After Free的crash。从控制台的输出也可以看出来，dealloc是在after call之前输出的。<br><img src="/images/1539314934_1.png" alt=""><br>即使是这种比较隐蔽的情况，Xcode10中，静态分析也能指出这种错误了。</p><h3 id="三、安全性提升"><a href="#三、安全性提升" class="headerlink" title="三、安全性提升"></a>三、安全性提升</h3><p> 这个部分在Section中占了比较大的篇幅，不过主要也就讲了两个东西，都是关于防止栈上的写溢出导致的安全性问题，关于栈的基础知识讲解倒是挺多的……</p><h4 id="Stack-Protector"><a href="#Stack-Protector" class="headerlink" title="Stack Protector"></a>Stack Protector</h4><p>先贴一张函数调用栈的结构图，每一个栈桢对应一个函数调用的记录，存储着当前函数要用到的临时变量（栈变量）以及调用完成后要返回到哪里（返回地址）继续执行。<br><img src="/images/1539532681_73.png" alt=""><br>这里还涉及到一种很常见的攻击方法，栈溢出攻击。例如下面这个函数中使用的strcpy函数，它拷贝字符串时并不会判断原串的长度是否超过了目标buffer的长度。攻击者可以恶意的构造一个输入，来覆写当前函数的返回地址，达到控制程序执行流程的目的（跳过一些验证函数等）。<br><img src="/images/1539533246_91.png" alt=""><br>虽然现在使用这些函数会出警告，让你使用它们的安全版本（如strncpy），但是难免会有疏忽的时候。<br>新的编译器加入了Stack Protector这个特性来帮助我们防止这种攻击，原理如下图：<br><img src="/images/1539533945_77.png" alt=""><br><img src="/images/1539533957_92.png" alt=""><br>简单来说就就是在返回地址和栈变量中间加了一小段间隙，这里面会填充一些用于校验的数据，并且自动在函数return之前加入一段检测代码，检测间隙中的数据是否被修改了，如果检测失败，就会强制终止程序。</p><p>这个例子中，如果从栈变量的范围溢出去写返回地址，一定会修改到这块保护区。推测保护区的大小和内容都是会发生变化的，这样攻击者也没法构造一个使保护区不变的输入。</p><p>苹果说这个功能是默认打开的，然而我用他的示例代码并没有出现abort的情况，看反汇编也没有发现有相关的插入的代码在里面。</p><h4 id="Stack-Checking"><a href="#Stack-Checking" class="headerlink" title="Stack Checking"></a>Stack Checking</h4><p>这种保护措施是针对下面这种栈帧的大小也是由输入来控制的函数的。<br><img src="/images/1539535234_63.png" alt=""><br>一种情况是，攻击者传入一个非常大的len，导致这个栈帧的范围与堆的范围有重叠的部分，这样就相当于可以改写任意的堆上的对象了。</p><p>这里有一个前提就是，苹果的系统上，是允许申请一个像这样超大的栈上buffer的，甚至超出物理内存的大小也是可以的。因为系统只会在实际有读写操作时，才会给这段虚拟内存分配一个物理内存上的页，也就是说除了有操作的那一小块虚拟内存，它前后的大段虚拟内存都是不占用物理内存的。<br><img src="/images/1539535965_94.png" alt=""><br>保护的方法也是类似的，在函数入口来检测栈帧的地址范围与堆是否有重叠，是的话也abort掉。<br><img src="/images/1539536569_76.png" alt=""><br>Debug下看反汇编，发现确实有相关的检测代码存在。</p><h3 id="四、新的扩展指令集"><a href="#四、新的扩展指令集" class="headerlink" title="四、新的扩展指令集"></a>四、新的扩展指令集</h3><p>由于没有这些新的设备，就没法实操了，直接上表格吧。<br><img src="/images/1539536873_18.png" alt=""><br>可以看到，移动和桌面平台上，都有SIMD相关的升级。</p><p>桌面端是支持了Intel六代U上增加的AVX512，寄存器宽了一倍，数量也多了一倍，达到32个512bit。</p><p>移动端则是在NEON指令集上增加了半精度浮点的支持，这样在位宽不变的情况下能多放一倍的数据进行并行操作，算是个小更新。据说主要是对机器学习有加成，因为机器学习需要的精度不高。</p><p>最后就是ARM v8.1中增加了原子操作相关的指令，在此之前ARM上的原子操作都是通过Load-link/store-conditional的方式实现的，虽然也是Lock Free的，但是通常需要四条指令。这会加速iOS上APP里用到的原子操作，我自己写项目的时候有时候也会用到，不过总感觉在移动端上，这个东西应该不会造成性能瓶颈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在WWDC上，LLVM这个Section，基本是年年都有，前年写了篇文章介绍了下，今年继续吧。&lt;br&gt;本来想着今年有官方的中文字幕了，可喜可贺、可喜可贺，然而却是下面这样的情况：&lt;br&gt;&lt;img src=&quot;/images/1539259407_77.png&quot; alt=&quot;&quot;&gt;
      
    
    </summary>
    
    
      <category term="llvm,iOS,oc" scheme="https://iweiyun.github.io/tags/llvm-iOS-oc/"/>
    
  </entry>
  
  <entry>
    <title>不一样的JavaScript</title>
    <link href="https://iweiyun.github.io/2018/10/15/js-interesting/"/>
    <id>https://iweiyun.github.io/2018/10/15/js-interesting/</id>
    <published>2018-10-15T14:30:08.000Z</published>
    <updated>2018-11-14T12:42:40.370Z</updated>
    
    <content type="html"><![CDATA[<p>js语法看起来是类c的，如果有c语言基础，可以看懂一些js代码，尤其是类似这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只看这段代码，跟c的写法甚至完全一样。很容易让你有种错觉，简单看下js语法，就能写出优秀的js代码。</p><p>但是，不要被骗了，当你看到后面的代码时，就不会再这样想了。下面就列举一些js语法上感觉有趣或比较特别的例子</p><p>​    </p><hr><h4 id="变量声明可以放在使用之后"><a href="#变量声明可以放在使用之后" class="headerlink" title="变量声明可以放在使用之后"></a>变量声明可以放在使用之后</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">3</span>;<span class="comment">// 此处使用</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a;<span class="comment">// 此处声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="对象可以动态的增加属性，不需要提前声明"><a href="#对象可以动态的增加属性，不需要提前声明" class="headerlink" title="对象可以动态的增加属性，不需要提前声明"></a>对象可以动态的增加属性，不需要提前声明</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o.p1 = <span class="string">"good"</span>;</span><br><span class="line">o.p2 = <span class="number">35</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">// Object &#123;p1: "good", p2: 35&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="对象的属性也可地动态的删除"><a href="#对象的属性也可地动态的删除" class="headerlink" title="对象的属性也可地动态的删除"></a>对象的属性也可地动态的删除</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">p1</span>: <span class="string">"good"</span>, <span class="attr">p2</span>: <span class="number">35</span>&#125;;</span><br><span class="line"><span class="keyword">delete</span> o.p1;</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">// Object &#123;p2: 35&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="函数也是对象，也有方法。如可以调用length，获取参数个数"><a href="#函数也是对象，也有方法。如可以调用length，获取参数个数" class="headerlink" title="函数也是对象，也有方法。如可以调用length，获取参数个数"></a>函数也是对象，也有方法。如可以调用length，获取参数个数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAdd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myAdd.length);<span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure><p>也是支持自定义的方法添加的</p><hr><h4 id="函数定义时，可以不指定参数，但在使用时可以传任意参数"><a href="#函数定义时，可以不指定参数，但在使用时可以传任意参数" class="headerlink" title="函数定义时，可以不指定参数，但在使用时可以传任意参数"></a>函数定义时，可以不指定参数，但在使用时可以传任意参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noParamFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">noParamFunc(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">// 输出1, 2</span></span><br></pre></td></tr></table></figure><hr><h4 id="可以动态决定函数的定义"><a href="#可以动态决定函数的定义" class="headerlink" title="可以动态决定函数的定义"></a>可以动态决定函数的定义</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hey"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sayHi();<span class="comment">// 根据condition的值输出Hi或Hey</span></span><br></pre></td></tr></table></figure><hr><h4 id="函数可以这样定义"><a href="#函数可以这样定义" class="headerlink" title="函数可以这样定义"></a>函数可以这样定义</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myAdd2 = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">2</span>;</span><br><span class="line">myAdd2(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>这种写法在定义简短的函数以及闭包时会非常简洁</p><p>如写出如下简洁实用的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> longestConsec = <span class="function">(<span class="params">a, k</span>) =&gt;</span> (k &lt; <span class="number">1</span> || a.length &lt; <span class="number">1</span> || k &gt; a.length)</span><br><span class="line">? <span class="string">''</span></span><br><span class="line">: a.map(<span class="function">(<span class="params">_, i, a</span>) =&gt;</span> a.slice(i, i + k).join(<span class="string">''</span>))</span><br><span class="line">.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.length &gt;= b.length ? a : b)</span><br></pre></td></tr></table></figure><hr><h4 id="函数定义时将其赋值给其它变量，则函数名在外部不再可用"><a href="#函数定义时将其赋值给其它变量，则函数名在外部不再可用" class="headerlink" title="函数定义时将其赋值给其它变量，则函数名在外部不再可用"></a>函数定义时将其赋值给其它变量，则函数名在外部不再可用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'good'</span>);</span><br><span class="line">&#125;</span><br><span class="line">bar();  <span class="comment">// 出错，这儿只能通过foo()来调用</span></span><br><span class="line">foo();  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>但是，如下的写法又是正确的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'good'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = bar;</span><br><span class="line">bar();  <span class="comment">// ok</span></span><br><span class="line">foo();  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><hr><h4 id="在for循环里定义的变量，作用域是超出for的"><a href="#在for循环里定义的变量，作用域是超出for的" class="headerlink" title="在for循环里定义的变量，作用域是超出for的"></a>在for循环里定义的变量，作用域是超出for的</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 仍然可以访问，且是访问的上面的这个i</span></span><br></pre></td></tr></table></figure><hr><h4 id="一元加号，可以将字符串转为数字"><a href="#一元加号，可以将字符串转为数字" class="headerlink" title="一元加号，可以将字符串转为数字"></a>一元加号，可以将字符串转为数字</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+<span class="string">"10"</span><span class="comment">// 就是数值10</span></span><br></pre></td></tr></table></figure><hr><h4 id="数组创建的歧义"><a href="#数组创建的歧义" class="headerlink" title="数组创建的歧义"></a>数组创建的歧义</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看起来相同的写法，但行为预期却不一样</span></span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a1);     <span class="comment">// [3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a2);     <span class="comment">// [] 长度为3的空数组</span></span><br></pre></td></tr></table></figure><hr><h4 id="作用域不注意，可能行为也是不可预期"><a href="#作用域不注意，可能行为也是不可预期" class="headerlink" title="作用域不注意，可能行为也是不可预期"></a>作用域不注意，可能行为也是不可预期</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    subLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subLoop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码本来是想执行100次的循环，但实际只会执行10次</p><hr><h4 id="奇怪的相等判断"><a href="#奇怪的相等判断" class="headerlink" title="奇怪的相等判断"></a>奇怪的相等判断</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ==<span class="string">""</span>            <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span>==<span class="string">"0"</span>           <span class="comment">// true</span></span><br><span class="line"><span class="string">""</span> == <span class="string">"0"</span>           <span class="comment">// false</span></span><br></pre></td></tr></table></figure><hr><h4 id="0-可以用来取整"><a href="#0-可以用来取整" class="headerlink" title="|0 可以用来取整"></a>|0 可以用来取整</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.5</span>  | <span class="number">0</span><span class="comment">// 结果是1</span></span><br><span class="line"><span class="number">-2.5</span> | <span class="number">0</span><span class="comment">// 结果是-2</span></span><br></pre></td></tr></table></figure><p>除此之外，还有很多取整的办法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~~<span class="number">1.5</span><span class="comment">// 1</span></span><br><span class="line"><span class="number">1.5</span> ^ <span class="number">0</span><span class="comment">// 1</span></span><br><span class="line"><span class="number">1.5</span> &lt;&lt; <span class="number">0</span><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><hr><h4 id="奇怪但有效的表达式"><a href="#奇怪但有效的表达式" class="headerlink" title="奇怪但有效的表达式"></a>奇怪但有效的表达式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>][<span class="number">1</span>,<span class="number">2</span>];<span class="comment">// 输出3</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++[[]][+[]]+[+[]];</span><br></pre></td></tr></table></figure><p>这个也是有效的表达式，表达式的值是10。 具体原因可以参考<a href="http://justjavac.com/javascript/2012/05/24/can-you-explain-why-10.html" target="_blank" rel="noopener">这篇文章</a></p><hr><h4 id="JS语法本身是需要分号的"><a href="#JS语法本身是需要分号的" class="headerlink" title="JS语法本身是需要分号的"></a>JS语法本身是需要分号的</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">6</span></span><br><span class="line"><span class="comment">// code</span></span><br></pre></td></tr></table></figure><p>虽然写的代码可以不加分号，在解释执行时，解释器会帮我们补上分号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// code</span></span><br></pre></td></tr></table></figure><p>但有时候依赖于解释器加分号的话，行为可能不是预期的</p><hr><p>​    </p><p><strong>参考资料</strong></p><p><a href="https://bonsaiden.github.io/JavaScript-Garden/zh" target="_blank" rel="noopener">JavaScript秘密花园</a></p><p><a href="https://www.cnblogs.com/venoral/p/5280805.html" target="_blank" rel="noopener">JavaScript之Function函数深入总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;js语法看起来是类c的，如果有c语言基础，可以看懂一些js代码，尤其是类似这样的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
    
      <category term="js,javascript" scheme="https://iweiyun.github.io/tags/js-javascript/"/>
    
  </entry>
  
  <entry>
    <title>利用函数组合提升代码可维护性</title>
    <link href="https://iweiyun.github.io/2018/10/03/func-compose/"/>
    <id>https://iweiyun.github.io/2018/10/03/func-compose/</id>
    <published>2018-10-03T14:24:56.000Z</published>
    <updated>2018-10-03T14:52:23.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>函数组合，在函数式编程里面也是挺重要的概念，能够将函数进行操作合并等，在有些场景下可以大幅度提升代码的可读及可维护性。</p><p>下面就演示一些利用函数组合重构代码以达到更好可维护性的例子</p><h3 id="简单场景"><a href="#简单场景" class="headerlink" title="简单场景"></a>简单场景</h3><p>假设有如下代码： </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process1(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process2(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process3(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process4(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure><p>这些函数来处理字符串，如果要组合调用的话，可能会写出来如下的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = ... </span><br><span class="line">str = process1(str) </span><br><span class="line">str = process2(str) </span><br><span class="line">str = process3(str) </span><br><span class="line">str = process4(str) </span><br><span class="line"><span class="comment">// use str</span></span><br></pre></td></tr></table></figure><p>或者更洒脱一些，写出如下的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ret = process4(process3(process2(process1(str))))</span><br></pre></td></tr></table></figure><p>第二种方式可读性不算太好，第一种方式代码写起来又会非常繁琐。那应该如何来优化呢？</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>Swift中是支持<strong>自定义运算符</strong>的，而且swift中<strong>函数是一等公民</strong>。这两个特性是很强大的，利用他们，可以更好的实现函数的组合，可以让代码看起来更简洁、更易读。</p><p>大概的思路是把process1、process2等进行组合，组合成一个新的函数，调用这个新函数的效果，跟分开挨个调用是一样的。</p><p>优化后的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ++ : <span class="type">AdditionPrecedence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> ++ <span class="params">(lhs: @escaping <span class="params">(String)</span></span></span> -&gt; <span class="type">String</span>, rhs: @escaping (<span class="type">String</span>) -&gt; <span class="type">String</span>) -&gt; (<span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; rhs(lhs($<span class="number">0</span>)) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ret = (process1 ++ process2 ++ process3 ++ process4)(str)</span><br></pre></td></tr></table></figure><p>这样写出来的代码，易读且易维护，要增删操作、调整调用顺序等都是很容易的。</p><h3 id="更多场景"><a href="#更多场景" class="headerlink" title="更多场景"></a>更多场景</h3><p>上面这种场景，是比较特殊的场景，函数签名一致并且是同步函数。在真正工作中更普遍的场景是：</p><ol><li>函数签名不一致，如process1(String)，process2(Int, String)</li><li>函数是异步操作，而且回调的闭包类型也不一样等。</li></ol><h4 id="函数签名不一致"><a href="#函数签名不一致" class="headerlink" title="函数签名不一致"></a>函数签名不一致</h4><p>要能组合函数类型不一致的问题，可以参考：<a href="https://iweiyun.github.io/2018/09/04/curry-cleancode/">利用柯里化去除重复代码</a>，利用柯里化 (严格来说叫partial function application) 可以很容易解决。</p><p>代码示例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">process1(<span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process2(<span class="number">_</span> i: <span class="type">Int</span>, <span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process3(<span class="number">_</span> i: <span class="type">Int</span>, <span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">process4(<span class="number">_</span> i: <span class="type">Int</span>, <span class="number">_</span> param: <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line"></span><br><span class="line">process1 ++ curry(process2) ++ curry(process3) ++ curry(process4)</span><br></pre></td></tr></table></figure><p>不过这儿补充下，有柯里化，就有<strong>反柯里化</strong>。反柯里化就是给函数增加参数，让该函数跟其它函数类型对齐。</p><p>反柯里化的一种简单实现如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uncurry</span><span class="params">(function: @escaping <span class="params">(String)</span></span></span> -&gt; <span class="type">String</span>) -&gt; (<span class="type">String</span>, <span class="type">Int</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; s, <span class="number">_</span> <span class="keyword">in</span> function(s) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用该反柯里化方式，新的组合代码可以适度简化为这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uncuryy(process1) ++ process2 ++ process3 ++ process4</span><br></pre></td></tr></table></figure><p>uncurry完善的实现，可以参考Github上的一些实现，如 <a href="https://github.com/pointfreeco/swift-overture/blob/master/Sources/Overture/Uncurry.swift" target="_blank" rel="noopener">swift-overture</a></p><h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><p>再来看异步操作的问题。</p><p>说到异步处理，如果熟悉一些异步处理框架，如<a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="noopener">PromiseKit</a>或<a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>，那么可能知道PromiseKit里的Promise或RxSwift里的Observable这两个对象。</p><p>仔细想想，Promise和Observable本身就是很有意思的对象，这些对象可以封装异步操作，当然，也可以表示同步操作，表示纯数据等。这些对象本身也提供了很多操作，操作之后，返回的结果仍然是该对象类型。（在函数式编程里面，这两个对象都可以理解为<a href="http://www.ruanyifeng.com/blog/2015/07/monad.html" target="_blank" rel="noopener">Monad</a>对象）</p><p>理解上面这一点是关键，如果Observable本身可以封装异步操作，那么，一个异步操作就可以表达为一个同步函数，只是返回对象是一个代表同步或异步的对象。这样异步的问题就转变为同步处理的问题了。</p><p>下面继续举个简单的例子</p><p>假设有如下4个异步操作：</p><blockquote><p>asyncProcess1<br>asyncProcess2_1<br>asyncProcess2_2<br>asyncProcess3</p></blockquote><p>1、2、3这几个是并发，2_1和2_2是串行</p><p>用RxSwift写的传统代码大概如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">asyncProcess1(param: [<span class="type">String</span>]) -&gt; <span class="type">Observable</span>&lt;<span class="type">Ret</span>&gt; &#123;&#125;</span><br><span class="line">asyncProcess2_1(param1: <span class="type">Int</span>, param2: [<span class="type">String</span>]) -&gt; <span class="type">Observable</span>&lt;<span class="type">Ret</span>&gt; &#123;&#125;</span><br><span class="line">asyncProcess2_2(param: [<span class="type">String</span>]) -&gt; <span class="type">Observable</span>&lt;<span class="type">Ret</span>&gt; &#123;&#125;</span><br><span class="line">asyncProcess3(param: [<span class="type">String</span>]) -&gt; <span class="type">Observable</span>&lt;<span class="type">Ret</span>&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> process2 = <span class="type">Observable</span>.concat(asyncProcess2_1(value, strs), asyncProcess2_2(strs))</span><br><span class="line"><span class="keyword">let</span> process = <span class="type">Observable</span>.merge([asyncProcess1(strs), process2, asyncProcess3(strs)])</span><br><span class="line"><span class="comment">// some code</span></span><br></pre></td></tr></table></figure><p>下面我们就尝试重构下该代码。</p><p>先定义下通用的concat和merge的操作符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并发两个函数，合并成一个函数</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ||| : <span class="type">RxPrecedence</span></span><br><span class="line"><span class="comment">// 串行两个函数，合并成一个函数</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &gt;&gt;&gt; : <span class="type">RxPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">RxOper</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt; = (<span class="type">T</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> ||| &lt;T, U&gt;<span class="params">(lfun: @escaping RxOper&lt;T, U&gt;, rfun: @escaping RxOper&lt;T, U&gt;)</span></span> -&gt; <span class="type">RxOper</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; value <span class="keyword">in</span></span><br><span class="line">        <span class="type">Observable</span>.merge([lfun(value), rfun(value)])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> &gt;&gt;&gt; &lt;T, U&gt;<span class="params">(lfun: @escaping RxOper&lt;T, U&gt;, rfun: @escaping RxOper&lt;T, U&gt;)</span></span> -&gt; <span class="type">RxOper</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; value <span class="keyword">in</span></span><br><span class="line">        lfun(value).concat(rfun(value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写相应的业务代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新的处理代码</span></span><br><span class="line"><span class="keyword">let</span> process = asyncProcess1 ||| (curry(asyncProcess2_1)(value) &gt;&gt;&gt; asyncProcess2_2) ||| asyncProcess3</span><br><span class="line"><span class="comment">// process(strs)...</span></span><br></pre></td></tr></table></figure><p>新代码的优势一目了然。并且这些例子都是拿的非常简单的示例来讲解的，真正的使用场景上，当操作数量逐渐增加，操作逻辑逐渐复杂时，传统的代码写法的冗余就越能显现。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/ijoshsmith/function-composition-in-swift" target="_blank" rel="noopener">Function Composition in Swift</a></p><p><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/" target="_blank" rel="noopener">RxSwift中文文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;函数组合，在函数式编程里面也是挺重要的概念，能够将函数进行操作合并等，在有些场景下可以大幅度提升代码的可读及可维护性。&lt;/p&gt;
&lt;p&gt;下面就
      
    
    </summary>
    
    
      <category term="swift,函数式,函数组合,rxswift,promise" scheme="https://iweiyun.github.io/tags/swift-%E5%87%BD%E6%95%B0%E5%BC%8F-%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88-rxswift-promise/"/>
    
  </entry>
  
  <entry>
    <title>Swift is like Haskell</title>
    <link href="https://iweiyun.github.io/2018/09/27/swift-is-like-haskell/"/>
    <id>https://iweiyun.github.io/2018/09/27/swift-is-like-haskell/</id>
    <published>2018-09-27T13:08:53.000Z</published>
    <updated>2018-11-14T12:47:12.097Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Swift是一门多泛式语言，而且参考了很多其它语言的实现，所以总能在不同语言里看到一些Swift的影子。</p><p>前段时间看到一篇文章，<a href="https://leverich.github.io/swiftislikescala/" target="_blank" rel="noopener">Swift is like Scala</a>，里面做了Swift和Scala一些语法的对比，有些代码块语法上是很像的。最近又看到了<a href="http://nilhcem.com/swift-is-like-kotlin/" target="_blank" rel="noopener">Swift is like Kotlin</a>，<a href="http://repo.tiye.me/jiyinyiyong/swift-is-like-go/" target="_blank" rel="noopener">Swift is like Go</a>。感觉这些挺有趣的，最近刚好有了解一点Haskell，所以就有了这个想法来对比下相似点。</p><p>这儿只是列出两门语言一些类似的点，或语法，或概念上的。但在真正使用的时候，差别还是巨大的。如果想了解真正的工程中，Haskell的使用，可以参考下 <a href="https://github.com/trending/haskell?since=weekly" target="_blank" rel="noopener">Github Haskell Star排名</a>等</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><hr><h5 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello, world!"</span>)</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">putStrLn</span> <span class="string">"hello, world!"</span></span><br></pre></td></tr></table></figure><hr><h5 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- haskell中没有var定义，只能定义不可修改的变量</span></span><br><span class="line"><span class="title">let</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h5 id="显示指定类型"><a href="#显示指定类型" class="headerlink" title="显示指定类型"></a>显示指定类型</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Float</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> a = <span class="number">5</span> :: <span class="type">Float</span></span><br></pre></td></tr></table></figure><hr><h5 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ret = <span class="string">"111"</span> + <span class="string">"222"</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> ret = <span class="string">"111"</span> ++ <span class="string">"222"</span></span><br></pre></td></tr></table></figure><hr><h5 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lst = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> lst = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]</span><br></pre></td></tr></table></figure><hr><h5 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lst = [<span class="number">1</span> ... <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> lst = [<span class="number">1</span> .. <span class="number">5</span>]<span class="comment">-- [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><hr><h5 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAdd</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> a + b &#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myAdd</span> a b = a + b</span><br></pre></td></tr></table></figure><hr><h5 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAdd</span>&lt;T: Numeric&gt;<span class="params">(<span class="number">_</span> a: T, <span class="number">_</span> b: T)</span></span> -&gt; <span class="type">T</span> &#123; <span class="keyword">return</span> a + b &#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myAdd</span> a b = a + b</span><br></pre></td></tr></table></figure><hr><h5 id="返回元组"><a href="#返回元组" class="headerlink" title="返回元组"></a>返回元组</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b, a * b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">process</span> a b = (a + b, a * b)</span><br></pre></td></tr></table></figure><hr><h5 id="操作符另外的调用方式"><a href="#操作符另外的调用方式" class="headerlink" title="操作符另外的调用方式"></a>操作符另外的调用方式</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(+)(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">// 输出3</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(+) <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><hr><h5 id="自定义操作符"><a href="#自定义操作符" class="headerlink" title="自定义操作符"></a>自定义操作符</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;^&gt; : <span class="type">AdditionPrecedence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> &lt;^&gt;<span class="params">(lhs: Int, rhs: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> lhs + rhs &#125;</span><br><span class="line"><span class="number">5</span> &lt;^&gt; <span class="number">6</span><span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&lt;^&gt;) :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">a</span> &lt;^&gt; b = a + b</span><br><span class="line"><span class="number">5</span> &lt;^&gt; <span class="number">6</span><span class="comment">-- 11</span></span><br></pre></td></tr></table></figure><hr><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">2</span>&#125;<span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> (*<span class="number">2</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]<span class="comment">-- [2, 4, 6]</span></span><br></pre></td></tr></table></figure><hr><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">CGPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> x: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> y: <span class="type">CGFloat</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="type">Double</span> <span class="type">Double</span></span></span><br><span class="line">              <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br></pre></td></tr></table></figure><hr><h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> circle(<span class="type">CGPoint</span>, <span class="type">CGFloat</span>)</span><br><span class="line">    <span class="keyword">case</span> rectangle(<span class="type">CGPoint</span>, <span class="type">CGFloat</span>, <span class="type">CGFloat</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Point</span> <span class="type">Double</span></span></span><br><span class="line">           | <span class="type">Rectangle</span> <span class="type">Point</span> <span class="type">Double</span> <span class="type">Double</span></span><br><span class="line">             <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br></pre></td></tr></table></figure><hr><h5 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h5><p>​    <font color="gray" size="2"><em>Swift</em></font></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e = <span class="type">Shape</span>.circle(<span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>), <span class="number">100</span>)</span><br><span class="line"><span class="keyword">switch</span> e &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .circle(pt, <span class="number">_</span>):</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .rectangle(pt, <span class="number">_</span>, <span class="number">_</span>):</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <font color="gray" size="2"><em>Haskell</em></font></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">shapeInfo</span> :: <span class="type">Shape</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">shapeInfo</span> (<span class="type">Circle</span> pt _) = <span class="string">"Circle point"</span> ++ show pt</span><br><span class="line"><span class="title">shapeInfo</span> (<span class="type">Rectangle</span> pt _ _) = <span class="string">"Rectangle point"</span> ++ show pt</span><br></pre></td></tr></table></figure><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://cnhaskell.com/index.html" target="_blank" rel="noopener">Real World Haskell 中文版</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;Swift是一门多泛式语言，而且参考了很多其它语言的实现，所以总能在不同语言里看到一些Swift的影子。&lt;/p&gt;
&lt;p&gt;前段时间看到一篇文章
      
    
    </summary>
    
    
      <category term="haskell,swift,函数式" scheme="https://iweiyun.github.io/tags/haskell-swift-%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>利用柯里化去除重复代码</title>
    <link href="https://iweiyun.github.io/2018/09/04/curry-cleancode/"/>
    <id>https://iweiyun.github.io/2018/09/04/curry-cleancode/</id>
    <published>2018-09-04T11:58:01.000Z</published>
    <updated>2018-11-02T10:48:53.937Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Swift中，函数是一等公民</strong></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>最近因为某个类中有重复代码，在“固化思维”重构之后，虽然原来的重复代码去掉了，但又有如下样式的代码，仔细想想，其实还是有重复，如files和dirs的获取，以及对结果的处理，代码是完全一样的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">WeiyunItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">restore</span><span class="params">(dir: WeiyunDir?)</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> files = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> dirs = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunDir</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">WeiyunSDK</span>.sharedInstance()?.restoreRecycleFile(files, dir: dirs, pdirkey: dir?.dirkey, ppdirkey: dir?.pdirkey, block: &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> = err &#123;</span><br><span class="line">                    observer(.error(error))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    observer(.completed)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">()</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> files = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> dirs = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunDir</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">WeiyunSDK</span>.sharedInstance()?.clearRecycleFile(files, dir: dirs, block: &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> = err, !ignoreError(error) &#123;</span><br><span class="line">                    observer(.error(error))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    observer(.completed)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>按传统的思路来写的话，就是将相同的代码抽取到函数里，然后再调用相应函数来避免重复代码。 重构后大概的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">WeiyunItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">splitItems</span><span class="params">()</span></span> -&gt; ([<span class="type">WeiyunFile</span>], [<span class="type">WeiyunDir</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> files = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> dirs = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunDir</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> (files, dirs)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">processResult</span><span class="params">(observer: PrimitiveSequenceType.CompletableObserver, err: Error?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> = err &#123;</span><br><span class="line">            observer(.error(error))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            observer(.completed)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">restore</span><span class="params">(dir: WeiyunDir?)</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> tuple = splitItems()</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">WeiyunSDK</span>.sharedInstance()?.restoreRecycleFile(tuple.<span class="number">0</span>, dir: tuple.<span class="number">1</span>, pdirkey: dir?.dirkey, ppdirkey: dir?.pdirkey, block: &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.processResult(observer: observer, err: err)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">()</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> tuple = splitItems()</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">WeiyunSDK</span>.sharedInstance()?.clearRecycleFile(tuple.<span class="number">0</span>, dir: tuple.<span class="number">1</span>, block: &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.processResult(observer: observer, err: err)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来还ok，除了Completable.create及Disposables.create()之外，基本没有重复代码了。</p><h4 id="继续思考"><a href="#继续思考" class="headerlink" title="继续思考"></a>继续思考</h4><p>不过，这是终点了吗？并不是，毕竟还有部分代码是重复的。</p><p>我们现在换一种思路来思考，第一张截图里面，除了调用的WeiyunSDK的接口不同，传入的参数不同，其它所有代码都是一样的，那么是否可以在这儿做文章？</p><p>再回到开头看下这句话：Swift中函数是一等公民。这句话的意义是说函数也可以被操作、变换、处理等，你想到的基本都能做。</p><p>那么，把函数作为值传入处理函数中，在处理函数中调用处理就ok。通过传入不同的函数，即可实现调用不同的请求。</p><p>但有个很大的问题，函数类型不一样，restoreRecycleFile多了第2、3两个参数！</p><p>如何把restoreRecycleFile和clearRecycleFile变为具有相同参数的函数，就是要解决的问题。</p><p>今天的主角：<strong>柯里化</strong>，就是来解决这个问题的。</p><h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><p>柯里化是一个通用的概念，在函数式编程里面非常重要。它在维基上的定义是：</p><blockquote><p>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p></blockquote><p>就作用来说，柯里化可以改变函数类型，可以提前绑定其中的参数。</p><p>Github上也有一些现成的柯里化开源库，可以直接用的。如<a href="https://github.com/thoughtbot/Curry" target="_blank" rel="noopener">Curry</a>、<a href="https://github.com/robrix/Prelude" target="_blank" rel="noopener">Prelude</a>等</p><p>可以看如何将两个参数变一个参数的简单实现，以及如何使用柯里化：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">curry</span>&lt;A, B, C&gt;<span class="params">(<span class="number">_</span> function: @escaping <span class="params">(<span class="params">(A, B)</span></span></span></span>) -&gt; <span class="type">C</span>) -&gt; (<span class="type">A</span>) -&gt; (<span class="type">B</span>) -&gt; <span class="type">C</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; (a: <span class="type">A</span>) -&gt; (<span class="type">B</span>) -&gt; <span class="type">C</span> <span class="keyword">in</span> &#123; (b: <span class="type">B</span>) -&gt; <span class="type">C</span> <span class="keyword">in</span> function((a, b)) &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAdd</span><span class="params">(a: Int, b: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = curry(myAdd)(<span class="number">5</span>)<span class="comment">// 这样就可以变为只接受一个参数的函数，</span></span><br><span class="line">f(<span class="number">10</span>)<span class="comment">// 可以这样来调用，并且结果是15</span></span><br></pre></td></tr></table></figure><h4 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h4><p>在我们这个需求场景中，是需要提前绑定第2和3个参数，并且返回只接受三个参数的函数，这些开源库没有提供相应实现，不自己实现一个并不复杂：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以绑定2、3参数的curry化函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">curry2_3</span>&lt;A, B, C, D, E, F&gt;<span class="params">(<span class="number">_</span> function: @escaping <span class="params">(A, B, C, D, E)</span></span></span> -&gt; <span class="type">F</span>) -&gt; (<span class="type">C</span>, <span class="type">D</span>) -&gt; (<span class="type">A</span>, <span class="type">B</span>, <span class="type">E</span>) -&gt; <span class="type">F</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="built_in">c</span>, d <span class="keyword">in</span> &#123; a, b, e <span class="keyword">in</span> function(a, b, <span class="built_in">c</span>, d, e) &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把这个函数用上之后，就可以将代码整理成如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">WeiyunItem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">restore</span><span class="params">(dir: WeiyunDir?)</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> f = curry2_3(<span class="type">WeiyunSDK</span>.sharedInstance().restoreRecycleFile)(dir?.dirkey, dir?.pdirkey)</span><br><span class="line">        <span class="keyword">return</span> operate(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">()</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> f = <span class="type">WeiyunSDK</span>.sharedInstance().clearRecycleFile</span><br><span class="line">        <span class="keyword">return</span> operate(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">operate</span><span class="params">(<span class="number">_</span> function: @escaping <span class="params">([WeiyunFile]?, [WeiyunDir]?, RestoreRecycleItemBlock?)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> files = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunFile</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> dirs = compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">WeiyunDir</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            function(files, dirs, &#123; <span class="number">_</span>, <span class="number">_</span>, err <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> = err &#123;</span><br><span class="line">                    observer(.error(error))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    observer(.completed)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就没有任何重复代码了</p><p>这儿只是演示了柯里化非常简单的一种使用场景，在函数式编程中，对函数的处理变换无处不在，柯里化也会大放异彩！</p><blockquote><p>严格来说，curry2_3 这种处理方式，是叫函数部分施用，有些语言里会明确区分这些概念，有些语言里(例如Groovy)没有区分。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Swift中，函数是一等公民&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h4&gt;&lt;p&gt;最近因为某个类中有重复代码，在“固化思维”重构之后，虽然原来的
      
    
    </summary>
    
    
  </entry>
  
</feed>
